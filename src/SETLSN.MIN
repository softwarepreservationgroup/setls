       TTL  S E T L - S -- NOTES TO IMPLEMENTORS
*
*      S E T L - S   V E R S I O N   2 . 3
*
*      (c) 1992
*          New York University
*
*      It is being maintained by
*          Dr. J. VandeKopple
*          715 Broadway, 7th Floor
*          New York University
*          New York, NY 10003
*
*      SETLS versions 2.0 and up are based on SETLS version 1.9, work
*      done by Nigel Chapman at the University of Leeds as part of his
*      Ph.D. thesis work.  It is with his kind permission that we
*      have continued work on the project.
*
*      (c) 1980 - version 1.9
*          This piece of software is being developed by
*              Nigel Chapman,
*              The Department of Computer Studies,
*              The University of Leeds,
*              LEEDS,
*              LS2 9JT
*              England
*
*      SETL-S may not be reproduced or distributed, either in
*      machine-readable form, or otherwise, without the written
*      permission of Nigel Chapman.
*
       TTL  S E T L S  -  REVISION HISTORY
       EJC
*
*      REVISION HISTORY
*      ----------------
*
*      VERSION 2.3 (June 92)
*      _____________________
*
*      BUGS FIXED
*      ----------
*
*      B2.301  After adding .CSED, corrected bug in GBCPF
*              with jump to new label GPF2A.
*      B2.302  While early version had SYSPT.ASM in a separate
*              segment, for Intel model it must share DATA seg.
*
*      CHANGES
*      -------
*
*      C2.301  Add conditional .CGBC to external routine SYSGC.
*              Called at the start and end of garbage collection
*              to perform any needed notification to operating
*              system or user.
*      C2.302  Add sediment algorithm to garbage collector,
*              conditioned on .CSED, with corresponding .CEPP
*              sections.
*      C2.303  SYSAX and .CSAX introduced for Spitbol OSI
*              compatibility - see SYSAX in procedures section.
*      C2.304  Added .CREL conditional and extensive routines
*              (RELOC et. al.) to perform relocation of data
*              in working section, static region, and dynamic
*              region after reload of a saved memory image.
*              Routines RELAJ, RELCR, and RELOC are invoked
*              by OSINT after reloading a save file.
*              It is now possible to reload such an image even
*              if the spitbol compiler and its data structures
*              are reloaded to other addresses.  The working
*              section has been extensively rearranged to
*              accommodate the RELOC procedure.
*      C2.305  Changed VRNML to VRLEN to conform with Spitbol
*              use in RELST.
*      C2.306  With .CSFN, added R$SFC and R$SFN for compatibility
*              with Intel OSINT, though SETLS syntax does not
*              permit the SPITBOL scheme of multiple input files.
*              Also added shortened proc FILNM.
*      C2.307  Changed XCTSC to KVSTC and XCTSN to KVSTN for
*              OSINT compatibility.
*      C2.308  Changed RLBLKs to RUBLKs, to avoid name conflict
*              with RELOC routines.
*      C2.309  Added VCBLKs to data structures, simply to conform
*              to OSINT calls to HOST, which require VCBLKs rather
*              than TPBLKs.
*
*      VERSION 2.2 (January 91)
*      ------------------------
*
*      BUGS FIXED
*      ----------
*
*      B2.201  ICREM repaired so that result of MOD operator is
*              always positive
*      B2.202  Repaired S$RDA and S$GET to reset EOFLG
*      B2.203  IOPUT correction on allocated block size
*      B2.204  When SYSEJ is called, need R$FCB in order to flush
*              output buffers
*
*      CHANGES
*      -------
*
*      C2.201  Added MSREM to provide MOD operator for sets,
*              yielding symmetric difference (proc DFSST)
*      C2.202  Forced all ERR and ERB codes to 3 digits to
*              support Mark Emmer's error utility
*      C2.203  Improper CNE character compare for filename in
*              IOSRC.  Changes made to convert case.  In DOS,
*              should not be case sensitive.  Maybe later set
*              up conditional assembly symbol
*
*      VERSION 2.1 (August 89)
*      -----------------------
*
*      BUGS FIXED
*      ----------
*
*      B2.101  Grammar repaired to correct case expression syntax
*              and Read statement
*      B2.102  CDGEN corrected for C$EXP type when O$COP needed,
*              corrects param passing and enumerated sets & tuples
*      B2.103  Time output corrected to 10ths, not mcsec
*      B2.104  JUMPN repaired for pairs corrects iterator problem
*      B2.105  SCANX corrected for buffer size, allocation of buffer
*      B2.106  Interactive endfile now recognized, not from file
*      B2.107  CDGEN now copies (subscripted) names when forming sets
*              and passing parameters.
*      B2.108  JUMPN repair corrects iteration over pairs.
*      B2.109  For O$WIT, appending OM corrected to have no effect.
*      B2.110  TNBLD repair for CASE stmt in which stmt_block is
*              single stmt, forms C$STM node.
*      B2.111  Repaired STRSB, which tests for substring in given
*              string.  Went 1 char too far in test.
*
*      CHANGES
*      -------
*
*      C2.101  Parser and parse tables now based on the NYU LALR
*              parsing tools.  CMPIL uses tables SYMNO, PTRHS, PTCHK,
*              PTLHS, and PTACT.
*      C2.102  GENST and MSSMA now permit multi-valued map assign.
*      C2.103  New operators:  **, max, min, even, odd, is_xxx,
*              pow, npow, char, ?
*      C2.104  Output to terminal as default
*      C2.105  TNBLD revised to eliminated explicit rule numbers
*      C2.106  Parse tables removed from working storage, placed
*              in separate module, loaded by SYSPT into dynamic mem
*      C2.107  Defined .CEPP and .CRPP, modified GBCOL and GBCPF
*              to resolve problems caused by smaller MXLEN value
*      C2.108  File I/O added - code for INPUT, OUTPUT, READA, PRINTA,
*              GET, & PUT added.  New structures:  IOBLK, FCBLK, XNBLK,
*              and XRBLK.  Grammar mod to add READA.  Revised EOF to
*              recognize for each file.  Added READL for GET string
*              from keyboard.
*      C2.109  Random operator added via sys call to SYSRN.
*      C2.110  Added ASSERT statement.
*      C2.111  Added slices, both reference and assign to.
*      C2.112  To help catch GBCOL problems, revised BLKLN & GBCPF to
*              trap any illegal blocks.  Must now indicate action for
*              all legal block types.
*      C2.113  Added HOST function (particularly for PCs).  Not all
*              cases behave correctly yet because of SPITHOST vs.
*              SCOPS version incompatibility.
*      C2.114  Compound operators (for binary oper) added.  Special
*              arrangement for ?/ since don't need same jumps as ?.
*      C2.115  Added parallel assignment, such as [x,y] := ...
*      C2.116  Added map iterators to permit (for [a,b] in S) and
*              (for b = m(a)).
*
*      VERSION 2.0 (Apr 88)
*      --------------------
*
*      BUGS FIXED
*      ----------
*
*      B2.001  Each BSW assigned a default address for PC translator
*      B2.002  Modified BSW in TNBLD to preserve production number
*      B2.003  Several BTW and WTB needed for machine independence
*      B2.004  Offsets 1(XS) revised to OFFS1(XS), etc.
*      B2.005  Translator bug required revision of LCW for XL and XT
*      B2.006  CDGEN revised to permit enumerated set types
*      B2.007  SETFM and TPLFM now N (not E) procs - stack problems
*      B2.008  TPFRB revised to correct shift for FROMB operator
*      B2.009  STKLN and STKSN revised to get proper byte offset
*      B2.010  Label discard offset in DSCLB corrected
*      B2.011  ABEND parameters not used, so needed to be cleared
*      B2.012  Size of NLSET and NLTUP corrected to *TSSI$
*      B2.013  ALOTS correction for MXLEN size check
*      B2.014  Corrections to count of statement number
*      B2.015  Recovered orig PCBLK in O$RTN procedure return
*      B2.016  TPEQL revised for tuple = pair
*      B2.017  FROMB and FROME now work for pairs
*      B2.018  Tuple former revised to handle explicit om entries
*      B2.019  Garbage in XL had caused intermittent GBCOL problems
*      B2.020  MSFRM repair for elt FROM empty set now pops argument
*      B2.021  In LABST, when cut CCBLK from CMBLK, make sure at least
*                3 words still available in block
*      B2.022  If syntax error, suppress stats in RECV1
*      B2.023  Repair CODEG label jump for ELSEIF to prevent inf loop
*
*      CHANGES
*      ------
*
*      C2.001  Subscript assign to map or tuple revised to permit update
*      C2.002  Added subscript assign and reference for string
*      C2.003  Not permit curly brackets anywhere on lh side
*      C2.004  APPL3 added to permit 3 operands
*      C2.005  Added string concat via SCPLS
*      C2.006  Plus operator added for tuples and pairs
*      C2.007  FINDD and FINDS now permit reuse of dead entries
*      C2.008  Mult of integer by pair or tuple added
*      C2.009  Suppress Form Feed in output for PC version
*
*      DOCUMENTATION REVISIONS
*      -----------------------
*
*      D2.001  Most bug fixes and changes have JVK marker
*      D2.002  Added NYU copyright after confirmation by Nigel Chapman
*      D2.003  Added Revision History section
*
       TTL  S E T L - S  -- BASIC INFORMATION
       EJC
*
*      General structure
*      -----------------
*
*      The system is based to a large extent on the macro
*      Spitbol implementation of Snobol4, being written
*      in Minimal, the implementation language developed
*      for that system, and employing a broadly similar
*      interpretive scheme.  Additionally, the space allocation
*      scheme and garbage collector used in Setl-s have been
*      taken from the earlier system.  The operating sytem
*      interface routines used by Setl-s are identical to the
*      Spitbol Osint - it is hoped, therefore, that implementors
*      having access to a Minimal translator and Spitbol Osint
*      will be able to bring up Setl-s with little difficulty.
*
*      It has been assumed that implementors will in any case be
*      familiar with the Minimal language and Spitbol system.
*      If it is desired to implement Setl-s from scratch on a
*      machine which does not have macro Spitbol, it will be
*      necessary to consult the extensive implementation notes
*      available with Spitbol.
*
.DEF   .CNEX
*      Grammar does not support the spitbol type EXIT() code.
*      Nigel's version of .cnex had a different meaning.
*      In his case, it was used to reduce the working storage
*      section size by leaving the parse tables out at first.
*      The information would have to be recovered by the load
*      module.
*
*      The system comprises two distinct parts - a compiler
*      which transforms the Setl source into an interpretive
*      code (described below) and an interpreter.  Parsing is
*      carried out by the CMPIL procedure, based on the NYU LALR
*      parsing tools.  It includes the parsing actions SHIFT,
*      REDUCE, SHIFT-REDUCE, and ACCEPT.  The actual parse
*      tables have been removed from the Working-Storage section
*      and have been placed in a separate load module.  A call
*      to the routine SYSPT during initialization then loads
*      the tables SYMNO, PTRHS, PTCHK, PTLHS, and PTACT into
*      dynamic memory.  The advantage of using this method is
*      that after parsing, the garbage collector can recover a
*      substantial amount of workspace which was occupied by
*      the parser and make it available to the user program at
*      runtime.
*
       EJC
*
*      Interpretive code format
*      ------------------------
*
*      The interpretive pseudo-code consists of a series of
*      address pointers. The exact format of the code is
*      described in connection with the CDBLK format. The
*      purpose of this section is to give general insight into
*      the interpretive approach involved.
*
*      The basic form of the code is related to reverse polish.
*      In other words, the operands precede the operators which
*      are zero address operators.
*
*      The operands are moved to the top of the main stack and
*      the operators are applied to the top stack entries.
*
*      The actual pointers in the code point to a block whose
*      first word is the address of the interpretor routine
*      to be executed for the code word.
*
*      In the case of operators, the pointer is to a word which
*      contains the address of the operator to be executed. In
*      the case of operands such as constants, the pointer is to
*      the operand itself. Accordingly, all operands contain
*      a field which points to the routine to load the value of
*      the operand onto the stack. In the case of a variable,
*      there are two such pointers. One to load the value and
*      one to store the value.
       EJC
*
*      Internal data representations
*      -----------------------------
*
*      Representation of values
*
*      A value is represented by a pointer to a block which
*      describes the type and particulars of the data value.
       EJC
*
*
*      Organization of data area
*      -------------------------
*
*
*      The data area is divided into two regions.
*
*      Static area
*
*      The static area builds up from the bottom and contains
*      data areas which are allocated dynamically but are never
*      deleted or moved around. The macro-program itself
*      uses the static area for the following.
*
*      1)   All variable blocks (VRBLK).
*
*      2)   The hash table for variable blocks.
*
*      3)   Miscellaneous buffers and work areas (see program
*           initialization section).
*
*      In addition, the system procedures may use this area for
*      input/output buffers, external functions etc. Space in
*      the static region is allocated by calling procedure ALOST
*
*      The following global variables define the current
*      location and size of the static area.
*
*      STATB                 address of start of static area
*      STATE                 address+1 of last word in area.
*
*      The minimum size of static is given approximately by
*           12 + *E$HNB + *E$STS + space for
*           standard print buffer.
       EJC
*
*      Dynamic area
*
*      The dynamic area is built upwards in memory after the
*      static region. Data in this area must all be in standard
*      block formats so that it can be processed by the garbage
*      collector (procedure GBCOL). GBCOL compacts blocks down
*      in this region as required by space exhaustion and can
*      also move all blocks up to allow for expansion of the
*      static region.
*
*      Garbage collection is fundamental to the allocation of
*      space for values. SETL-S uses a very efficient garbage
*      collector which insists that pointers into dynamic store
*      should be identifiable without use of bit tables,
*      marker bits etc. To satisfy this requirement, dynamic
*      memory must not start at too low an address and lengths
*      of objects
*      may not exceed the numerical value of the lowest dynamic
*      address. To avoid either penalizing users with modest
*      requirements or restricting those with greater needs on
*      host systems where dynamic memory is allocated in low
*      addresses, the minimum dynamic address may be specified
*      sufficiently high to permit arbitrarily large SETL-S
*      objects to be created ( with the possibility in extreme
*      cases of wasting large amounts of memory below the
*      start address). This minimum value is made available
*      in variable MXLEN by a system routine, SYSMX.
*      Alternatively SYSMX may indicate that a
*      default may be used in which dynamic is placed
*      at the lowest possible address following static.
*
*      The following global work cells define the location and
*      length of the dynamic area.
*
*      DNAMB                 start of dynamic area
*      DNAMP                 next available location
*      DNAME                 last available location + 1
*
*      DNAMB is always higher than STATE since the ALOST
*      procedure maintains some expansion space above STATE.
*      *** DNAMB must never be permitted to have a value less
*      than that in MXLEN ***
*
*      Space in the dynamic region is allocated by the ALLOC
*      procedure. The dynamic region may be used by system
*      procedures provided that all the rules are obeyed.
       EJC
*
*      Register usage
*      --------------
*
*      (CP)                  code pointer register. Used to
*                            hold a pointer to the current
*                            location in the interpretive pseudo
*                            code (i.e. ptr into a CDBLK).
*
*      (XL,XR)               general index registers. Usually
*                            used to hold pointers to blocks in
*                            dynamic storage. An important
*                            restriction is that the value in
*                            XL must be collectable for
*                            a garbage collect call. A value
*                            is collectable if it either points
*                            outside the dynamic area, or if it
*                            points to the start of a block in
*                            the dynamic area.
*
*      (XS)                  stack pointer. Used to point to
*                            the stack front. The stack may
*                            build up or down and is used
*                            to stack subroutine return points
*                            and other recursively saved data.
*
*      (Xt)                  an alternative name for XL during
*                            its use in accessing stacked items.
*
*      (WA,WB,WC)            general work registers. Cannot be
*                            used for indexing, but may hold
*                            various types of data.
*
*      (IA)                  used for all signed integer
*                            arithmetic, both that used by the
*                            translator and that arising from
*                            use of SETL arithmetic operators
*
*      (RA)                  real accumulator. Used for all
*                            floating point arithmetic.
       EJC
*
*      SETL-S conditional assembly symbols
*      ------------------------------------
*
*      In the SETL-S translator, the following conditional
*      assembly symbols are referred to. To incorporate the
*      features referred to, the MINIMAL source should be
*      prefaced by suitable conditional assembly symbol
*      definitions.
*      In all cases it is permissible to default the definitions
*      in which case the additional features will be omitted
*      from the target code.
*
.DEF   .CAHT                 define to include horizontal tab
.DEF   .CASL                 define to include 26 shifted lettrs
*      .CBSL                 define to include backslash char
*      .CDTL                 define to permit lower case DTC arg
.DEF   .CEPP                 define if entry points have odd parity
.DEF   .CEXP                 define to have SPITBOL pop SYSEX arguments
.DEF   .CGBC                 define to include SYSGC function
.DEF   .CIOD                 define if alternate i/o delimiter
.DEF   .CNOT                 define to include NOT char
.DEF   .CNRA                 define to omit all real arithmetic
*      .CPOL                 define if interface polling desired
.DEF   .CREL                 define to include RELOC routines
.DEF   .CRPP                 define if return points have odd parity
.DEF   .CSAX                 define if SYSAX is to be called
.DEF   .CSBR                 define to include curly set brkts
*      .CSED                 define to use sediment in GBCOL
*      .CSFN                 define to track source file names
*      .CSLL                 define if codes for shifted
*                            letters are less than those for
*                            upper case.
*      .CSN6                 define to pad stmt nos to 6 chars
*      .CSN8                 define to pad stmt nos to 8 chars
.DEF   .CSST                 define to include /SUCH THAT/ char
.DEF   .CTBR                 define to include tuple brackets
*      .cdbg                 define for garbage collector debug
.DEF   .CNPF                 define to disable profiler
*
       TTL  S E T L - S -- PROCEDURES SECTION
*
*      This section starts with descriptions of the operating
*      system dependent procedures which are used by the SETL-S
*      translator. All such procedures have five letter names
*      beginning with sys. They are listed in alphabetical
*      order.
*      All procedures have a  specification consisting of a
*      model call, preceded by a possibly empty list of register
*      contents giving parameters available to the procedure and
*      followed by a possibly empty list of register contents
*      required on return from the call or which may have had
*      their contents destroyed. Only those registers explicitly
*      mentioned in the list after the call may have their
*      values changed.
*      The segment of code providing the external procedures is
*      conveniently referred to as OSINT (operating system
*      interface). The SYSXX procedures it contains provide
*      facilities not usually available as primitives in
*      assembly languages. For particular target machines,
*      implementors may choose for some MINIMAL opcodes which
*      do not have reasonably direct translations, to use calls
*      of additional procedures which they provide in OSINT.
*      E.g. MWB or TRC might be translated as JSR SYSMB,
*      JSR SYSTC in some implementations.
*
*      In the descriptions, reference is made to --BLK
*      formats (-- = a pair of letters). See the SETL-S
*      definitions section for detailed descriptions of all
*      such block formats except FCBLK for which SYSFC should
*      be consulted.
*
*      Section 0 contains INP,INR specifications of internal
*      procedures,routines. This gives a single pass translator
*      information making it easy to generate alternative calls
*      in the translation of JSR-S for procedures of different
*      types if this proves necessary.
*
       SEC                   Start of procedures section
.IF    .CSAX
*
*      SYSAX -- after execution
*
SYSAX  EXP                   Define external entry point
*
*      If the conditional assembly symbol .CSAX is defined,
*      this routine is called immediately after execution and
*      before printing of execution statistics or dump output.
*      Purpose of call is for implementor to determine and
*      if the call is not required it will be omitted if .CSAX
*      is undefined.  In this case SYSAX need not be coded.
*
*      JSR  SYSAX            Call after execution
.ELSE
.FI
*
*      SYSBX -- before execution
*
SYSBX  EXP  E,0              Define external entry point
*
*      Called after initial SETL-S compilation and before
*      commencing execution in case OSINT needs
*      to assign files or perform other necessary services.
*      OSINT may also choose to send a message to online
*      terminal (if any) indicating that execution is starting.
*
*      JSR  SYSBX            call before execution starts
       EJC
*
*      SYSDC -- date check
*
SYSDC  EXP  E,0              Define external entry point
*
*      SYSDC is called to check that the expiry date for a trial
*      version of SETL-S is unexpired.
*
*      JSR  SYSDC            call to check date
*      return only if date is ok
       EJC
*
*
*      SYSDT -- get current date
*
SYSDT  EXP  E,0              Define external entry point
*
*      SYSDT is used to obtain the current date. The date is
*      returned as a character string in any format appropriate
*      to the operating system in use. It may also contain the
*      current time of day. SYSDT is used to implement the
*      SETL function date.
*
*      JSR  SYSDT            call to get date
*      (XL)                  pointer to block containing date
*
*      The format of the block is like an SCBLK except that
*      the first word need not be set. The result is copied
*      into SETL-S dynamic memory on return.
       EJC
*
*      SYSEF -- eject file
*
SYSEF  EXP  E,3              Define external entry point
*
*      SYSEF is used to write a page eject to a named file. It
*      may only be used for files where this concept makes
*      sense. Note that SYSEF is not normally used for the
*      standard output file (see SYSEP).
*
*      (WA)                  ptr to FCBLK or zero
*      (XR)                  eject argument (SCBLK ptr)
*      JSR  SYSEF            call to eject file
*      PPM  LOC              return here if file does not exist
*      PPM  LOC              return here if inappropriate file
*      PPM  LOC              return here if I/O error
       EJC
*
*      SYSEJ -- end of job
*
SYSEJ  EXP  E,0              Define external entry point
*
*      SYSEJ is called once at the end of execution to
*      terminate the run. The significance of the abend and
*      code values is system dependent. In general, the code
*      value should be made available for testing, and the
*      abend value should cause some post-mortem action such as
*      a dump. Note that SYSEJ does not return to its caller.
*      See SYSXI for details of FCBLK chain
*
*      (WA)                  value of abend keyword
*      (WB)                  value of code keyword
*      (XL)                  0 or ptr to head of FCBLK chain
*      JSR  SYSEJ            call to end job
*
*      The following special values are used as codes in (WB)
*      999  execution suppressed
*      998  standard output file full or unavailable in a SYSXI
*           load module. In these cases (WA) contains the number
*           of the statement causing premature termination.
       EJC
*
*      SYSEM -- get error message text
*
SYSEM  EXP  E,0              Define external entry point
*
*      SYSEM is used to obtain the text of ERR, ERB calls in the
*      source program given the error code number. It is allowed
*      to return a null string if this facility is unavailable.
*
*      (WA)                  error code number
*      JSR  SYSEM            call to get text
*      (XR)                  text of message
*
*      The returned value is a pointer to a block in SCBLK
*      format except that the first word need not be set. The
*      string is copied into dynamic memory on return.
*      The null string may be returned if WA is out of range
*      or if no failure message can be returned.
       EJC
*
*      SYSEN -- endfile
*
SYSEN  EXP  E,3              Define external entry point
*
*      SYSEN is used to implement the SETL function endfile.
*      The meaning is system dependent. In general, endfile
*      implies that no further I/O operations will be performed,
*      but does not guarantee this to be the case. The file
*      should be closed after the call, a subsequent read
*      or write may reopen the file at the start or it may be
*      necessary to reopen the file via SYSIO.
*
*      (WA)                  ptr to FCBLK or zero
*      (XR)                  endfile argument (SCBLK ptr)
*      JSR  SYSEN            call to endfile
*      PPM  LOC              return here if file does not exist
*      PPM  LOC              return here if endfile not allowed
*      PPM  LOC              return here if I/O error
*      (WA,WB)               destroyed
*
*      The second error return is used for files for which
*      endfile is not permitted. For example, it may be expected
*      that the standard input and output files are in this
*      category.
       EJC
*
*      SYSEP -- eject printer page
*
SYSEP  EXP  E,0              Define external entry point
*
*      SYSEP is called to perform a page eject on the standard
*      printer output file (corresponding to SYSPR output).
*
*      JSR  SYSEP            call to eject printer output
       EJC
*
*      SYSEX -- CALL EXTERNAL FUNCTION
*
SYSEX  EXP                   DEFINE EXTERNAL ENTRY POINT
*
*      SYSEX IS CALLED TO PASS CONTROL TO AN EXTERNAL FUNCTION
*      PREVIOUSLY LOADED WITH A CALL TO SYSLD.
*
*      (XS)                  POINTER TO ARGUMENTS ON STACK
*      (XL)                  POINTER TO CONTROL BLOCK (EFBLK)
*      (WA)                  NUMBER OF ARGUMENTS ON STACK
*      JSR  SYSEX            CALL TO PASS CONTROL TO FUNCTION
*      PPM  LOC              RETURN HERE IF FUNCTION CALL FAILS
*      PPM  LOC              RETURN HERE IF INSUFFICIENT MEMORY
*      PPM  LOC              RETURN HERE IF BAD ARGUMENT TYPE
.IF    .CEXP
.ELSE
*      (XS)                  POPPED PAST ARGUMENTS
.FI
*      (XR)                  RESULT RETURNED
*
*      THE ARGUMENTS ARE STORED ON THE STACK WITH
*      THE LAST ARGUMENT AT 0(XS). ON RETURN, XS
*      IS POPPED PAST THE ARGUMENTS.
*
*      THE FORM OF THE ARGUMENTS AS PASSED IS THAT USED IN THE
*      SPITBOL TRANSLATOR (SEE DEFINITIONS AND DATA STRUCTURES
*      SECTION). THE CONTROL BLOCK FORMAT IS ALSO DESCRIBED
*      (UNDER EFBLK) IN THIS SECTION.
*
*      THERE ARE TWO WAYS OF RETURNING A RESULT.
*
*      1)   RETURN A POINTER TO A BLOCK IN DYNAMIC STORAGE. THIS
*           BLOCK MUST BE IN EXACTLY CORRECT FORMAT, INCLUDING
*           THE FIRST WORD. ONLY FUNCTIONS WRITTEN WITH INTIMATE
*           KNOWLEDGE OF THE SYSTEM WILL RETURN IN THIS WAY.
*
*      2)   STRING, INTEGER AND REAL RESULTS MAY BE RETURNED BY
*           POINTING TO A PSEUDO-BLOCK OUTSIDE DYNAMIC MEMORY.
*           THIS BLOCK IS IN ICBLK, RCBLK OR SCBLK FORMAT EXCEPT
*           THAT THE FIRST WORD WILL BE OVERWRITTEN
*           BY A TYPE WORD ON RETURN AND SO NEED NOT
*           BE CORRECTLY SET. SUCH A RESULT IS
*           COPIED INTO MAIN STORAGE BEFORE PROCEEDING.
*           UNCONVERTED RESULTS MAY SIMILARLY BE RETURNED IN A
*           PSEUDO-BLOCK WHICH IS IN CORRECT FORMAT INCLUDING
*           TYPE WORD RECOGNISABLE BY GARBAGE COLLECTOR SINCE
*           BLOCK IS COPIED INTO DYNAMIC MEMORY.
       EJC
*
*      SYSFC -- file control block routine
*
SYSFC  EXP  E,1              Define external entry point
*
*      See also SYSIO
*      INPUT and OUTPUT have 3 arguments referred to as shown
*           INPUT(variable name,file arg1,file arg2)
*           OUTPUT(variable name,file arg1,file arg2)
*      File arg1 may be an integer or string used to identify
*      an I/O channel.  It is converted to a string for checking.
*      the exact significance of file arg2.
*      It is not rigorously prescribed but to improve portability,
*      the scheme described in the Spitbol User Manual
*      should be adopted when possible.  The preferred form is
*      a string $F$,R$R$,C$C$,I$I$,...,Z$Z$  where
*      $F$ is an optional file name which is placed first.
*       Remaining items may be omitted or included in any order.
*      $R$ is maximum record length
*      $C$ is a carriage control character or character string
*      $I$ is some form of channel identification used in the
*         absence of $F$ to associate the variable
*         with a file allocated dynamically by JCL commands at
*         Spitbol load time.
*      ,...,Z$Z$ are additional fields
*      If , (comma) cannot be used as a delimiter, .CIOD
*      should be defined to introduce by conditional assembly
*      another delimiter (see
*        IODEL  EQU  *
*      early in definitions section).
*      SYSFC is called when a variable is input or output
*      associated to check file arg1 and arg2 and
*      to report whether an FCBLK (file control
*      block) is necessary and if so what size it should be.
*      This makes it possible for Spitbol rather than Osint to
*      allocate such a block in dynamic memory if required
*      or alternatively in static memory.
*      The significance of an FCBLK, if one is requested, is
*      entirely up to the system interface.  The only retriction
*      is that if the FCBLK should appear to lie in dynamic
*      memory, pointers to it should be proper pointers to
*      the start of a recognisable and garbage collectable
*      block (this condition will be met if SYSFC requests
*      Spitbol to provide an FCBLK).
*      An option is provided for Osint to return a pointer in
*      XL to an FCBLK which it privately allocated.  This ptr
*      will be made available when I/O occurs later.
*      Private PCBLKs may have arbitrary contents and Spitbol
*      stores nothing in them.
       EJC
*      The requested size for an FCBLK in dynamic memory
*      should allow a 2 word overhead for block type and
*      length fields.  Information subsequently stored in the
*      remaining words may be arbitrary if an XNBLK (external
*      non-relocatable block) is requested.  If the request is
*      for an XRBLK (external relocatable block) the
*      contents of words should be collectable (i.e. any
*      apparent pointers into dynamic should be genuine block
*      pointers).  These restrictions do not apply if an FCBLK
*      is allocated outside dynamic or is not allocated at all.
*      If an FCBLK is requested, its fields will be initialised
*      to zero before entry to SYSIO with the exception of
*      words 0 and 1 in which the block type and length
*      fields are placed for FCBLKs in dynamic memory only.
*      For the possible use of SYSEJ and SYSXI, if FCBLKs
*      are used, a chain is built so that they may all be
*      found - see SYSXI for details.
*      If both file arg1 and file arg2 are null, calls of SYSFC
*      and SYSIO are omitted.
*      If file arg1 is null (standard input/output file), SYSFC
*      is called to check non-null file arg2 but any request
*      for an FCBLK will be ignored, since Spitbol handles the
*      standard files specially and cannot readily keep FCBLK
*      pointers for them.
*      File arg1 is type checked by Spitbol so further checking
*      may be unneccessary in many implementations.
*      File arg2 is passed so that SYSFC may analyse and
*      check it.  However to assist in this, Spitbol also passes
*      on the stack the components of this argument with
*      file name, $F$ (otherwise null) extracted and stacked
*      first.
*      The other fields, if any, are extracted as substrings,
*      pointers to them are stacked and a count of all items
*      stacked is placed in WC.  If an FCBLK was earlier
*      allocated and pointed to via file arg1, SYSFC is also
*      passed a pointer to this FCBLK.
*
*      (XL)                  file arg1 SCBLK ptr (2nd arg)
*      (XR)                  file arg2 (3rd arg) or null
*      -(XS)...-(XS)         SCBLKs for $F$,$R$,$C$,...
*      (WC)                  No. of stacked SCBLKs above
*      (WA)                  Existing file arg1 FCBLK ptr or 0
*      (WB)                  0/3 for input/output association
*      JSR  SYSFC            call to check need for FCBLK
*      PPM  LOC              invalid file argument
*      (XS)                  popped (WC) times
*      (WA non zero)         byte size of requested FCBLK
*      (WA=0,XL non zero)    private FCBLK in XL
*      (WA=XL=0)             no FCBLK wanted, no private FCBLK
*      (WC)                  0/1/2 request alloc of XRBLK/XNBLK
*                            /static block for use as FCBLK
*      (WB)                  destroyed
       EJC
*
.IF    .CGBC
*
*      SYSGC -- INFORM INTERFACE OF GARBAGE COLLECTIONS
*
SYSGC  EXP                   DEFINE EXTERNAL ENTRY POINT
*
*      PROVIDES MEANS FOR INTERFACE TO TAKE SPECIAL ACTIONS
*      PRIOR TO AND AFTER A GARBAGE COLLECTION.
*
*      POSSIBLE USAGES-
*      1. PROVIDE VISIBLE SCREEN ICON OF GARBAGE COLLECTION
*         IN PROGRESS
*      2. INFORM VIRTUAL MEMORY MANAGER TO IGNORE PAGE ACCESS
*         PATTERNS DURING GARBAGE COLLECTION.  SUCH ACCESSES
*         TYPICALLY DESTROY THE PAGE WORKING SET ACCUMULATED
*         BY THE PROGRAM.
*      3. INFORM VIRTUAL MEMORY MANAGER THAT CONTENTS OF MEMORY
*         FREED BY GARBAGE COLLECTION CAN BE DISCARDED.
*
*      (XR)                  NON-ZERO IF BEGINNING GC
*                            =0 IF COMPLETING GC
*      (WA)                  DNAMB=START OF DYNAMIC AREA
*      (WB)                  DNAMP=NEXT AVAILABLE LOCATION
*      (WC)                  DNAME=LAST AVAILABLE LOCATION + 1
*      JSR  SYSGC            CALL TO SYSGC FUNCTION
*      ALL REGISTERS PRESERVED
       EJC
.FI
*
*      SYSHS -- GIVE ACCESS TO HOST COMPUTER FEATURES
*
SYSHS  EXP                   DEFINE EXTERNAL ENTRY POINT
*
*      PROVIDES MEANS FOR IMPLEMENTING SPECIAL FEATURES
*      ON DIFFERENT HOST COMPUTERS. THE ONLY DEFINED ENTRY IS
*      THAT WHERE ALL ARGUMENTS ARE NULL IN WHICH CASE SYSHS
*      RETURNS AN SCBLK CONTAINING NAME OF COMPUTER,
*      NAME OF OPERATING SYSTEM AND NAME OF SITE SEPARATED BY
*      COLONS. THE SCBLK NEED NOT HAVE A CORRECT FIRST FIELD
*      AS THIS IS SUPPLIED ON COPYING STRING TO DYNAMIC MEMORY.
*      SPITBOL DOES NO ARGUMENT CHECKING BUT DOES PROVIDE A
*      SINGLE ERROR RETURN FOR ARGUMENTS CHECKED AS ERRONEOUS
*      BY OSINT. IT ALSO PROVIDES A SINGLE EXECUTION ERROR
*      RETURN. IF THESE ARE INADEQUATE, USE MAY BE MADE OF THE
*      MINIMAL ERROR SECTION DIRECT AS DESCRIBED IN MINIMAL
*      DOCUMENTATION, SECTION 10.
*      SEVERAL NON-ERROR RETURNS ARE PROVIDED. THE FIRST
*      CORRESPONDS TO THE DEFINED ENTRY OR, FOR IMPLEMENTATION
*      DEFINED ENTRIES, ANY STRING MAY BE RETURNED. THE OTHERS
*      PERMIT RESPECTIVELY,  RETURN A NULL RESULT, RETURN WITH A
*      RESULT TO BE STACKED WHICH IS POINTED AT BY XR, AND A
*      RETURN CAUSING SPITBOL STATEMENT FAILURE. IF A RETURNED
*      RESULT IS IN DYNAMIC MEMORY IT MUST OBEY GARBAGE
*      COLLECTOR RULES. THE ONLY RESULTS COPIED ON RETURN
*      ARE STRINGS RETURNED VIA PPM LOC3 RETURN.
*
*      (WA)                  ARGUMENT 1
*      (XL)                  ARGUMENT 2
*      (XR)                  ARGUMENT 3
*      JSR  SYSHS            CALL TO GET HOST INFORMATION
*      PPM  LOC1             ERRONEOUS ARG
*      PPM  LOC2             EXECUTION ERROR
*      PPM  LOC3             SCBLK PTR IN XL OR 0 IF UNAVAILABLE
*      PPM  LOC4             RETURN A NULL RESULT
*      PPM  LOC5             RETURN RESULT IN XR
*      PPM  LOC6             CAUSE STATEMENT FAILURE
       EJC
*
*      SYSID -- return system identification
*
SYSID  EXP  E,0              Define external entry point
*
*      This routine should return strings to head the standard
*      printer output. The first string will be appended to
*      a heading line of the form
*           SETL-S version V.V
*      supplied by SETL-S itself. V.V are digits giving the
*      major version number and generally at least a minor
*      version number relating to OSINT should be supplied to
*      give say
*           SETL-S version V.V(M.M)
*      the second string should identify at least the machine
*      and operating system.  Preferably it should include
*      the date and time of the run.
*      Optionally the strings may include site name of the
*      the implementor and/or machine on which run takes place,
*      unique site or copy number and other information as
*      appropriate without making it so long as to be a
*      nuisance to users.
*      The first words of the SCBLKs pointed at need not be
*      correctly set.
*
*      JSR  SYSID            call for system identification
*      (XR)                  SCBLK ptr for addition to header
*      (XL)                  ptr to second header SCBLK
       EJC
*
*      SYSIL -- get input record length
*
SYSIL  EXP  E,0              Define external entry point
*
*      SYSIL is used to get the length of the next input record
*      from a file previously input associated with a SYSIO
*      call. The length returned is used to establish a buffer
*      for a subsequent SYSIN call.
*
*      (WA)                  ptr to FCBLK or zero
*      JSR  SYSIL            call to get record length
*      (WA)                  length or zero if file closed
*
*      No harm is done if the value returned is too long since
*      unused space will be reclaimed after the SYSIN call.
*
*      Note that it is the SYSIL call (not the SYSIO call) which
*      causes the file to be opened as required for the first
*      record input from the file.
       EJC
*
*      SYSIN -- read input record
*
SYSIN  EXP  E,3              Define external entry point
*
*      SYSIN is used to read a record from the file which was
*      referenced in a prior call to SYSIL (i.e. these calls
*      always occur in pairs). The buffer provided is an
*      SCBLK for a string of length set from the SYSIL call.
*      If the actual length read is less than this, the length
*      field of the SCBLK must be modified before returning
*      unless buffer is right padded with zeroes.
*      It is also permissible to take any of the alternative
*      returns after SCBLK length has been modified.
*
*      (WA)                  ptr to FCBLK or zero
*      (XR)                  pointer to buffer (SCBLK ptr)
*      JSR  SYSIN            call to read record
*      PPM  LOC              endfile or no i/P file after SYSXI
*      PPM  LOC              return here if I/O error
*      PPM  LOC              return here if record format error
*      (WA,WB,WC)            destroyed
       EJC
*
*      SYSIO -- input/output file association
*
SYSIO  EXP  E,2              Define external entry point
*
*      See also SYSFC.
*      SYSIO is called in response to a SETL input or output
*      function call except when file arg1 and file arg2
*      are both null.
*      Its call always follows immediately after a call
*      of SYSFC. If SYSFC requested allocation
*      of an FCBLK, its address will be in WA.
*      For input files, non-zero values of $r$ should be
*      copied to WC for use in allocating input buffers. If $r$
*      is defaulted or not implemented, WC should be zeroised.
*      Once a file has been opened, subsequent input(),output()
*      calls in which the second argument is identical with that
*      in a previous call, merely associate the additional
*      variable name (first argument) to the file and do not
*      result in re-opening the file.
*      In subsequent associated accesses to the file a pointer
*      to any FCBLK allocated will be made available.
*
*      (XL)                  file arg1 SCBLK ptr (2nd arg)
*      (XR)                  file arg2 SCBLK ptr (3rd arg)
*      (WA)                  FCBLK ptr (0 if none)
*      (WB)                  0 for input, 3 for output
*      JSR  SYSIO            call to associate file
*      PPM  LOC              return here if file does not exist
*      PPM  LOC              return if input/output not allowed
*      (XL)                  FCBLK pointer (0 if none)
*      (WC)                  0 (for default) or max record lngth
*      (WA,WB)               destroyed
*
*      The second error return is used if the file named exists
*      but input/output from the file is not allowed. For
*      example, the standard output file may be in this category
*      as regards input association.
       EJC
*
*
*      SYSMM -- get more memory
*
SYSMM  EXP  E,0              Define external entry point
*
*      SYSMM is called in an attempt to allocate more dynamic
*      memory. This memory must be allocated contiguously with
*      the current dynamic data area.
*
*      The amount allocated is up to the system to decide. Any
*      value is acceptable including zero if allocation is
*      impossible.
*
*      JSR  SYSMM            call to get more memory
*      (XR)                  number of additional words obtained
       EJC
*
*      SYSMX -- supply MXLEN
*
SYSMX  EXP  E,0              Define external entry point
*
*      Because of the method of garbage collection, no SETL-S
*      object is allowed to occupy more BAUS of memory than
*      the integer giving the lowest address of dynamic
*      (garbage collectable) memory. MXLEN is the name used to
*      refer to this maximum length of an object and for most
*      users of most implementations, provided dynamic memory
*      starts at an address of at least a few thousand words,
*      there is no problem.
*      If the default starting address is less than say 10000 or
*      20000, then a load time option should be provided where a
*      user can request that he be able to create larger
*      objects. This routine informs SETL-S of this request if
*      any. The value returned is either an integer
*      representing the desired value of MXLEN (and hence the
*      minimum dynamic store address which may result in
*      non-use of some store) or zero if a default is acceptable
*      in which MXLEN is set to the lowest address allocated
*      to dynamic store before compilation starts.
*
*      JSR  SYSMX            call to get MXLEN
*      (WA)                  either MXLEN or 0 for default
       EJC
*
*      SYSOU -- output record
*
SYSOU  EXP  E,2              Define external entry point
*
*      SYSOU is used to write a record to a file previously
*      associated with a SYSIO call.
*
*      (WA)                  ptr to FCBLK or zero
*      (XR)                  record to be written (SCBLK)
*      JSR  SYSOU            call to output record
*      PPM  LOC              file full or no file after SYSXI
*      PPM  LOC              return here if I/O error
*      (WA,WB,WC)            destroyed
*
*      Note that it is the SYSOU call (not the SYSIO call) which
*      causes the file to be opened as required for the first
*      record output to the file.
       EJC
*
*      SYSPI -- print on interactive channel
*
SYSPI  EXP  E,1              Define external entry point
*
*      If SETL-S is run from an online terminal, OSINT can
*      request that messages such as copies of compilation
*      errors be sent to the terminal (see SYSPP). If relevant
*      reply was made by SYSPP then SYSPI is called to send such
*      messages to the interactive channel.
*      SYSPI is also used for sending output to the terminal
*      through the special variable name, terminal.
*
*      (XR)                  ptr to line buffer (SCBLK)
*      (WA)                  line length
*      JSR  SYSPI            call to print line
*      PPM  LOC              failure return
*      (WA,WB)               destroyed
       EJC
.IF    .CPOL
*
*      SYSPL -- PROVIDE INTERACTIVE CONTROL OF SPITBOL
*
SYSPL  EXP                   DEFINE EXTERNAL ENTRY POINT
*
*      PROVIDES MEANS FOR INTERFACE TO TAKE SPECIAL ACTIONS,
*      SUCH AS INTERRUPTING EXECUTION, BREAKPOINTING, STEPPING,
*      AND EXPRESSION EVALUATION.  THESE LAST THREE OPTIONS ARE
*      NOT PRESENTLY IMPLEMENTED BY THE CODE CALLING SYSPL.
*
*
*      (WA)                  OPCODE AS FOLLOWS-
*                            =0 POLL TO ALLOW OSINT TO INTERRUPT
*                            =1 BREAKPOINT HIT
*                            =2 COMPLETION OF STATEMENT STEPPING
*                            =3 EXPRESSION EVALUATION RESULT
*      (WB)                  LINE NUMBER
*      R$FCB                 O OR PTR TO HEAD OF FCBLK CHAIN
*      JSR  SYSPL            CALL TO SYSPL FUNCTION
*      PPM  LOC              USER INTERRUPTION
*      PPM  LOC              STEP ONE STATEMENT
*      PPM  LOC              EVALUATE EXPRESSION
*      ---                   RESUME EXECUTION
*                            (WA) = NEW POLLING INTERVAL
*
.FI
*
*      SYSPP -- obtain print parameters
*
SYSPP  EXP  E,0              Define external entry point
*
*      SYSPP is called once during compilation to obtain
*      parameters required for correct printed output format
*      and to select other options. It may also be called again
*      after SYSXI when a load module is resumed. In this
*      case the value returned in WA may be less than or equal
*      to that returned in initial call but may not be
*      greater.
*      The information returned is -
*      1.   line length in chars for standard print file
*      2.   no of lines/page. 0 is preferable for a non-paged
*           device (e.g. online terminal) in which case listing
*           page throws are suppressed
*      3.   An initial nolist option to suppress listing
*      4.   Options to suppress listing of compilation and/or
*           execution stats (useful for established programs) -
*           combined with 3. gives possibility of listing
*           file never being opened.
*      5.   Option to have copies of errors sent to an
*           interactive channel in addition to standard printer.
*      6.   Option to keep page headers short (e.g. if listing
*           to an online terminal).
*      7.   An option to choose extended or compact listing
*           format. In the former a page eject and in the latter
*           a few line feeds precede the printing of each
*           of-- listing, compilation statistics, execution
*           output and execution statistics.
*      8.   An option to suppress execution.
*      9.   An option to request that name /terminal/  be pre-
*           associated to an online terminal via SYSPI and SYSRI
*      10.  an intermediate (standard) listing option requiring
*           that page ejects occur in source listings. Redundant
*           if extended option chosen but partially extends
*           compact option.
*      11.  Option to suppress SYSID identification.
*
*      JSR  SYSPP            call to get print parameters
*      (WA)                  print line length in chars
*      (WB)                  number of lines/page
*      (WC)                  bits value ...jihgfedcba where
*                            a = 1 to send error copy to int.ch.
*                            B = 1 means std printer is int. ch.
*                            C = 1 for nolist option
*                            D = 1 to suppress compiln stats
*                            e = 1 to suppress execn stats
*                            F = 1/0 for extnded/compact listing
*                            g = 1 for noexecute
*                            H = 1 pre-associate /terminal/
*                            i = 1 for standard listing options
*                            J = 1 suppresses listing header
       EJC
*
*      SYSPR -- print line on standard output file
*
SYSPR  EXP  E,1              Define external entry point
*
*      SYSPR is used to print a single line on the standard
*      output file.
*
*      (XR)                  pointer to line buffer (SCBLK)
*      (WA)                  line length
*      JSR  SYSPR            call to print line
*      PPM  LOC              too much O/P or no file after SYSXI
*      (WA,WB)               destroyed
*
*      The buffer pointed to is the length obtained from the
*      SYSPP call and is filled out with trailing blanks. The
*      value in WA is the actual line length which may be less
*      than the maximum line length possible. There is no space
*      control associated with the line, all lines are printed
*      single spaced. Note that null lines (WA=0) are possible
*      in which case a blank line is to be printed.
*
*      The error exit is used for systems which limit the amount
*      of printed output. If possible, printing should be
*      permitted after this condition has been signalled once to
*      allow for dump and other diagnostic information.
*      Assuming this to be possible, SETL-S may make more SYSPR
*      calls. If the error return occurs another time, execution
*      is terminated by a call of SYSEJ with ending code 998.
       EJC
*
*      SYSPT -- copy LALR parse table to dynamic region
*
SYSPT  EXP  E,0              Define external extry point
*
*      SYSPT is used to place the LALR parse tables into
*      the dynamic region of memory.  The caller must already
*      have computed the desired size in words of all of the
*      table combined:  Symno map, RHS, Check table, LHS,
*      and the Action table.  It should also have allocated
*      the target memory region (updating DNAMP).  Note that
*      each block has a one word header field.  After return
*      from SYSPT, the caller must still break the large region
*      into individual tables and set the initial addresses of
*      each into the proper R$xxx location for use by CMPIL.
*
*      (WA)                  total size of 5 tables w headers
*      (XR)                  ptr to start of target dynam region
*      JSR  SYSPT
*      (XR)                  ptr reset to init
*
*      SYSRD -- read record from standard input file
*
SYSRD  EXP  E,1              Define external entry point
*
*      SYSRD is used to read a record from the standard input
*      file. The buffer provided is an SCBLK for a string the
*      length of which in characters is given in WC, this
*      corresponding to the maximum length of string which
*      SETL-S is prepared to receive.
*      Default value is 80 characters
*      If fewer than (WC) characters are read, the length
*      field of the SCBLK must be adjusted before returning
*      unless the buffer is right padded with zeroes.
*      It is also permissible to take the alternative return
*      after such an adjustment has been made.
*      SETL-S may continue to make calls after an endfile
*      return so this routine should be prepared to make
*      repeated endfile returns.
*
*      (XR)                  pointer to buffer (SCBLK ptr)
*      (WC)                  length of buffer in characters
*      JSR  SYSRD            call to read line
*      PPM  LOC              endfile or no i/P file after SYSXI
*      (WA,WB,WC)            destroyed
       EJC
*
*      SYSRI -- read record from interactive channel
*
SYSRI  EXP  E,1              Define external entry point
*
*      Reads a record from online terminal for SETL-S variable,
*      terminal. If online terminal is unavailable then code the
*      endfile return only.
*      The buffer provided is of length 120 characters. SYSRI
*      should replace the count in the second word of the SCBLK
*      by the actual character count unless buffer is right
*      padded with zeroes.
*      It is also permissible to take the alternative
*      return after adjusting the count.
*      The end of file return may be used if this makes
*      sense on the target machine (e.g. if there is an
*      eof character.)
*
*      (XR)                  ptr to 120 char buffer (SCBLK ptr)
*      JSR  SYSRI            call to read line from terminal
*      PPM  LOC              end of file return
*      (WA,WB,WC)            may be destroyed
       EJC
*
*      SYSRN -- get a random number (integer)
*
SYSRN  EXP  E,0
*
*      SYSRN is used to obtain a random positive integer number,
*      since reals are not yet implemented.  The value generated
*      is in the range 0 <= random < IA input.  The caller must
*      adjust and recognize that the value of IA cannot result.
*
*      (IA)                  input - upper limit of random
*      JSR  SYSRN            get a random number
*      (IA)                  result  0 <= random < input
*
*      SYSTM -- get execution time so far
*
SYSTM  EXP  E,0              Define external entry point
*
*      SYSTM is used to obtain the amount of execution time
*      used so far since SETL-S was given control. The units
*      are described as milliseconds in the SETL-S output, but
*      the exact meaning is system dependent. Where appropriate,
*      this value should relate to processor rather than clock
*      timing values.
*
*      JSR  SYSTM            call to get timer value
*      (IA)                  time so far in milliseconds
       EJC
.IF    .CNEX
.ELSE
*
*      SYSUL -- UNLOAD EXTERNAL FUNCTION
*
SYSUL  EXP                   DEFINE EXTERNAL ENTRY POINT
*
*      SYSUL IS USED TO UNLOAD A FUNCTION PREVIOUSLY
*      LOADED WITH A CALL TO SYSLD.
*
*      (XR)                  PTR TO CONTROL BLOCK (EFBLK)
*      JSR  SYSUL            CALL TO UNLOAD FUNCTION
*
*      THE FUNCTION CANNOT BE CALLED FOLLOWING A SYSUL CALL
*      UNTIL ANOTHER SYSLD CALL IS MADE FOR THE SAME FUNCTION.
*
*      THE EFBLK CONTAINS THE FUNCTION CODE POINTER AND ALSO A
*      POINTER TO THE VRBLK CONTAINING THE FUNCTION NAME (SEE
*      DEFINITIONS AND DATA STRUCTURES SECTION).
*
*      SYSXI -- EXIT TO PRODUCE LOAD MODULE
*
SYSXI  EXP  E,2              DEFINE EXTERNAL ENTRY POINT
*
*      WHEN SYSXI IS CALLED, XL CONTAINS EITHER A STRING POINTER
*      OR ZERO. IN THE FORMER CASE, THE STRING GIVES THE
*      CHARACTER NAME OF A PROGRAM. THE INTENTION IS THAT
*      SPITBOL EXECUTION SHOULD BE TERMINATED FORTHWITH AND
*      THE NAMED PROGRAM LOADED AND EXECUTED. THIS TYPE OF CHAIN
*      EXECUTION IS VERY SYSTEM DEPENDENT AND IMPLEMENTORS MAY
*      CHOOSE TO OMIT IT OR FIND IT IMPOSSIBLE TO PROVIDE.
*      IF (XL) IS ZERO,IA CONTAINS ONE OF THE FOLLOWING INTEGERS
*
*      -1, -2, -3
*           CREATE IF POSSIBLE A LOAD MODULE CONTAINING ONLY THE
*           IMPURE AREA OF MEMORY WHICH NEEDS TO BE LOADED WITH
*           A COMPATIBLE PURE SEGMENT FOR SUBSEQUENT EXECUTIONS.
*           VERSION NUMBERS TO CHECK COMPATIBILITY SHOULD BE
*           KEPT IN BOTH SEGMENTS AND CHECKED ON LOADING.
*           TO ASSIST WITH THIS CHECK, (XR) ON ENTRY IS A
*           POINTER TO AN SCBLK CONTAINING THE SPITBOL MAJOR
*           VERSION NUMBER V.V (SEE SYSID).
*
*      0    IF POSSIBLE, RETURN CONTROL TO JOB CONTROL
*           COMMAND LEVEL. THE EFFECT IF AVAILABLE WILL BE
*           SYSTEM DEPENDENT.
*
*      +1, +2, +3
*           CREATE IF POSSIBLE A LOAD MODULE FROM ALL OF
*           MEMORY. IT SHOULD BE POSSIBLE TO LOAD AND EXECUTE
*           THIS MODULE DIRECTLY.
*
*      IN THE CASE OF SAVED LOAD MODULES, THE STATUS OF OPEN
*      FILES IS NOT PRESERVED AND IMPLEMENTORS MAY CHOOSE TO
*      OFFER MEANS OF ATTACHING FILES BEFORE EXECUTION OF LOAD
*      MODULES STARTS OR LEAVE IT TO THE USER TO INCLUDE
*      SUITABLE INPUT(), OUTPUT() CALLS IN HIS PROGRAM.
*      SYSXI SHOULD MAKE A NOTE THAT NO I/O CHANNELS,
*      INCLUDING STANDARD FILES, HAVE FILES ATTACHED SO THAT
*      CALLS OF SYSIN, SYSOU, SYSPR, SYSRD SHOULD FAIL UNLESS
*      NEW ASSOCIATIONS ARE MADE FOR THE LOAD MODULE.
*      AT LEAST IN THE CASE OF THE STANDARD OUTPUT FILE, IT IS
*      RECOMMENDED THAT EITHER THE USER BE REQUIRED TO ATTACH
*      A FILE OR THAT A DEFAULT FILE IS ATTACHED, SINCE THE
*      PROBLEM OF ERROR MESSAGES GENERATED BY THE LOAD MODULE
*      IS OTHERWISE SEVERE. AS A LAST RESORT, IF SPITBOL
*      ATTEMPTS TO WRITE TO THE STANDARD OUTPUT FILE AND GETS A
*      REPLY INDICATING THAT SUCH OUPUT IS UNACCEPTABLE IT STOPS
*      BY USING AN ENTRY TO SYSEJ WITH ENDING CODE 998.
*      AS DESCRIBED BELOW, PASSING OF SOME ARGUMENTS MAKES IT
*      CLEAR THAT LOAD MODULE WILL USE A STANDARD OUTPUT FILE.
       EJC
*
*      IF USE IS MADE OF FCBLKS FOR I/O ASSOCIATION, SPITBOL
*      BUILDS A CHAIN SO THAT THOSE IN USE MAY BE FOUND IN SYSXI
*      AND SYSEJ. THE NODES ARE 4 WORDS LONG. THIRD WORD
*      CONTAINS LINK TO NEXT NODE OR 0, FOURTH WORD CONTAINS
*      FCBLK POINTER.
*
*      SYSXI (CONTINUED)
*
*      (XL)                  ZERO OR SCBLK PTR
*      (XR)                  PTR TO V.V SCBLK
*      (IA)                  SIGNED INTEGER ARGUMENT
*      (WB)                  0 OR PTR TO HEAD OF FCBLK CHAIN
*      JSR  SYSXI            CALL TO EXIT
*      PPM  LOC              REQUESTED ACTION NOT POSSIBLE
*      PPM  LOC              ACTION CAUSED IRRECOVERABLE ERROR
*      (REGISTERS)           SHOULD BE PRESERVED OVER CALL
*
*      LOADING AND RUNNING THE LOAD MODULE OR RETURNING FROM
*      JCL COMMAND LEVEL CAUSES EXECUTION TO RESUME AT THE POINT
*      AFTER THE ERROR RETURNS WHICH FOLLOW THE CALL OF SYSXI.
*      THE VALUE PASSED AS EXIT ARGUMENT IS USED TO INDICATE
*      OPTIONS REQUIRED ON RESUMPTION OF LOAD MODULE.
*      +1 OR -1 REQUIRE THAT ON RESUMPTION, SYSID AND SYSPP BE
*      CALLED AND A HEADING PRINTED ON THE STANDARD OUTPUT FILE.
*      +2 OR -2 INDICATE THAT SYSPP WILL BE CALLED BUT NOT SYSID
*      AND NO HEADING WILL BE PUT ON STANDARD OUTPUT FILE.
*      ABOVE OPTIONS HAVE THE OBVIOUS IMPLICATION THAT A
*      STANDARD O/P FILE MUST BE PROVIDED FOR THE LOAD MODULE.
*      +3 OR -3 INDICATE CALLS OF NEITHER SYSID NOR SYSPP
*      AND NO HEADING WILL BE PLACED ON STANDARD OUTPUT FILE.
*      NO RETURN FROM SYSXI IS POSSIBLE IF ANOTHER PROGRAM
*      IS LOADED AND ENTERED.
.FI
       EJC
*
*
*
*      Introduce the internal procedures.
*
ADSEL  INP  R,0
ADTEL  INP  E,0
ALLOC  INP  E,0
ALOCS  INP  E,0
ALOST  INP  E,0
ALOTS  INP  E,0
BLKLN  INP  E,0
CDGEN  INP  R,0
CDWRD  INP  E,0
CHKCP  INP  R,1
CHKMP  INP  E,1
CHKST  INP  E,0
CMBLD  INP  N,0
CMPIL  INP  E,0
CODEG  INP  E,0
COMPV  INP  R,2
COPYV  INP  R,0
DFFNC  INP  E,0
DFINT  INP  E,0
DFSST  INP  E,0
DSCLB  INP  E,0
DTYPE  INP  E,0
ERMSG  INP  E,0
ERTEX  INP  E,0
EXPIC  INP  E,0
.IF    .CSFN
FILNM  INP  E,0
.FI
FINDD  INP  R,3
FINDS  INP  R,3
FMNPW  INP  E,0
FMSET  INP  N,0
FMTPL  INP  N,0
GBCOL  INP  E,0
GBCPF  INP  E,0
GENPC  INP  E,0
.IF    .CNPF
.ELSE
GENPF  INP  E,0
.FI
GENLH  INP  E,0
GENST  INP  E,0
GPOPL  INP  E,0
GPOPR  INP  E,0
GPOPX  INP  E,0
GTINT  INP  E,1
GTNUM  INP  E,1
.IF    .CNRA
.ELSE
GTREA  INP  E,1
.FI
GTSMI  INP  N,2
GTSTG  INP  N,1
HASHS  INP  E,0
HASHV  INP  R,0
ICBLD  INP  E,0
ICCMP  INP  E,3
INSTA  INP  E,0
IOPUT  INP  N,1
IOSRC  INP  E,1
LABCR  INP  E,1
LABRF  INP  E,0
LABST  INP  E,0
       EJC
LCOMP  INP  E,3
LISTR  INP  E,0
LISTT  INP  E,0
NEXTS  INP  E,0
NXTLB  INP  E,0
NXTNP  INP  E,0
NXTVR  INP  E,0
.IF    .CNPF
.ELSE
PFPRH  INP  E,0
.FI
PATCT  INP  E,0
PRINT  INP  E,1
READS  INP  E,0
PRCMP  INP  R,2
PRPAR  INP  E,0
PRTCH  INP  E,0
PRTIC  INP  E,0
PRTIS  INP  E,0
PRTIN  INP  E,0
PRTMI  INP  E,0
PRTMX  INP  E,0
PRTNL  INP  R,0
PRTPG  INP  E,0
PRTPS  INP  E,0
PRTST  INP  R,0
PRTTR  INP  E,0
.IF    .CNPF
.ELSE
PRTWD  INP  E,0
.FI
PRTUP  INP  E,0
.IF    .CNRA
.ELSE
RCBLD  INP  E,0
RCCMP  INP  E,3
.FI
READL  INP  E,1
READR  INP  E,1
.IF    .CREL
RELAJ  INP  E,0
RELCR  INP  E,0
RELDN  INP  E,0
RELOC  INP  E,0
RELST  INP  E,0
RELWS  INP  E,0
.FI
RPLIC  INP  E,0
RPLTP  INP  E,0
RSTRT  INP  E,0
SBSTR  INP  E,0
SCANE  INP  R,0
SCANG  INP  E,0
SCANX  INP  E,0
SCONC  INP  E,0
SELST  INP  E,0
SETTP  INP  E,0
SLICT  INP  N,0
SLTPI  INP  E,0
START  INP  E,0
STCMP  INP  R,2
STNCL  INP  E,2
STRGV  INP  R,0
STRSB  INP  E,2
SYMTS  INP  E,0
TACTN  INP  E,0
TCONC  INP  E,0
TNBLD  INP  N,0
TPCMP  INP  R,2
TUPPR  INP  E,0
TPELT  INP  E,1
TRIMR  INP  E,0
UNION  INP  E,0
       EJC
*
*      Introduce the internal routines
*
APPLX  INR
APPLY  INR
EXCMP  INR
EXFAL  INR
EXINT  INR
EXIOM  INR
EXIOV  INR
EXITS  INR
EXIXR  INR
EXNUL  INR
EXRND  INR
EXREA  INR
EXROV  INR
EXTRU  INR
FAILP  INR
RECOV  INR
SUCCP  INR
SUCRP  INR
XECMP  INR
XEDIV  INR
XEDMR  INR
XEDVI  INR
XEMAX  INR
XEMIN  INR
XEMNS  INR
XEMUL  INR
XENPW  INR
XEOIN  INR
XEPLS  INR
XEREM  INR
XESLE  INR
XESLI  INR
XESLL  INR
XESLN  INR
XESLT  INR
XESL0  INR
XESPA  INR
XESPI  INR
XESPN  INR
XESPS  INR
XESPT  INR
XESPP  INR
XEVAL  INR
       TTL  S E T L - S -- DEFINITIONS AND DATA STRUCTURES
*
*      This section contains all symbol definitions and also
*      pictures of all data structures used in the system.
*
       SEC                   Start of definitions section
*
*      Definitions of machine parameters
*
*      The MINIMAL translator should supply appropriate values
*      for the particular target machine for all the
*      EQU  *
*      definitions given at the start of this section.
*
CFP$A  EQU  *                Number of characters in alphabet
*
CFP$B  EQU  *                BAUS/word addressing factor
*
CFP$C  EQU  *                Number of characters per word
*
CFP$F  EQU  *                Offset in BAUS to chars in
*                            SCBLK. See SCBLK format.
*
CFP$I  EQU  *                Number of words in integer constant
*
CFP$M  EQU  *                Max positive integer in one word
*
CFP$N  EQU  *                Number of bits in one word
*
CFP$R  EQU  *                Number of words in real constant
*
CFP$S  EQU  *                Number of sig digs for real output
*
CFP$X  EQU  *                Max digits in real exponent
*
MXDGS  EQU  CFP$S+CFP$X      Max digits in real number
*
NSTMX  EQU  MXDGS+5          Max space for real (for +0.e+)
       EJC
*
*      Environment parameters
*
*      The SETL-S program is essentially independent of
*      the definitions of these parameters. However, the
*      efficiency of the system may be affected. Consequently,
*      these parameters may require tuning for a given version
*      the values given in comments have been successfully used.
*
*      E$SRS is the number of words to reserve at the end of
*      storage for end of run processing. It should be
*      set as small as possible without causing memory overflow
*      in critical situations (e.g. memory overflow termination)
*      and should thus reserve sufficient space at least for
*      an SCBLK containing say 30 characters.
*
E$SRS  EQU  *                30 Words
*
*      E$STS is the number of words grabbed in a chunk when
*      storage is allocated in the static region. The minimum
*      permitted value is 256/CFP$B. Larger values will lead
*      to increased efficiency at the cost of wasting memory.
*
E$STS  EQU  *                500 Words
*
*      E$CBS is the size of code block allocated initially and
*      the expansion increment if overflow occurs. If this value
*      is too small or too large, excessive garbage collections
*      will occur during compilation and memory may be lost
*      in the case of a too large value.
*
E$CBS  EQU  *                500 Words
*
*      E$HNB  is the number of bucket headers in symbol table.
*      Note that it should always be odd. Larger values will
*      speed up compilation at the
*      expense of additional storage for the hash table.
*
E$HNB  EQU  *                307 headers for symbol hash table
*
*      E$HNW is the maximum number of words of a string
*      name which participate in the string hash algorithm.
*      Larger values give a better hash at the expense of taking
*      longer to compute the hash. There is some optimal value.
*
E$HNW  EQU  *                6 Words
*
*      If the amount of free space left after a garbage
*      collection is small compared to the total amount of space
*      in use garbage collector thrashing is likely to occur as
*      this space is used up.  E$FSP is a measure of the
*      minimum percentage of dynamic memory left as free space
*      before the system routine SYSMM is called to try to
*      obtain more memory.
*
E$FSP  EQU  *                15 Percent
*
.IF    .CSED
*      If the amount of free space left in the sediment
*      after a garbage collection is a significant fraction of
*      the new sediment size, the sediment is marked for
*      collection on the next call to the carbage collector.
*
E$SED  EQU  *                25 Percent
.FI
       EJC
*
*      Definitions of codes for letters
*
CH$LA  EQU  *                Letter A
CH$LB  EQU  *                Letter B
CH$LC  EQU  *                Letter C
CH$LD  EQU  *                Letter D
CH$LE  EQU  *                Letter E
CH$LF  EQU  *                Letter F
CH$LG  EQU  *                Letter G
CH$LH  EQU  *                Letter H
CH$LI  EQU  *                Letter I
CH$LJ  EQU  *                Letter J
CH$LK  EQU  *                Letter K
CH$LL  EQU  *                Letter L
CH$LM  EQU  *                Letter M
CH$LN  EQU  *                Letter N
CH$LO  EQU  *                Letter O
CH$LP  EQU  *                Letter P
CH$LQ  EQU  *                Letter Q
CH$LR  EQU  *                Letter R
CH$LS  EQU  *                Letter S
CH$LT  EQU  *                Letter T
CH$LU  EQU  *                Letter U
CH$LV  EQU  *                Letter V
CH$LW  EQU  *                Letter W
CH$LX  EQU  *                Letter X
CH$LY  EQU  *                Letter Y
CH$L$  EQU  *                Letter Z
*
*      Definitions of codes for digits
*
CH$D0  EQU  *                Digit 0
CH$D1  EQU  *                Digit 1
CH$D2  EQU  *                Digit 2
CH$D3  EQU  *                Digit 3
CH$D4  EQU  *                Digit 4
CH$D5  EQU  *                Digit 5
CH$D6  EQU  *                Digit 6
CH$D7  EQU  *                Digit 7
CH$D8  EQU  *                Digit 8
CH$D9  EQU  *                Digit 9
       EJC
*
*      Definitions of codes for special characters
*
CH$AM  EQU  *                Ampersand
CH$AS  EQU  *                Multiplication symbol (asterisk)
CH$BL  EQU  *                Blank
CH$CL  EQU  *                Colon
CH$CM  EQU  *                Comma
CH$CP  EQU  *                Closing paren
CH$DT  EQU  *                Dot
CH$DL  EQU  *                Dollar
CH$EQ  EQU  *                Equal sign
CH$MN  EQU  *                Minus sign
CH$NM  EQU  *                Number sign
CH$OG  EQU  *                Operator - greater than
CH$OL  EQU  *                Operator - less than
CH$OP  EQU  *                Opening paren
CH$PC  EQU  *                Percent
CH$PL  EQU  *                Plus sign
CH$QU  EQU  *                Interrogation operator (question)
CH$SL  EQU  *                Slash
CH$SM  EQU  *                Semicolon
CH$SQ  EQU  *                Single quote
CH$UN  EQU  *                Underline
*
*      Optional alternative characters
*
.IF    .CIOD
IODEL  EQU  *                i/o delimiter
.FI
.IF    .CSBR
CH$OS  EQU  *                Opening set bracket
CH$CS  EQU  *                Closing set bracket
.FI
.IF    .CTBR
CH$OT  EQU  *                Opening tuple bracket
CH$CT  EQU  *                Closing tuple bracket
.FI
.IF    .CSST
CH$ST  EQU  *                Such that (vertical bar)
.FI
.IF    .CBSL
CH$BS  EQU  *                Backslash
.FI
.IF    .CNOT
CH$NT  EQU  *                NOT symbol
.FI
.IF    .CAHT
*
*      Tab character - syntactically equivalent to blank
*
CH$HT  EQU  *                Horizontal tab
.FI
       EJC
.IF    .CASL
*
*      Lower case or shifted case alphabetic chars
*
CH$$A  EQU  *                Shifted A
CH$$B  EQU  *                Shifted B
CH$$C  EQU  *                Shifted C
CH$$D  EQU  *                Shifted D
CH$$E  EQU  *                Shifted E
CH$$F  EQU  *                Shifted F
CH$$G  EQU  *                Shifted G
CH$$H  EQU  *                Shifted H
CH$$I  EQU  *                Shifted I
CH$$J  EQU  *                Shifted J
CH$$K  EQU  *                Shifted K
CH$$L  EQU  *                Shifted L
CH$$M  EQU  *                Shifted M
CH$$N  EQU  *                Shifted N
CH$$O  EQU  *                Shifted O
CH$$P  EQU  *                Shifted P
CH$$Q  EQU  *                Shifted Q
CH$$R  EQU  *                Shifted R
CH$$S  EQU  *                Shifted S
CH$$T  EQU  *                Shifted T
CH$$U  EQU  *                Shifted U
CH$$V  EQU  *                Shifted V
CH$$W  EQU  *                Shifted W
CH$$X  EQU  *                Shifted X
CH$$Y  EQU  *                Shifted Y
CH$$$  EQU  *                Shifted Z
.IF    .CSLL
LCDIF  EQU  CH$LA-CH$$A      Compute letter case difference
.ELSE
LCDIF  EQU  CH$$A-CH$LA      Compute letter case difference
.FI
.FI
       EJC
.IF    .CDBG
DBSTG  EQU  *                stage to start at
DBFRQ  EQU  *                frequency
       EJC
.FI
*
*      Insert LALR constants here  JVK
*
*      Constants generated by LALR grammar
*
NMTRM  EQU  68               number of terminals
NMSYM  EQU  178              number of symbols
NMRUL  EQU  224              number of rules
P$NST  EQU  228              number of states
P$CHK  EQU  5702             check table size
P$ACT  EQU  5592             action table size
P$SST  EQU  369              start state
P$EOF  EQU  148              eof symbol
P$ACC  EQU  5749             accept action
P$ERA  EQU  5750             error action
*
*      Max number of compiler-generated labels
*
MAXLB  EQU  150
       EJC
*
*      Data block formats and definitions
*
*      The following sections describe the detailed format of
*      all possible data blocks in static and dynamic memory.
*
*      Every block has a name of the form XXBLK where XX is a
*      unique two character identifier. The first word of every
*      block must contain a pointer to a program location in the
*      interpretor which is immediately preceded by an address
*      constant containing the value bl$xx where XX is the block
*      identifier. This provides a uniform mechanism for
*      distinguishing between the various block types.
*
*      In some cases, the contents of the first word is constant
*      for a given block type and merely serves as a pointer
*      to the identifying address constant. However, in other
*      cases there are several possibilities for the first
*      word in which case each of the several program entry
*      points must be preceded by the appropriate constant.
*
*      In each block, some of the fields are relocatable. This
*      means that they may contain a pointer to another block
*      in the dynamic area. (To be more precise, if they contain
*      a pointer within the dynamic area, then it is a pointer
*      to a block). Such fields must be modified by the garbage
*      collector (procedure GBCOL) whenever blocks are compacted
*      in the dynamic region. The garbage collector (actually
*      procedure GBCPF) requires that all such relocatable
*      fields in a block must be contiguous.
       EJC
*
*      The description format uses the following scheme.
*
*      1)   Block title and two character identifier
*
*      2)   Description of basic use of block and indication
*           of circumstances under which it is constructed.
*
*      3)   Picture of the block format. In these pictures low
*           memory addresses are at the top of the page. Fixed
*           length fields are surrounded by i (letter i). Fields
*           which are fixed length but whose length is dependent
*           on a configuration parameter are surrounded by *
*           (asterisk). Variable length fields are surrounded
*           by / (slash).
*
*      4)   Definition of symbolic offsets to fields in
*           block and of the size of the block if fixed length
*           or of the size of the fixed length fields if the
*           block is variable length.
*           Note that some routines such as GBCPF assume
*           certain offsets are equal. The definitions
*           given here enforce this.  Make changes to
*           them only with due care.
*
*      Definitions of common offsets
*
OFFS1  EQU  1
OFFS2  EQU  2
OFFS3  EQU  3
OFFS4  EQU  4
*
*      5)   Detailed comments on the significance and formats
*           of the various fields.
*
*      The order is alphabetical by identification code.
       EJC
*
*      Definitions of block codes
*
*      This table provides a unique identification code for
*      each separate block type. The first word of a block in
*      the dynamic area always contains the address of a program
*      entry point. The block code is used as the entry point id
*      the order of these codes dictates the order of the table
*      used by the datatype function (SCNMT in the constant SEC)
*
*      Block codes for accessible datatypes
*
BL$AA  EQU  0                dummy - for APPLY, ATBLK starts at 1
BL$AT  EQU  BL$AA+1          ATBLK     atom
BL$IC  EQU  BL$AT+1          ICBLK integer
BL$MP  EQU  BL$IC+1
BL$OM  EQU  BL$MP+1          OMEGA
BL$PR  EQU  BL$OM+1          PRBLK     pair
.IF    .CNRA
BL$SC  EQU  BL$PR+1          SCBLK     string
.ELSE
BL$RC  EQU  BL$PR+1          RCBLK     real
BL$SC  EQU  BL$RC+1          SCBLK     string
.FI
BL$ST  EQU  BL$SC+1          STBLK     set block
BL$TP  EQU  BL$ST+1          TPBLK     tuple block
BL$TV  EQU  BL$TP+1          TVBLK  truth value
BL$VC  EQU  BL$TV+1
*
BL$$D  EQU  BL$VC+1          Number of block codes for data
*
*      Other block codes
*
BL$CD  EQU  BL$VC+1          CDBLK     JVK-number correction
BL$PC  EQU  BL$CD+1
BL$PF  EQU  BL$PC+1          PFBLK
*
BL$SN  EQU  BL$PF+1          SNBLK  sym no map
BL$RU  EQU  BL$SN+1          RUBLK  for lhs and rhs tables
BL$CK  EQU  BL$RU+1          CKBLK  for check table
BL$AC  EQU  BL$CK+1          ACBLK  for action table
*
BL$CC  EQU  BL$AC+1          CCBLK
BL$CT  EQU  BL$CC+1          CTBLK  for character table
BL$EF  EQU  BL$CT+1          EFBLK
BL$LR  EQU  BL$EF+1          LRBLK  for label ref
BL$LT  EQU  BL$LR+1          LTBLK  for label table
BL$IO  EQU  BL$LT+1          IOBLK
BL$XN  EQU  BL$IO+1          XNBLK
BL$XR  EQU  BL$XN+1          XRBLK
BL$CM  EQU  BL$XR+1          CMBLK
*
BL$$I  EQU  0                Default identification code
BL$$T  EQU  BL$AC+1          Code for data or trace block
BL$$$  EQU  BL$CM+1          Number of block codes
       EJC
*
*      Field references
*
*      References to the fields of data blocks are symbolic
*      (i.e. use the symbolic offsets) with the following
*      exceptions.
*
*      1)   References to the first word are usually not
*           symbolic since they use the (X) operand format.
*
*      2)   The code which constructs a block is often not
*           symbolic and should be changed if the corresponding
*           block format is modified.
*
*      3)   The PLC and PSC instructions imply an offset
*           corresponding to the definition of CFP$F.
*
*      4)   There are non-symbolic references (easily changed)
*           in the garbage collector (procedures GBCPF, BLKLN).
*
*      5)   The fields idval, fargs appear in several blocks
*           and any changes must be made in parallel to all
*           blocks containing the fields. The actual references
*           to these fields are symbolic with the above
*           listed exceptions.
*
*      6)   Several spots in the code assume that the
*           definitions of the fields VRVAL, TRNXT are
*           the same (these are sections of code which search
*           out along a TRBLK chain from a variable).
*
*      Apart from the exceptions listed, references are symbolic
*      as far as possible and modifying the order or number
*      of fields will not require changes.
       EJC
*
*      COMMON FIELDS FOR FUNCTION BLOCKS
*
*      BLOCKS WHICH REPRESENT CALLABLE FUNCTIONS HAVE TWO
*      COMMON FIELDS AT THE START OF THE BLOCK AS FOLLOWS.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           /                                    /
*           /       REST OF FUNCTION BLOCK       /
*           /                                    /
*           +------------------------------------+
*
FCODE  EQU  0                POINTER TO CODE FOR FUNCTION
FARGS  EQU  1                NUMBER OF ARGUMENTS
*
*      FCODE IS A POINTER TO THE LOCATION IN THE INTERPRETOR
*      PROGRAM WHICH PROCESSES THIS TYPE OF FUNCTION CALL.
*
*      FARGS IS THE EXPECTED NUMBER OF ARGUMENTS. THE ACTUAL
*      NUMBER OF ARGUMENTS IS ADJUSTED TO THIS AMOUNT BY
*      DELETING EXTRA ARGUMENTS OR SUPPLYING TRAILING NULLS
*      FOR MISSING ONES BEFORE TRANSFERRING THOUGH FCODE.
*      A VALUE OF 999 MAY BE USED IN THIS FIELD TO INDICATE A
*      VARIABLE NUMBER OF ARGUMENTS (SEE SVBLK FIELD SVNAR).
*
*      THE BLOCK TYPES WHICH FOLLOW THIS SCHEME ARE.
*
*      FFBLK                 FIELD FUNCTION
*      DFBLK                 DATATYPE FUNCTION
*      PFBLK                 PROGRAM DEFINED FUNCTION
*      EFBLK                 EXTERNAL LOADED FUNCTION
       EJC
*
*      LALR parser action block  (ACBLK)
*
*      The action block and check block (see CKBLK) are used by
*      the LALR parser to determined the parse action to be taken.
*      They are used in the compilation phase only, hence can be
*      collected before execution.
*      Only the type code field is significant.
*
ACTYP  EQU  0
ACSI$  EQU  P$ACT+1
*
*      Atom                  (ATBLK)
*
*      An ATBLK is built by each call to the SETL function
*      NEWAT
*
*           +------------------------------------+
*           I        ATTYP                       I
*           +------------------------------------+
*           *        ATVAL                       *
*           +------------------------------------+
*
ATTYP  EQU  0                Pointer to routine B$ATL to load
ATVAL  EQU  ATTYP+1          Print value
ATSI$  EQU  ATVAL+CFP$I
*
*      The integer value in the ATVAL field is for printing
*      only -- the value of an atom is its address, hence
*      atoms are built in static, and never copied.
*
       EJC
*
*      Code construction block (CCBLK)
*
*      At any one moment there is at most one CCBLK into
*      which the compiler is currently storing code (CDWRD).
*
*           +------------------------------------+
*           I                CCTYP               i
*           +------------------------------------+
*           i                CCLEN               i
*           +------------------------------------+
*           i                CCUSE               i
*           +------------------------------------+
*           /                                    /
*           /                CCCOD               /
*           /                                    /
*           +------------------------------------+
*
CCTYP  EQU  0                Pointer to dummy routine B$CCT
CCLEN  EQU  CCTYP+1          Length of CCBLK in BAUS
CCUSE  EQU  CCLEN+1          Offset past last used word (BAUS)
CCCOD  EQU  CCUSE+1          Start of generated code in block
*
*      The reason that the CCBLK is a separate block type from
*      the usual CDBLK is that the garbage collector must
*      only process those fields which have been set (see GBCPF)
       EJC
*
*      Code block (CDBLK)
*
*      A code block is built for each statement compiled during
*      the initial compilation.
*
*           +------------------------------------+
*           I                CDJMP               i
*           +------------------------------------+
*           i                CDSTM               i
*           +------------------------------------+
*           i                CDLEN               i
*           +------------------------------------+
*           /                                    /
*           /                CDCOD               /
*           /                                    /
*           +------------------------------------+
*
CDJMP  EQU  0                Ptr to routine to execute statement
CDSTM  EQU  CDJMP+1          Statement number
CDLEN  EQU  OFFS2            Length of CDBLK in BAUS
CDCOD  EQU  CDLEN+1          Executable pseudo-code
CDSI$  EQU  CDCOD            Number of standard fields in CDBLK
*
*      CDSTM is the statement number of the current statement.
*
*      LALR Check table block  (CKBLK)
*
*      The action table and check table are the two LALR table
*      used in determining the next parse action to be taken.
*      Only one such table is needed during compilation.  It is
*      collected before execution.
*      Only the type code field is significant.
*
CKTYP  EQU  0
CKSI$  EQU  P$CHK+1          Type code + Size of check table
       EJC
*
*      Compiler block (CMBLK)
*
*      A CMBLK is built for each node in the tree representation
*      of a program.
*
*      CMBLKs come in a variety of shapes and sizes, but it is
*      convenient to group them together under the same block
*      type
*
*
*           +------------------------------------+
*           I                CMIDN               i
*           +------------------------------------+
*           i                CMLEN               i
*           +------------------------------------+
*           i                CMTYP               i
*           +------------------------------------+
*           /                                    /
*           /        CMVLS                       /
*           /                                    /
*           +------------------------------------+
*
*
CMIDN  EQU  0                Pointer to dummy routine b$cmt
CMLEN  EQU  CMIDN+1          Length of CMBLK in BAUS
CMTYP  EQU  CMLEN+1          Type (c$xxx, see list below)
CMVLS  EQU  CMTYP+1
*
*      The above fields are common to all types of CMBLK.
*      The remaining definitions apply only to particular
*      types.
*
*      Expression list or statement list element
*
*      (CMTYP = C$EXP or C$STM)
*
CMLHD  EQU  CMVLS            ptr to list head (others on list)
CMLTL  EQU  CMLHD+1          ptr to list tail (current entry)
*
*      IF statement   (CMTYP = C$IFS)
*      or Truth Value Operator (AND, OR, IMP) (CMTYP = C$TVO)
*
CMTST  EQU  CMVLS            test expression
CMTHN  EQU  CMTST+1          THEN block
CMELS  EQU  CMTHN+1          ELSE block (0 if none)
CMTVO  EQU  CMELS+1          ptr to string name of operator
*
*      LOOP statement  (CMTYP = C$LUP)
*
CMLPI  EQU  CMVLS            iterator controlling the loop
CMLPB  EQU  CMLPI+1          loop body
*
       EJC
*      Full iterator  (CMTYP = C$FIT)
*
CMINI  EQU  CMVLS            INIT block
CMDNG  EQU  CMINI+1          DOING block
CMWHI  EQU  CMDNG+1          WHILE test
CMSTP  EQU  CMWHI+1          STEP block
CMUNT  EQU  CMSTP+1          UNTIL test
CMTRM  EQU  CMUNT+1          TERM block
       EJC
*
*      Expressions  (CMTYP = C$BOP, C$ASS, or C$CMP)
*                          = C$UOP has no left operand)
*
CMOPR  EQU  CMVLS            operator
CMROP  EQU  CMOPR+1          right/only operand
CMLOP  EQU  CMROP+1          left operand
*
*      Iterator  (CMTYP = C$ITR)
*      lh IN expression
*
CMILH  EQU  CMVLS            left hand
CMIXP  EQU  CMILH+1          expression
CMINX  EQU  CMIXP+1          link, ST test or 0
*
*      Map (or tuple) iterators  (CMTYP = C$MIT or C$MCI)
*      b = m(a)  or  b = m{a}
*
CMMLH  EQU  CMVLS            left hand
CMMID  EQU  CMMLH+1          ident
CMMNX  EQU  CMMID+1          link or 0 (Pos match CMINX)
CMMSB  EQU  CMMNX+1          subscript
*
*      Set or tuple former  (CMTYP = C$FMR)
*
CMFXP  EQU  CMVLS            expression
CMFIT  EQU  CMFXP+1          iterator
*
*      Arithmetic former  (CMTYP = C$ARF)
*      exp1 ... exp2
*
CMAIN  EQU  CMVLS            initial value
CMAST  EQU  CMAIN+1          second value (gives step)
CMALM  EQU  CMAST+1          limit
*
*      Subscripted expression  (CMTYP = C$SUB or C$SBM)
*
CMSXP  EQU  CMVLS            subscripted expression
CMSBS  EQU  CMSXP+1          subscript
*
*      Sliced expression  (CMTYP = C$SLC)
*
CMSLX  EQU  CMVLS            sliced expression
CMSLI  EQU  CMSLX+1          initial subscript
CMSLE  EQU  CMSLI+1          ending subscript
*
*      CASE statement or expression  (CMTYP =C$CAS)
*
CMCEX  EQU  CMVLS            controlling expression
CMCBD  EQU  CMCEX+1          body
*
*      Individual case (CMYTP = C$TAG)
*
CMTGV  EQU  CMVLS            tag values (cexplist)
CMTGB  EQU  CMTGV+1          block
CMTRS  EQU  CMTGB+1          rest - link, ELSE or 0
*
*      Procedure call  (CMTYP = C$CAL)
*
CMPRC  EQU  CMVLS            PCBLK pointer
CMARG  EQU  CMPRC+1          Ptr to argument list
*
*      i-o statement  (CMTYP = C$IOS)
*
CMIOS  EQU  CMVLS            F$xxx ptr to function
CMIOA  EQU  CMIOS+1          argument list
CMIOF  EQU  CMIOA+1          function arg for READA only
       EJC
*
*      Sizes for CMBLKs with n elements
*
CSI$1  EQU  CMVLS+1
CSI$2  EQU  CSI$1+1
CSI$3  EQU  CSI$2+1
CSI$4  EQU  CSI$3+1
CSI$5  EQU  CSI$4+1
CSI$6  EQU  CSI$5+1
       EJC
*
*      List of C$xxx type codes
*
C$EXP  EQU  0                expression list element
C$STM  EQU  C$EXP+1          stament list element
C$IFS  EQU  C$STM+1          IF statement
.IF    .CNPF
C$LUP  EQU  C$IFS+1          LOOP statement
.ELSE
C$TVO  EQU  C$IFS+1          Truth Value Operator (AND/OR/IMP)
C$LUP  EQU  C$TVO+1          LOOP statement
.FI
C$FIT  EQU  C$LUP+1          full iterator
C$BOP  EQU  C$FIT+1          expression node, binary op
C$UOP  EQU  C$BOP+1                           unary
C$ASS  EQU  C$UOP+1                           assigning
C$CMP  EQU  C$ASS+1                           compound oper
C$SET  EQU  C$CMP+1          set
C$TUP  EQU  C$SET+1          tuple
C$ITR  EQU  C$TUP+1          iterator
C$MIT  EQU  C$ITR+1          map or tuple iterator
C$MCI  EQU  C$MIT+1          map (curly) iterator
C$FMR  EQU  C$MCI+1          set or tuple former
C$ARF  EQU  C$FMR+1          arithmetic set or tuple former
C$SUB  EQU  C$ARF+1          subscript ()
C$SBM  EQU  C$SUB+1          subscript {}
C$SLC  EQU  C$SBM+1          slice (a..b)
C$EXR  EQU  C$SLC+1          EXPR block
C$YLD  EQU  C$EXR+1          YIELD
C$EQN  EQU  C$YLD+1          EXISTS quantifier
C$NQN  EQU  C$EQN+1          NOTEXISTS quantifier
C$AQN  EQU  C$NQN+1          FORALL quantifier
C$CAS  EQU  C$AQN+1          CASE statement/expression
C$TAG  EQU  C$CAS+1          individual case
C$IOS  EQU  C$TAG+1          i-o statement
C$CAL  EQU  C$IOS+1          proc call
C$RTN  EQU  C$CAL+1          return
C$DFL  EQU  C$RTN+1          special value for default step etc
C$$$$  EQU  C$DFL+1          number of type codes
       EJC
*
*      Character table block    (CTBLK)
*
*      A CTBLK is used to hold logical character tables
*      for use with ANY, NOTANY, SPAN and BREAK patterns.
*      Each character table can be used to store CFP$N
*      distinct tables as bit columns.  A bit column
*      allocated for each argument of more than one
*      character in length to one of the above listed
*      string primitives.
*
*           +-----------------------------------+
*           I              CTTYP                I
*           +-----------------------------------+
*           *                                   *
*           *                                   *
*           *              CTCHS                *
*           *                                   *
*           *                                   *
*           +-----------------------------------+
*
CTTYP  EQU  0                type field dummy (b$ctt)
CTCHS  EQU  CTTYP+1          start of character table words
CTSI$  EQU  CTCHS+CFP$A      number of words in CTBLK
*
*      CTCHS is CFP$A words long and consists of a one word
*      bit string value for each possible character in the
*      internal alphabet.  Each of the CFP$N possible bits in
*      a bitstring is used to form a column of bit indicators.
*      A bit is set on if the character is in the table and off
*      if the character is not present.
*
       EJC
*
*      EXTERNAL FUNCTION BLOCK (EFBLK)
*
*      AN EXTERNAL FUNCTION BLOCK IS USED TO CONTROL THE CALLING
*      OF AN EXTERNAL FUNCTION. IT IS BUILT BY A CALL TO LOAD.
*
*           +------------------------------------+
*           I                FCODE               I
*           +------------------------------------+
*           I                FARGS               I
*           +------------------------------------+
*           I                EFLEN               I
*           +------------------------------------+
*           I                EFUSE               I
*           +------------------------------------+
*           I                EFCOD               I
*           +------------------------------------+
*           I                EFVAR               I
*           +------------------------------------+
*           I                EFRSL               I
*           +------------------------------------+
*           /                                    /
*           /                EFTAR               /
*           /                                    /
*           +------------------------------------+
*
EFLEN  EQU  FARGS+1          LENGTH OF EFBLK IN BYTES
EFUSE  EQU  EFLEN+1          USE COUNT (FOR OPSYN)
EFCOD  EQU  EFUSE+1          PTR TO CODE (FROM SYSLD)
EFVAR  EQU  EFCOD+1          PTR TO ASSOCIATED VRBLK
EFRSL  EQU  EFVAR+1          RESULT TYPE (SEE BELOW)
EFTAR  EQU  EFRSL+1          ARGUMENT TYPES (SEE BELOW)
EFSI$  EQU  EFTAR            NUMBER OF STANDARD FIELDS IN EFBLK
*
*      THE FCODE FIELD POINTS TO THE ROUTINE B$EFC.
*
*      EFUSE IS USED TO KEEP TRACK OF MULTIPLE USE WHEN OPSYN
*      IS EMPLOYED. THE FUNCTION IS AUTOMATICALLY UNLOADED
*      WHEN THERE ARE NO MORE REFERENCES TO THE FUNCTION.
*
*      EFRSL AND EFTAR ARE TYPE CODES AS FOLLOWS.
*
*           0                TYPE IS UNCONVERTED
*           1                TYPE IS STRING
*           2                TYPE IS INTEGER
.IF    .CNRA
.IF    .CNLF
*           3                TYPE IS FILE
.FI
.ELSE
*           3                TYPE IS REAL
.IF    .CNLF
*           4                TYPE IS FILE
.FI
.FI
       EJC
*
*      Integer constant block (ICBLK)
*
*      An ICBLK is created for every integer referenced or
*      created by a program. Note however that certain internal
*      integer values are stored as addresses (e.g. the length
*      field in a string constant block)
*
*           +------------------------------------+
*           I                ICGET               i
*           +------------------------------------+
*           *                ICVAL               *
*           +------------------------------------+
*
ICGET  EQU  0                Ptr to routine B$ICL to load int
ICVAL  EQU  ICGET+1          Integer value
ICSI$  EQU  ICVAL+CFP$I      Size of ICBLK
*
*      The length of the ICVAL field is CFP$I.
       EJC
*
*      Label Reference   (LRBLK)
*
*      References to compiler-generated labels are chained
*      together - a LRBLK is generated for a forward reference.
*
*      The LRBLKs are kept in three separate lots of chains
*
*      a)      References made in already completed blocks
*              are chained from the corresponding entry in
*             the label table (LTBLK).
*      b)   References made within
*             the block under construction at a particular
*             time are chained from R$LBR, with the fields
*             which will eventually point to the CDBLK in which
*             the reference occurs set to the label number.
*      c)      References to the label whose value is the block
*             under construction are chained from R$LBC. The
*             corresponding entry in the table is set to =R$LBC.
*
*           +------------------------------------+
*           I        LRTYP                       I
*           +------------------------------------+
*           I        LRNXT                       I
*           +------------------------------------+
*           I        LRCDB                       I
*           +------------------------------------+
*           I        LRCOF                       I
*           +------------------------------------+
*
LRTYP  EQU  0                Ptr to dummy rtn B$LBR
LRNXT  EQU  LRTYP+1          Ptr to next LRBLK on chain
LRCDB  EQU  LRNXT+1          Ptr to CDBLK in which reference was
LRCOF  EQU  LRCDB+1          Offset within CDBLK to word of ref
LRSI$  EQU  LRCOF+1          Size of LRBLK
       EJC
*
*      Label table block    (LTBLK)
*
*      LTBLKs are used by the compiler to hold its temporary
*      label tables
*
LTTYP  EQU  0                type field dummy (b$ltb)
LTSI$  EQU  MAXLB+1          size
*
*      All fields are pointers - see LRBLK descriptions and
*      LABRF and LABST procedures
*
       EJC
*
*      PCBLK
*
*      A PCBLK is created by the compiler for every SETL-s
*      procedure declared.
*
*           +------------------------------------+
*           I        PCCAL                       I
*           +------------------------------------+
*           I        PCPVB                       I
*           +------------------------------------+
*           I        PCARG                       I
*           +------------------------------------+
*           I        PCLOC                       I
*           +------------------------------------+
*           I        PCNAR                       I
*           +------------------------------------+
*           I        PCSAV                       I
*           +------------------------------------+
*           I        PCCOD                       I
*           +------------------------------------+
*
PCCAL  EQU  0                Ptr to B$PCC call routine
PCPVB  EQU  PCCAL+1          Ptr to PVBLK
PCARG  EQU  PCPVB+1          Ptr to first argument VRBLK
PCLOC  EQU  PCARG+1          Ptr past local VRBLKs
PCNAR  EQU  PCLOC+1          Number of arguments
PCSAV  EQU  PCNAR+1          Ptr to initial save area on stack
PCCOD  EQU  PCSAV+1          Ptr to code block
PCSI$  EQU  PCCOD+1
*
*      The PCPVB field points to the symbol table entry
*      for the procedure. (See PVBLK)
*
*      PCARG and PCLOC point into static at the VRBLKs for
*      the arguments and locals, which must be contiguous.
*      ALOST is not called by the compiler, except to allocate
*      VRBLKs.
*
*      On first entry to a procedure, locals will have been
*      given their initial values by the compiler.  These are
*      saved on the stack, with PCSAV pointing to them, so
*      INITed variables can be correctly initialised on
*      recursive calls. By unstacking the values on return
*      we assure that variables will be correctly initialised
*      on subsequent entries.
       EJC
*
*      Profile Counts (PFBLK)
*
*      If profiling is requested, a single PFBLK is built in
*      static to hold the profile statistics. None of the
*      fields is collectable.
*
*           +------------------------------------+
*           I             PFTYP                  I
*           +------------------------------------+
*           /                                    /
*           /             PFDTA                  /
*           /                                    /
*           +------------------------------------+
*
PFTYP  EQU  0                ptr to routine B$PFC
PFDTA  EQU  PFTYP+1          start of counts etc.
PFSI$  EQU  PFTYP            size of std fields (PFTYP only)
*
*      The data stored from PFDTA onwards is in pairs of
*
*           +------------------------------------+
*           * Number of executions (integer)     *
*           +------------------------------------+
*           * Total time of executions (int)     *
*           +------------------------------------+
*
*      There is one such pair for each basic block in the
*      program
       EJC
*
*      PRBLK
*
*      A PRBLK is created whwnever an enumerated tuple with 2
*      elements is encountered.  It is used for building maps
*      (see MSBLK and MMBLK), but can also be treated as a
*      tuple.
*           +------------------------------------+
*           I        PRTYP                       I
*           +------------------------------------+
*           I        PRDOM                       I
*           +------------------------------------+
*           I        PRRNG                       I
*           +------------------------------------+
*           I        PRNXT                       I
*           +------------------------------------+
PRTYP  EQU  0                Pointer to routine B$PRL
PRDOM  EQU  PRTYP+1          First element (domain)
PRRNG  EQU  PRDOM+1          Second element (range)
PRNXT  EQU  PRRNG+1          Link when chained in mmap
PRSI$  EQU  PRNXT+1
       EJC
*
*      PVBLK
*
*      A PVBLK is built as the symbol table entry for each
*      procedure name. The format must agree exactly with
*      that of VRBLKs and WDBLKs.
*
*
*           +------------------------------------+
*           I        PVLNK                       I
*           +------------------------------------+
*           I        PVTYP                       I
*           +------------------------------------+
*           I        PVVAL                       I
*           +------------------------------------+
*           I        PVNXT                       I
*           +------------------------------------+
*           I        PVNML                       I
*           +------------------------------------+
*           /                                    /
*           /        PVCHS                       /
*           /                                    /
*           +------------------------------------+
*
*
PVLNK  EQU  0                Link field for proc chain
PVTYP  EQU  PVLNK+1          Type code = T$FNM
PVVAL  EQU  PVTYP+1          Value - ptr to PCBLK
PVNXT  EQU  PVVAL+1          Hash chain link
PVNML  EQU  PVNXT+1          Length of name
PVCHS  EQU  PVNML+1          Characters of name
*
*      The type is in the second word, not the first, so
*      that SCANE can treat PVBLKS and WDBLKs identically.
*      In particular, WDPR1=PVTYP and WDPR2=PVVAL.
*      (Perhaps it would be a good idea to change WDBLKs)
*
*      The PVBLKs are chained together, so that they will be
*      readily accessible.
*      After parsing, the PVVAL fields are set to zero, so
*      that PCBLKs and their associated code will become
*      collectable after they become unreachable.
       EJC
*
*      I-O descriptor block  (IOBLK)
*
IOTYP  EQU  0                 Ptr to dummy rtn B$IOT
IOSCB  EQU  IOTYP+1           Ptr to SCBLK for filearg
IOLNK  EQU  IOSCB+1           Link for FCBLK chain
IOFCB  EQU  IOLNK+1           FCBLK pointer
IOINL  EQU  IOFCB+1           Pointer to input line
IOOFS  EQU  IOINL+1           Offset
IOUSE  EQU  IOOFS+1           0/3 input/output use indicator
IOEOF  EQU  IOUSE+1           non-0 if at eof/else 0
IOSI$  EQU  IOEOF+1           Length of IOBLK
*
*      Map block             (MPBLK)
*
*      An MPBLK is built for all maps created or referenced
*      in a SETL program.
*      A map is a set of pairs, and not, strictly speaking, a
*      separate data-type.  It is necessary for the SETL-s
*      interpreter to keep track of the status of sets
*      containing pairs.
*
*           +------------------------------------+
*           I        MPTYP                       I
*           +------------------------------------+
*           I        MPLEN                       I
*           +------------------------------------+
*           I        MPNEL                       I
*           +------------------------------------+
*           /                                    /
*           /        MPELS                       /
*           /                                    /
*           +------------------------------------+
*
MPTYP  EQU  0                Ptr to load routine B$MPL
MPLEN  EQU  MPTYP+1          Length of MPBLK in BAUs
MPNEL  EQU  MPLEN+1          Number of elements
MPSI$  EQU  MPNEL+1          Length of standard fields
*
*      The format of these fields is identical to that
*      for STBLK and TPBLK.
*
*      Entries are pairs.  If two pairs have the same domain
*      value they are chained together, to give easy multi-
*      valued map references.  Note, however, that a
*      multi-valued map is not treated as aseparate type in
*      this implementation.
*
*
.IF    .CNRA
.ELSE
       EJC
*
*      Real constant block (RCBLK)
*
*      An RCBLK is created for all reals used
*
*           +------------------------------------+
*           I                RCGET               i
*           +------------------------------------+
*           *                RCVAL               *
*           +------------------------------------+
*
RCGET  EQU  0                Ptr to routine B$RCL to load real
RCVAL  EQU  RCGET+1          Real value
RCSI$  EQU  RCVAL+CFP$R      Size of RCBLK
*
*      The length of the RCVAL field is CFP$R.
.FI
       EJC
*
*      LALR Parser Rule Block  (RUBLK)
*
*      For the LALR parser, a table is needed to provide
*      information about the grammar rules.  Two such blocks
*      are needed.
*      For the LHSide, we need to know the number (see SNBLK)
*      of the non-terminal on the left-hand side of the rule.
*      For the RHSide, we need to know the number of items
*      on the right side of the rule, in order to know how
*      many items to pop from the state stack.
*      These blocks are needed only during compilation, and
*      are collected before execution.
*      Only the 0th field, which contains the type code, is
*      significant.
*
RUTYP  EQU  0
RUSI$  EQU  NMRUL+1
*
*      String constant block (SCBLK)
*
*      An SCBLK is built for every string referenced or created
*      by a program.
*
*           +------------------------------------+
*           I                SCGET               i
*           +------------------------------------+
*           i                SCLEN               i
*           +------------------------------------+
*           /                                    /
*           /                SCHAR               /
*           /                                    /
*           +------------------------------------+
*
SCGET  EQU  0                Ptr to routine B$SCL to load string
SCLEN  EQU  SCGET+1          Length of string in characters
SCHAR  EQU  SCLEN+1          Characters of string
SCSI$  EQU  SCHAR            Size of standard fields in SCBLK
*
*      The characters of the string are stored left justified.
*      The final word is padded on the right with zeros.
*      (I.e. the character whose internal code is zero).
*
*      The value of SCLEN may not exceed MXLEN. This ensures
*      that character offsets (e.g. the pattern match cursor)
*      can be correctly processed by the garbage collector.
*
*      Note that the offset to the characters of the string
*      is given in BAUS by CFP$F and that this value is
*      automatically allowed for in PLC, PSC.
*      Note that for a SETL-S SCBLK, the value of CFP$F
*      is given by CFP$B*SCHAR.
       EJC
*
*      LALR Symbol Number table      (SNBLK)
*
*      The LALR parse tables include a mapping which assigns
*      a symbol number for each terminal and non-terminal.
*      Only codes for terminals are needed here.
*      This numeric encoding is used to simplify the use and
*      form of the parse tables.
*      It is used during the compilation phase only.  It must
*      have the proper type word, in case garbage collection
*      occurs during parsing.  It is discarded before
*      execution.
*      Only the type code field is significant.
*
SNTYP  EQU  0
SNSI$  EQU  NMTRM+1
*
*      Set                   (STBLK)
*
*      An STBLK is created for each set created or
*      referenced in a program
*
*           +------------------------------------+
*           I        STTYP                       I
*           +------------------------------------+
*           I        STLEN                       I
*           +------------------------------------+
*           I        STNEL                       I
*           +------------------------------------+
*           /                                    /
*           /        STELS                       /
*           /                                    /
*           +------------------------------------+
*
STTYP  EQU  0                Ptr to load routine B$STL
STLEN  EQU  STTYP+1          Length of STBLK in BAUs
STNEL  EQU  STLEN+1          Number of elements
STSI$  EQU  STNEL+1          Length of standard fields
*
*      The format of these fields is identical to that of
*      MPBLKs (for which they are often used) and TPBLKs
*
       EJC
*      Tuple                 (TPBLK)
*
*      A TPBLK is created for every tuple referenced or created
*      by a program.
*
*           +------------------------------------+
*           I        TPTYP                       I
*           +------------------------------------+
*           I        TPLEN                       I
*           +------------------------------------+
*           I        TPNEL                       I
*           +------------------------------------+
*           /                                    /
*           /        TPELS                       /
*           /                                    /
*           +------------------------------------+
*
TPTYP  EQU  0                Pointer to routine B$TPL
TPLEN  EQU  TPTYP+1          Length of TPBLK in BAUs
TPNEL  EQU  TPLEN+1          Number of elements (cardinality)
TPSI$  EQU  TPNEL+1
*
*      It is useful to define fields for the elements
*      of a two-element tuple, to help when converting
*      between PRBLKs and TPBLKs.
*
TPDOM  EQU  TPSI$
TPRNG  EQU  TPDOM+1
*
*      Note that the first three fields of tuples, sets and maps
*      are identical in format.
*
*      Size of standard fields for these blocks
TSSI$  EQU  TPNEL+1
*
*      Equivalent size in BAUS - for use in NLTUP and NLSET
TBSI1  EQU  CFP$B
TBSI2  EQU  TBSI1+TBSI1
TBSI$  EQU  TBSI2+TBSI1
*
*      Default number of entries in freshly created tuple, set
*      or map
TSNEN  EQU  11
*
*      VECTOR BLOCK (VCBLK)
*
*      JVK - BORROWED FROM SPITBOL ONLY SINCE VCBLKs USED TO
*      PROVIDE PARAMETERS FOR THE HOST FUNCTION OF OSINT.
*      SINCE SETLS USES TPBLKs, MUST TRANSFER INFO TO A VCBLK
*      BEFORE THE CALL TO SYSHS.
*
*      A VCBLK IS USED TO REPRESENT AN ARRAY VALUE WHICH HAS
*      ONE DIMENSION WHOSE LOWER BOUND IS ONE. ALL OTHER ARRAYS
*      ARE REPRESENTED BY ARBLKS. A VCBLK IS CREATED BY THE
*      SYSTEM FUNCTION ARRAY (S$ARR) WHEN PASSED AN INTEGER ARG.
*
*           +------------------------------------+
*           I                VCTYP               I
*           +------------------------------------+
*           I                IDVAL               I
*           +------------------------------------+
*           I                VCLEN               I
*           +------------------------------------+
*           /                                    /
*           /                VCVLS               /
*           /                                    /
*           +------------------------------------+
*
VCTYP  EQU  0                POINTER TO DUMMY ROUTINE B$VCT
VCIDV  EQU  VCTYP+1
VCLEN  EQU  VCIDV+1          LENGTH OF VCBLK IN BYTES
VCVLS  EQU  VCLEN+1          START OF VECTOR VALUES
VCSI$  EQU  VCVLS            SIZE OF STANDARD FIELDS IN VCBLK
*
*      VCVLS ARE EITHER DATA POINTERS OR TRBLK POINTERS
*
*      THE DIMENSION CAN BE DEDUCED FROM VCLEN.
       EJC
*
*      Variable block (VRBLK)
*
*      A variable block is built in the static memory area
*      for every variable referenced or created by a program.
*
*      Note that since these blocks only occur in the static
*      region, it is permissible to point to any word in
*      the block and this is used to provide two distinct
*      access points from the generated code as follows.
*
*      1)   Point to VRGET (first word of VRBLK) to load the
*           value of the variable onto the main stack.
*
*      2)   Point to VRSTO (second word of VRBLK) to store the
*           top stack element as the value of the variable.
*
*           +------------------------------------+
*           I                VRGET               i
*           +------------------------------------+
*           i                VRSTO               i
*           +------------------------------------+
*           i                VRVAL               i
*           +------------------------------------+
*           i                VRNXT               i
*           +------------------------------------+
*           i            (PRCNO) VRLEN           i
*           +------------------------------------+
*           /                                    /
*           /                VRCHS               /
*           /                                    /
*           +------------------------------------+
       EJC
*
*      Variable block (continued)
*
VRGET  EQU  0                Pointer to routine to load value
VRSTO  EQU  VRGET+1          Pointer to routine to store value
VRVAL  EQU  VRSTO+1          Variable value
VRVLO  EQU  VRVAL-VRSTO      Offset to value from store field
VRNXT  EQU  VRVAL+1          Pointer to next VRBLK on hash chain
VRLEN  EQU  VRNXT+1          Length of name (or zero)
VRCHS  EQU  VRLEN+1          Characters of name (VRLEN gt 0)
VRSI$  EQU  VRCHS+1          Number of standard fields in VRBLK
VRSOF  EQU  VRLEN-SCLEN      Offset to dummy SCBLK for name
VRMXL  EQU  64               Max significant length of a name
*
*      VRGET = B$VRL
*
*      VRSTO = B$VRS
*      VRSTO = b$vre if value is protected
*
*      VRVAL points to the appropriate value
*
*      VRNXT points to the next VRBLK on this chain unless
*      this is the end of the chain in which case it is zero.
*
*      VRLEN is the name length for a variable.
*      PRCNO is the sequential procedure number used to
*      distinguish locals from globals and from other locals.
*
*      VRCHS contains characters of the name.
       EJC
*
*      Reserved word block (WDBLK)
*
*      A WDBLK is used to hold information for SETL reserved
*      words such as operators and ELSEIF. The format must
*      agree exactly with that for a VRBLK as regards location
*      of hash chain word and characters of the name since
*      these blocks are inserted along with VRBLKs into the
*      symbol table hash chains
*
*           +------------------------------------+
*           I                WDTYP               i
*           +------------------------------------+
*           i                WDPR1               i
*           +------------------------------------+
*           i                WDPR2               i
*           +------------------------------------+
*           i                WDNXT               i
*           +------------------------------------+
*           i                WDNML               i
*           +------------------------------------+
*           /                                    /
*           /                WDCHS               /
*           /                                    /
*           +------------------------------------+
*
WDTYP  EQU  0                Type of keyword
WDPR1  EQU  WDTYP+1          Properties 1
WDPR2  EQU  WDPR1+1          Properties 2
WDNXT  EQU  WDPR2+1          Ptr to next block on hash chain
WDNML  EQU  WDNXT+1          Name length
WDCHS  EQU  WDNML+1          Chars of name
WDSOF  EQU  WDNML-SCLEN      Offset to dummy SCBLK for name
*
WD$LX  EQU  0                Type for lexical class
WD$OP  EQU  WD$LX+1          Type for operator
WD$KW  EQU  WD$OP+1          Type for keyword
*
*      Note:  Minimal char set limits full details here
*
WOP01  EQU  0                Class 1 operator- IMP
WOP02  EQU  WOP01+1          Class 2 operator- OR
WOP03  EQU  WOP02+1          Class 3 operator- AND
WOP04  EQU  WOP03+1          Class 4 operator- NOT
WOP05  EQU  WOP04+1          Class 5 operator- relops SUBSET INCS NOTIN
WOP07  EQU  WOP05+1          Class 7 operator- LESS LESSF WITH
WOP08  EQU  WOP07+1          Class 8 operator- mult DIV MOD
WOP09  EQU  WOP08+1          Class 9 operator- expon
WOP10  EQU  WOP09+1          Class 10 operator- ABS ARB DOMAIN RANGE
*                                               STR TYPE VAL card
WOP11  EQU  WOP10+1          Class 11 operator- FROM FROMB FROME
       EJC
*
*      WDBLK (continued)
*
WOPAS  EQU  WOP11+1          Assigning operator- oper with assign
WOPCM  EQU  WOPAS+1          Compound operator
WOPEQ  EQU  WOPCM+1          Equals
WOPIN  EQU  WOPEQ+1          IN operator
WOPMN  EQU  WOPIN+1          Minus operator
WOPLS  EQU  WOPMN+1          Plus operator
T$BBB  EQU  WOPLS            max so far
*
*      Unique tokens for keywords
*
WTAST  EQU  T$BBB+1          ASSERT
WTCAS  EQU  WTAST+1          CASE
WTCST  EQU  WTCAS+1          CONST
WTCNT  EQU  WTCST+1          CONT CONTINUE
WT$DO  EQU  WTCNT+1          DO
WTDNG  EQU  WT$DO+1          DOING
WTELS  EQU  WTDNG+1          ELSE
WTELF  EQU  WTELS+1          ELSEIF
WTEND  EQU  WTELF+1          END
WTEXS  EQU  WTEND+1          EXISTS
WTEXP  EQU  WTEXS+1          EXPR
WTFOR  EQU  WTEXP+1          FOR
WTFRL  EQU  WTFOR+1          FORALL
WT$IF  EQU  WTFRL+1          IF
WTINI  EQU  WT$IF+1          INIT
WTLOO  EQU  WTINI+1          LOOP
WTNXS  EQU  WTLOO+1          NOTEXISTS
WT$OF  EQU  WTNXS+1          OF
WTPAS  EQU  WT$OF+1          PASS
WTPRC  EQU  WTPAS+1          PROCEDURE PROC
WTPRG  EQU  WTPRC+1          PROGRAM PROG
WTPRT  EQU  WTPRG+1          PRINT PRINTA
WTQUI  EQU  WTPRT+1          QUIT
WTREA  EQU  WTQUI+1          READ READL
WTRDA  EQU  WTREA+1          READA GET
WTRTN  EQU  WTRDA+1          RETURN
WT$ST  EQU  WTRTN+1          ST WHERE
WTSTP  EQU  WT$ST+1          STEP
WTSTO  EQU  WTSTP+1          STOP
WTTRM  EQU  WTSTO+1          TERM
WTTHN  EQU  WTTRM+1          THEN
WTUNT  EQU  WTTHN+1          UNTIL
WTVAR  EQU  WTUNT+1          VAR
WTWHI  EQU  WTVAR+1          WHILE
WTYLD  EQU  WTWHI+1          YIELD
T$CCC  EQU  WTYLD            Max code used so far
       EJC
*
*      Syntax type codes
*
*      These codes are returned from the SCANE procedure.
*
T$LPR  EQU  T$CCC+1          Left paren
T$RPR  EQU  T$LPR+1          Right paren
T$LSB  EQU  T$RPR+1          Left set bracket
T$RSB  EQU  T$LSB+1          Right set bracket
T$LTB  EQU  T$RSB+1          Left tuple bracket
T$RTB  EQU  T$LTB+1          Right tuple bracket
T$COL  EQU  T$RTB+1          Colon
T$ASG  EQU  T$COL+1          Assignment operator
T$CMA  EQU  T$ASG+1          Comma
T$SMC  EQU  T$CMA+1          Semicolon
T$ITR  EQU  T$SMC+1          Iterator range
T$CON  EQU  T$ITR+1          Constant
T$RNM  EQU  T$CON+1          Reserved name- TRUE FALSE NEWAT OM
*                                           EOF TIME DATE
T$STR  EQU  T$RNM+1          String
T$FNA  EQU  T$STR+1          Function name
T$VAR  EQU  T$FNA+1          Variable
T$EOF  EQU  T$VAR+1          (Parser end marker)
T$ACC  EQU  T$EOF+1          (Augmented grammar start symbol)
ERR$$  EQU  T$VAR+1          error symbol type code
*
*      External non-relocatable block  (XNBLK)
*
*      An XNBLK is a block representing an unknown (external)
*      data value. The block contains no pointers to other
*      relocatable blocks.  An XNBLK is used by external function
*      processing or possibly for system I/O routines etc.
*      The MACRO-system itself does not use XNBLKs.
*      This type of block may be used as a file control block.
*      See SYSFC, SYSIN, SYSOU, S$INP, S$OUP for details.
*
*           +-----------------------------------+
*           I              XNTYP                I
*           +-----------------------------------+
*           I              XNLEN                I
*           +-----------------------------------+
*           /                                   /
*           /              XNDTA                /
*           /                                   /
*           +-----------------------------------+
*
XNTYP  EQU  0                Pointer to dummy routine B$XNT
XNLEN  EQU  XNTYP+1          Length of XNBLK in bytes
XNDTA  EQU  XNLEN+1          Data words
XNSI$  EQU  XNDTA            Size of standard fields in XNBLK
*
*      Note that the term non-relocatable refers to the contents
*      and not the block itself. An XNBLK can be moved around if
*      is built in the dynamic memory area.
       EJC
*
*      External relocatable block  (XRBLK)
*
*      An XRBLK is a block representing an unknown (external)
*      data value. THe data area in this block consists only
*      of address values and any addresses pointing into the
*      dynamic memory area must point to the start of other
*      data blocks. See also description of XNBLK.
*      This type of block may be used as a file control block.
*      See SYSFC, SYSIN, SYSOU, S$INP, S$OUP for details
*
*           +-----------------------------------+
*           I              XRTYP                I
*           +-----------------------------------+
*           I              XRLEN                I
*           +-----------------------------------+
*           /                                   /
*           /              XRPTR                /
*           /                                   /
*           +-----------------------------------+
*
XRTYP  EQU  0                Pointer to dummy routine B$XRT
XRLEN  EQU  XRTYP+1          Length of XRBLK in bytes
XRPTR  EQU  XRLEN+1          Start of address pointers
XRSI$  EQU  XRPTR            Size of standard fields in XRBLK
*
       EJC
*
*      Stack offsets used by CDGEN procedure
*
*      IF statement
*
CDIL2  EQU  0                exit label
CDIL1  EQU  CDIL2+1          else label
CDICM  EQU  CDIL1+1          save CMBLK
*
*      CASE statement or expression
*
CDCL2  EQU  0
CDCL1  EQU  CDCL2+1
CDCL0  EQU  CDCL1+1
CDCCM  EQU  CDCL0+1
*
*      Loop with full iterator
*
CDFIT  EQU  0                save iterator block
CDFL3  EQU  CDFIT+1          )
CDFL2  EQU  CDFL3+1          )  labels
CDFL1  EQU  CDFL2+1          )
CDFLT  EQU  CDFL1+1          save temp count
CDFSC  EQU  CDFLT+1          save CONT label
CDFSQ  EQU  CDFSC+1          save QUIT label
CDFCM  EQU  CDFSQ+1          save loop CMBLK
*
*      Loop with FOR iterator
*
CDLIT  EQU  0                iterator CMBLK
CDLLT  EQU  CDLIT+1          loop temp count
CDLSC  EQU  CDLLT+1          save CONT label
CDLSQ  EQU  CDLSC+1          save QUIT label
CDLCM  EQU  CDLSQ+1          save loop CMBLK
CDLFT  EQU  CDLCM+1          former type (C$SET or C$TUP)
*
*      Set or tuple formers
*
CDSL2  EQU  0
CDSL1  EQU  CDSL2+1
CDSCM  EQU  CDSL1+1
       EJC
*      Input image length
*
INILN  EQU  80               Default image length for compiler
*
IONMB  EQU  2                Name base used for iochn in SYSIO
IONMO  EQU  4                Name offset used for iochn in SYSIO
*
*      In general, meaningful mnemonics should be used for
*      offsets. However for small integers used often in
*      literals the following general definitions are provided.
*
NUM01  EQU  1
NUM02  EQU  2
NUM03  EQU  3
NUM04  EQU  4
NUM05  EQU  5
NUM06  EQU  6
NUM07  EQU  7
NUM08  EQU  8
NUM09  EQU  9
NUM10  EQU  10
NINI8  EQU  998
NINI9  EQU  999
THSND  EQU  1000
NIN99  EQU  9999
*
*      Highest error code for lexical errors
*
MXLXE  EQU  5
*
.IF    .CNPF
.ELSE
*
*      Values used by the Profiler.
*
PFPD1  EQU  0                column offsets ...
PFPD2  EQU  7                ... for the profile ...
PFPD3  EQU  14               ... table printout.
PFPD4  EQU  21
PFCWD  EQU  30               width of table column
*
*      Now the size of a table entry (2 integers).
*
PFES$  EQU  CFP$I+CFP$I
*
.FI
PRCNC  EQU  VRMXL            Increment for PRCNO
PRCMV  EQU  PRCNC-1          mask value for name length
       EJC
*
*      Symbolic names for production numbers in the SETL-s
*      grammar.  These are used to control the semantic actions
*      performed according to the production being used in a
*      reduction
*
*      Note the use of mixed arabic/roman number systems.
*
PRN00  EQU  0
PRN01  EQU  1
PRN02  EQU  2
PRN03  EQU  3
PRN04  EQU  4
PRN05  EQU  5
PRN06  EQU  6
PRN07  EQU  7
PRN08  EQU  8
PRN09  EQU  9
PRN10  EQU  10
PRN11  EQU  11
PRN12  EQU  12
PRN13  EQU  13
PRN14  EQU  14
PRN15  EQU  15
PRN16  EQU  16
PRN17  EQU  17
PRN18  EQU  18
PRN19  EQU  19
PRN20  EQU  20
PRN21  EQU  21
PRN22  EQU  22
PRN23  EQU  23
PRN24  EQU  24
PRN25  EQU  25
PRN26  EQU  26
PRN27  EQU  27
PRN28  EQU  28
PRN29  EQU  29
PRN30  EQU  30
PRN31  EQU  31
PRN32  EQU  32
PRN33  EQU  33
PRN34  EQU  34
PRN35  EQU  35
PRN36  EQU  36
PRN37  EQU  37
PRN38  EQU  38
PRN39  EQU  39
PRN40  EQU  40
PRN41  EQU  41
PRN42  EQU  42
PRN43  EQU  43
PRN44  EQU  44
PRN45  EQU  45
PRN46  EQU  46
PRN47  EQU  47
PRN48  EQU  48
PRN49  EQU  49
       EJC
PRN50  EQU  50
PRN51  EQU  51
PRN52  EQU  52
PRN53  EQU  53
PRN54  EQU  54
PRN55  EQU  55
PRN56  EQU  56
PRN57  EQU  57
PRN58  EQU  58
PRN59  EQU  59
PRN60  EQU  60
PRN61  EQU  61
PRN62  EQU  62
PRN63  EQU  63
PRN64  EQU  64
PRN65  EQU  65
PRN66  EQU  66
PRN67  EQU  67
PRN68  EQU  68
PRN69  EQU  69
PRN70  EQU  70
PRN71  EQU  71
PRN72  EQU  72
PRN73  EQU  73
PRN74  EQU  74
PRN75  EQU  75
PRN76  EQU  76
PRN77  EQU  77
PRN78  EQU  78
PRN79  EQU  79
PRN80  EQU  80
PRN81  EQU  81
PRN82  EQU  82
PRN83  EQU  83
PRN84  EQU  84
PRN85  EQU  85
PRN86  EQU  86
PRN87  EQU  87
PRN88  EQU  88
PRN89  EQU  89
PRN90  EQU  90
PRN91  EQU  91
PRN92  EQU  92
PRN93  EQU  93
PRN94  EQU  94
PRN95  EQU  95
PRN96  EQU  96
PRN97  EQU  97
PRN98  EQU  98
PRN99  EQU  99
       EJC
PRC00  EQU  100
PRC01  EQU  101
PRC02  EQU  102
PRC03  EQU  103
PRC04  EQU  104
PRC05  EQU  105
PRC06  EQU  106
PRC07  EQU  107
PRC08  EQU  108
PRC09  EQU  109
PRC10  EQU  110
PRC11  EQU  111
PRC12  EQU  112
PRC13  EQU  113
PRC14  EQU  114
PRC15  EQU  115
PRC16  EQU  116
PRC17  EQU  117
PRC18  EQU  118
PRC19  EQU  119
PRC20  EQU  120
PRC21  EQU  121
PRC22  EQU  122
PRC23  EQU  123
PRC24  EQU  124
PRC25  EQU  125
PRC26  EQU  126
PRC27  EQU  127
PRC28  EQU  128
PRC29  EQU  129
PRC30  EQU  130
PRC31  EQU  131
PRC32  EQU  132
PRC33  EQU  133
PRC34  EQU  134
PRC35  EQU  135
PRC36  EQU  136
PRC37  EQU  137
PRC38  EQU  138
PRC39  EQU  139
PRC40  EQU  140
PRC41  EQU  141
PRC42  EQU  142
PRC43  EQU  143
PRC44  EQU  144
PRC45  EQU  145
PRC46  EQU  146
PRC47  EQU  147
PRC48  EQU  148
PRC49  EQU  149
       EJC
PRC50  EQU  150
PRC51  EQU  151
PRC52  EQU  152
PRC53  EQU  153
PRC54  EQU  154
PRC55  EQU  155
PRC56  EQU  156
PRC57  EQU  157
PRC58  EQU  158
PRC59  EQU  159
PRC60  EQU  160
PRC61  EQU  161
PRC62  EQU  162
PRC63  EQU  163
PRC64  EQU  164
PRC65  EQU  165
PRC66  EQU  166
PRC67  EQU  167
PRC68  EQU  168
PRC69  EQU  169
PRC70  EQU  170
PRC71  EQU  171
PRC72  EQU  172
PRC73  EQU  173
PRC74  EQU  174
PRC75  EQU  175
PRC76  EQU  176
PRC77  EQU  177
PRC78  EQU  178
PRC79  EQU  179
PRC80  EQU  180
PRC81  EQU  181
PRC82  EQU  182
PRC83  EQU  183
PRC84  EQU  184
PRC85  EQU  185
PRC86  EQU  186
PRC87  EQU  187
PRC88  EQU  188
PRC89  EQU  189
PRC90  EQU  190
PRC91  EQU  191
PRC92  EQU  192
PRC93  EQU  193
PRC94  EQU  194
PRC95  EQU  195
PRC96  EQU  196
PRC97  EQU  197
PRC98  EQU  198
PRC99  EQU  199
       EJC
PCC00  EQU  200
PCC01  EQU  201
PCC02  EQU  202
PCC03  EQU  203
PCC04  EQU  204
PCC05  EQU  205
PCC06  EQU  206
PCC07  EQU  207
PCC08  EQU  208
PCC09  EQU  209
PCC10  EQU  210
PCC11  EQU  211
PCC12  EQU  212
PCC13  EQU  213
PCC14  EQU  214
PCC15  EQU  215
PCC16  EQU  216
PCC17  EQU  217
PCC18  EQU  218
PCC19  EQU  219
PCC20  EQU  220
PCC21  EQU  221
PCC22  EQU  222
PCC23  EQU  223
PCC24  EQU  224
PCC25  EQU  225
PCC26  EQU  226
PCC27  EQU  227
PCC28  EQU  228
PCC29  EQU  229
PCC30  EQU  230
PCC31  EQU  231
PCC32  EQU  232
PCC33  EQU  233
PCC34  EQU  234
PCC35  EQU  235
PCC36  EQU  236
PCC37  EQU  237
PCC38  EQU  238
PCC39  EQU  239
PCC40  EQU  240
       EJC
*
*      Stack offsets used by TNBLD to access stacked grammar
*      symbols.  PRNEn is the offset to the pointer
*      corrsponding to the nth element from the end of a
*      production
*
PRNOF  EQU  2                offset between elements
PRNE1  EQU  PRNOF            last element
PRNE2  EQU  PRNE1+PRNOF
PRNE3  EQU  PRNE2+PRNOF
PRNE4  EQU  PRNE3+PRNOF
PRNE5  EQU  PRNE4+PRNOF
PRNE6  EQU  PRNE5+PRNOF
       EJC
*
*      Offsets used in prtsn, PRTMI and acess
*
PRSNF  EQU  13               Offset used in prtsn
PRTMF  EQU  15               Offset to col 15 (PRTMI)
RILEN  EQU  120              Buffer length for SYSRI
*
*      Codes for stages of processing
*
STGIC  EQU  0                Initial compile
STGXT  EQU  STGIC+1          Execution time
STGST  EQU  STGXT+1          Stopping
STGGB  EQU  STGST+1          Garbage collection
STGNO  EQU  STGGB+1          Number of stages
       EJC
*
*      Statement number pad count for LISTR
*
.IF    .CSN6
STNPD  EQU  6                Statement no pad count
.FI
.IF    .CSN8
STNPD  EQU  8                Statement no pad count
.FI
.IF    .CSN5
STNPD  EQU  5                Statement no pad count
.FI
*
*      and a few things dependent on it
*
STPD2  EQU  STNPD+STNPD      pad past line and stmt fields
.IF    .CNPF
.ELSE
PFPDA  EQU  STPD2+26         Pad to /at/
PFPDW  EQU  PFPDA+3          Pad to symbol in PRTWD
.FI
*
.IF    .CREL
       EJC
*
*      Definition of limits and adjustments that are built by
*      RELCR for use by the routines that relocate pointers
*      after a save file is reloaded.  See RELOC etc. for usage.
*
*      A block of information is built that is used in
*      relocating pointers.  There are RNSI$ instances
*      of a RSSI$ word structure.  Each instance corresponds
*      to one of the regions that a pointer might point into.
*
*      Each structure takes the form:
*
*           +------------------------------------+
*           I    ADDRESS PAST END OF SECTION     I
*           +------------------------------------+
*           I  ADJUSTMENT FROM OLD TO NEW ADRS   I
*           +------------------------------------+
*           I    ADDRESS OF START OF SECTION     I
*           +------------------------------------+
*
*      The instances are ordered thusly:
*
*           +------------------------------------+
*           I           DYNAMIC STORAGE          I
*           +------------------------------------+
*           I           STATIC STORAGE           I
*           +------------------------------------+
*           I       WORKING SECTION GLOBALS      I
*           +------------------------------------+
*           I          CONSTANT SECTION          I
*           +------------------------------------+
*           I            CODE SECTION            I
*           +------------------------------------+
*
*      Symbolic names for these locations as offsets from
*      the first entry are provided here.
*
*      Definitions within a section
*
RLEND  EQU  0                End
RLADJ  EQU  RLEND+1          Adjustment
RLSTR  EQU  RLADJ+1          Start
RSSI$  EQU  RLSTR+1          Size of section
RNSI$  EQU  5                Number of structures
*
*      Overall definitions of all structures
*
RLDYE  EQU  0                DYNAMIC REGION END
RLDYA  EQU  RLDYE+1          DYNAMIC REGION ADJUSTMENT
RLDYS  EQU  RLDYA+1          DYNAMIC REGION START
RLSTE  EQU  RLDYS+1          STATIC REGION END
RLSTA  EQU  RLSTE+1          STATIC REGION ADJUSTMENT
RLSTS  EQU  RLSTA+1          STATIC REGION START
RLWKE  EQU  RLSTS+1          WORKING SECTION GLOBALS END
RLWKA  EQU  RLWKE+1          WORKING SECTION GLOBALS ADJUSTMENT
RLWKS  EQU  RLWKA+1          WORKING SECTION GLOBALS START
RLCNE  EQU  RLWKS+1          CONSTANTS SECTION END
RLCNA  EQU  RLCNE+1          CONSTANTS SECTION ADJUSTMENT
RLCNS  EQU  RLCNA+1          CONSTANTS SECTION START
RLCDE  EQU  RLCNS+1          CODE SECTION END
RLCDA  EQU  RLCDE+1          CODE SECTION ADJUSTMENT
RLCDS  EQU  RLCDA+1          CODE SECTION START
RLSI$  EQU  RLCDS+1          NUMBER OF FIELDS IN STRUCTURE
.FI
*
       TTL  S E T L - S -- CONSTANT SECTION
*
*      This section consists entirely of assembled constants.
*
*      All label names are five letters. The order is
*      approximately alphabetical, but in some cases (always
*      documented), constants must be placed in some special
*      order which must not be disturbed.
*
*      It must also be remembered that there is a requirement
*      for no forward references which also disturbs the
*      alphabetical order in some cases.
*
       SEC                   Start of constant section
*
C$AAA  DAC  0                First location of constant section
*
*      Free store percentage (used by ALLOC)
*
ALFSP  DAC  E$FSP            Free store percentage
*
*      Bit constants for general use
*
BITS0  DBC  0                All zero bits
BITS1  DBC  1                One bit in low order position
BITS2  DBC  2                Bit in position 2
BITS3  DBC  4                Bit in position 3
BITS4  DBC  8                Bit in position 4
BITS5  DBC  16               Bit in position 5
BITS6  DBC  32               Bit in position 6
BITS7  DBC  64               Bit in position 7
BITS8  DBC  128              Bit in position 8
BITS9  DBC  256              Bit in position 9
BIT10  DBC  512              Bit in position 10
BITSM  DBC  CFP$M            Mask for max integer
       EJC
*
*      Message text for compilation statistics
*
ENCM1  DAC  B$SCL
       DAC  10
       DTC  /STORE USED/
*
ENCM2  DAC  B$SCL
       DAC  10
       DTC  /STORE LEFT/
*
ENCM3  DAC  B$SCL
       DAC  11
       DTC  /COMP ERRORS/
*
ENCM4  DAC  B$SCL
       DAC  14
       DTC  /COMP TIME-10th SEC/
*
ENCM5  DAC  B$SCL            Execution suppressed
       DAC  20
       DTC  /EXECUTION SUPPRESSED/
*
ENCM6  DAC  B$SCL
       DAC  11
       DTC  /time - 10th sec/
*
*      Messages issued when error recovery mechanism collapses
*
ERMS1  DAC  B$SCL
       DAC  21
       DTC  /error recovery failed/
*
ERMS2  DAC  B$SCL
       DAC  27
       DTC  /error inside error recovery/
       EJC
       EJC
*
*      Memory overflow during initialisation
*
ENDMO  DAC  B$SCL
ENDML  DAC  15
       DTC  /MEMORY OVERFLOW/
*
*      String constant for message issued at end
*
ENDMS  DAC  B$SCL
       DAC  10
       DTC  /NORMAL END/
*
*      Fail message for stack fail section
*
ENDSO  DAC  B$SCL            Stack overflow in garbage collector
       DAC  36
       DTC  /STACK OVERFLOW IN GARBAGE COLLECTION/
       EJC
*
*      String constant for error message (error section)
*
ERMMS  DAC  B$SCL            Error
       DAC  5
       DTC  /ERROR/
*
ERDSH  DAC  B$SCL            String / -- /
       DAC  4
       DTC  / -- /
*
*      String constant for page numbering
*
LSTMS  DAC  B$SCL            Page
       DAC  5
       DTC  /PAGE /
*
*      Listing header message
*
HEADR  DAC  B$SCL
       DAC  18
       DTC  /SETL-S VERSION 2.3/
*
HEADV  DAC  B$SCL            For exit() version no check
       DAC  3
       DTC  /2.3/
*
.IF    .CSED
*      Free store percentage (used by GBCOL)
*
GBSDP  DAC  E$SED            Sediment percentage
.FI
*
*      Pointer to INPUT routine
*
INPUT  DAC  S$INP
*
*      Integer constants for general use
*      ICBLD optimisation uses the first three.
*
INT$R  DAC  B$ICL
INTV0  DIC  +0               0
INTON  DAC  B$ICL
INTV1  DIC  +1               1
INTTW  DAC  B$ICL
INTV2  DIC  +2               2
INTVT  DIC  +10              10
INTVH  DIC  +100             100
INTTH  DIC  +1000            1000
*
*      Table used in ICBLD optimisation
*
INTAB  DAC  INT$R            Pointer to 0
       DAC  INTON            Pointer to 1
       DAC  INTTW            Pointer to 2
       EJC
*
*      Null (empty) tuple and set
*
NLTUP  DAC  B$TPL
       DAC  TBSI$
       DAC  0
*
*      The null set is a map
*
NLSET  DAC  B$MPL
       DAC  TBSI$
       DAC  0
*
*      Null string. All null values point to this string. The
*      SCHAR field contains blanks.
*      NULLW contains 10 blanks which ensures an all blank word
*      but for very exceptional machines.
*
NULLS  DAC  B$SCL            Null string value
       DAC  0                SCLEN = 0
NULLW  DTC  /          /
*
OMEGA  DAC  B$OML            The undefined value
       DAC  B$SCL
       DAC  1
       DTC  /*/
*
*      Pointer to OUTPUT routine
*
OUTPT  DAC  S$OUT
       EJC
*
*      Pointers to routines to perform internal operations
*
*
*      Pass no-op
*
PASSS  DAC  OPPAS
*
*      Conditional jumps
*
JTRUE  DAC  JUMPT
JCFLS  DAC  JFCLR
JFALS  DAC  JUMPF
JNOMG  DAC  JMPNO         omega test for ? oper
JNEXT  DAC  JUMPN
JNXTC  DAC  JMPNC         next for compd oper
JNXTM  DAC  JMPNM         next for map (or tuple) iter
*
ORNEG  DAC  RVNEG
*
*      iterator temporary load and store ops
*
TMPS0  DAC  STKS0
TMPS1  DAC  STKS1
TMPS2  DAC  STKS2
TMPSN  DAC  STKSN
*
TMPL0  DAC  STKL0
TMPL1  DAC  STKL1
TMPL2  DAC  STKL2
TMPL3  DAC  STKL3
TMPLN  DAC  STKLN
       EJC
*
*      Operator jump vectors
*      All labels in this section are of the form O$XXX, where
*      XXX is a three letter code for the operator.  Pointers to
*      these blocks are generated in the code for each SETL-S
*      operator referenced.
*
*      There are three types of block -
*      first, those with a single entry, a pointer to a routine
*      to perform the operation, regardless of operand type -
*      these are just like SPITBOL operators, and typically use
*      salvaged SPITBOL code.
*
*      Second, we have blocks with pointers to APPL1 (monadic)
*      or APPL2 (dyadic) in the first word, followed by a vector
*      of entry points.  These are used to implement a table -
*      driven type checking mechanism for heavily polymorphic
*      operators.
*
*      Finally, for those operators which can legally be applied
*      to operands of only one type, there are blocks with
*      pointers to APPX1 (monadic) or APPX2 (dyadic) in word 0
*      followed by a pointer to the operator routine and a
*      pointer to an error routine.
*
*      In addition, a few operators which are implemented in
*      a peculiar way (eg AND, assignment) have dummy entries.
*
*
       EJC
O$ABS  DAC  APPL1          abs
       DAC  ERABS
       DAC  ICABS
       DAC  ERABS
       DAC  ERABS
       DAC  ERABS
.IF    .CNRA
.ELSE
       DAC  RCABS
.FI
       DAC  SCABS
       DAC  ERABS
       DAC  ERABS
       DAC  ERABS
*
O$AND  DAC  0               and
*
O$ARB  DAC  APPL1           arb
       DAC  ERARB
       DAC  ERARB
       DAC  MSARB
       DAC  ERARB
       DAC  ERARB
.IF    .CNRA
.ELSE
       DAC  ERARB
.FI
       DAC  ERARB
       DAC  MSARB
       DAC  ERARB
       DAC  ERARB
*
O$ASS  DAC  0             assign
*
       EJC
O$CHR  DAC  APPX1         char
       DAC  B$ICL
       DAC  ICCHR
       DAC  ERCHR
*
O$COP  DAC  OPCOP         copy operand
*
O$DIV  DAC  APPL2         real division
       DAC  ERDIV
.IF .CNRA
       DAC  ERDIV
.ELSE
       DAC  ICDIV
.FI
       DAC  ERDIV
       DAC  ERDIV
       DAC  ERDIV
.IF    .CNRA
.ELSE
       DAC  RCDIV
.FI
       DAC  ERDIV
       DAC  ERDIV
       DAC  ERDIV
       DAC  ERDIV
*
O$DOM  DAC  APPL1         domain
       DAC  ERDOM
       DAC  ERDOM
       DAC  MSDOM
       DAC  ERDOM
       DAC  ERDOM
.IF    .CNRA
.ELSE
       DAC  ERDOM
.FI
       DAC  ERDOM
       DAC  MSDOM
       DAC  ERDOM
       DAC  ERDOM
*
O$DVI  DAC  APPX2           div -- integer division
       DAC  B$ICL
       DAC  ICDVI
       DAC  ERDVI
*
       EJC
O$END  DAC  OPEND
*
O$EQL  DAC  APPL2           =
       DAC  VLEQL
       DAC  ICEQL
       DAC  MSEQL
       DAC  VLEQL
       DAC  PREQL
.IF    .CNRA
.ELSE
       DAC  RCEQL
.FI
       DAC  SCEQL
       DAC  MSEQL
       DAC  TPEQL
       DAC  VLEQL
*
O$EVN  DAC  APPX1         even
       DAC  B$ICL
       DAC  ICEVN
       DAC  EREVN
*
O$EXP  DAC  APPL2
       DAC  EREXP
       DAC  ICEXP         int
       DAC  EREXP
       DAC  EREXP
       DAC  EREXP
.IF    .CNRA
.ELSE
       DAC  EREXP         reals
.FI
       DAC  EREXP
       DAC  EREXP
       DAC  EREXP
       DAC  EREXP
*
.IF    .CNRA
O$FIX  DAC  ERFIX
O$FLO  DAC  ERFLO
.ELSE
O$FIX  DAC  APPX1             fix
       DAC  B$RCL
       DAC  RCFIX
       DAC  ERFIX
*
O$FLO  DAC  APPX1             float
       DAC  B$ICL
       DAC  ICFLO
       DAC  ERFLO
.FI
O$FRB  DAC  APPL1             fromb
       DAC  ERFRB
       DAC  ERFRB
       DAC  ERFRB
       DAC  ERFRB
       DAC  PRFRB
.IF    .CNRA
.ELSE
       DAC  ERFRB
.FI
       DAC  ERFRB
       DAC  ERFRB
       DAC  TPFRB
       DAC  ERFRB
*
O$FRE  DAC  APPL1          frome
       DAC  ERFRE
       DAC  ERFRE
       DAC  ERFRE
       DAC  ERFRE
       DAC  PRFRE
.IF    .CNRA
.ELSE
       DAC  ERFRE
.FI
       DAC  ERFRE
       DAC  ERFRE
       DAC  TPFRE
       DAC  ERFRE
*
       EJC
O$FRM  DAC  APPL1          from
       DAC  ERFRM
       DAC  ERFRM
       DAC  MSFRM
       DAC  ERFRM
       DAC  ERFRM
.IF    .CNRA
.ELSE
       DAC  ERFRM
.FI
       DAC  ERFRM
       DAC  MSFRM
       DAC  ERFRM
       DAC  ERFRM
*
O$IAT  DAC  OPIAT             is_atom
*
O$IBO  DAC  OPIBO             is_boolean
*
O$IIN  DAC  OPIIN             is_integer
*
O$IMA  DAC  OPIMA             is_map
*
O$IMP  DAC  0                 imp  ->
*
O$INC  DAC  APPL2
       DAC  ERINC
       DAC  ERINC
       DAC  MSINC
       DAC  ERINC
       DAC  ERINC
.IF    .CNRA
.ELSE
       DAC  ERINC
.FI
       DAC  ERINC
       DAC  MSINC
       DAC  ERINC
       DAC  ERINC
       EJC
*
O$IOR  DAC  0                 (inclusive) OR
*
O$ISE  DAC  OPISE             is_set
*
O$IST  DAC  OPIST             is_string
*
O$ITU  DAC  OPITU             is_tuple
*
O$LES  DAC  APPL2             less
       DAC  ERLES
       DAC  ERLES
       DAC  MSLES
       DAC  ERLES
       DAC  ERLES
.IF    .CNRA
.ELSE
       DAC  ERLES
.FI
       DAC  ERLES
       DAC  MSLES
       DAC  ERLES
       DAC  ERLES
*
O$LSF  DAC  APPL2               lessf
       DAC  ERLSF
       DAC  ERLSF
       DAC  MSLSF
       DAC  ERLSF
       DAC  ERLSF
.IF    .CNRA
.ELSE
       DAC  ERLSF
.FI
       DAC  ERLSF
       DAC  MSLSF
       DAC  ERLSF
       DAC  ERLSF
*
O$MAX  DAC  APPL2                binary max oper
       DAC  ERMAX
       DAC  ICMAX                integer
       DAC  ERMAX
       DAC  ERMAX
       DAC  ERMAX
.IF    .CNRA
.ELSE
       DAC  ERMAX
.FI
       DAC  ERMAX
       DAC  ERMAX
       DAC  ERMAX
       DAC  ERMAX
*
O$MIN  DAC  APPL2                binary min operator
       DAC  ERMIN
       DAC  ICMIN                integer
       DAC  ERMIN
       DAC  ERMIN
       DAC  ERMIN
.IF    .CNRA
.ELSE
       DAC  ERMIN
.FI
       DAC  ERMIN
       DAC  ERMIN
       DAC  ERMIN
       DAC  ERMIN
*
O$MNS  DAC  APPL2                binary minus
       DAC  ERMNS
       DAC  ICMNS
       DAC  MSMNS
       DAC  ERMNS
       DAC  ERMNS
.IF    .CNRA
.ELSE
       DAC  RCMNS
.FI
       DAC  ERMNS
       DAC  MSMNS
       DAC  ERMNS
       DAC  ERMNS
*
       EJC
O$MMN  DAC  APPL1            monadic minus
       DAC  ERMMN
       DAC  ICMMN
       DAC  ERMMN
       DAC  ERMMN
       DAC  ERMMN
.IF    .CNRA
.ELSE
       DAC  RCMMN
.FI
       DAC  ERMMN
       DAC  ERMMN
       DAC  ERMMN
       DAC  ERMMN
*
O$MUL  DAC  APPL2              * multiplication
       DAC  ERMUL
       DAC  ICMUL
       DAC  MSMUL
       DAC  ERMUL
       DAC  PRMUL
.IF    .CNRA
.ELSE
       DAC  RCMUL
.FI
       DAC  SCMUL
       DAC  MSMUL
       DAC  TPMUL
       DAC  ERMUL
*
O$NEQ  DAC  APPL2             not equal
       DAC  VLNEQ
       DAC  ICNEQ
       DAC  MSNEQ
       DAC  VLNEQ
       DAC  PRNEQ
.IF    .CNRA
.ELSE
       DAC  RCNEQ
.FI
       DAC  SCNEQ
       DAC  MSNEQ
       DAC  TPNEQ
       DAC  VLNEQ
*
       EJC
O$NIN  DAC  APPL1           notin
       DAC  ERNIN
       DAC  ERNIN
       DAC  MSNIN
       DAC  ERNIN
       DAC  PRNIN
.IF    .CNRA
.ELSE
       DAC  ERNIN
.FI
       DAC  SCNIN
       DAC  MSNIN
       DAC  TPNIN
       DAC  ERNIN
*
O$NOT  DAC  APPX1             not
       DAC  B$TVL
       DAC  TVNOT
       DAC  ERNOT
*
O$NPW  DAC  APPL2             NPOW
       DAC  ERNPW
       DAC  ICNPW
       DAC  MSNPW
       DAC  ERNPW
       DAC  ERNPW
.IF    .CNRA
.ELSE
       DAC  ERNPW
.FI
       DAC  ERNPW
       DAC  MSNPW
       DAC  ERNPW
       DAC  ERNPW
*
       EJC
O$NUM  DAC  APPL1             #
       DAC  ERNUM
       DAC  ERNUM
       DAC  MPNUM
       DAC  ERNUM
       DAC  PRNUM
.IF    .CNRA
.ELSE
       DAC  ERNUM
.FI
       DAC  SCNUM
       DAC  STNU$
       DAC  TPNUM
       DAC  ERNUM
*
O$ODD  DAC  APPX1           odd oper
       DAC  B$ICL
       DAC  ICODD
       DAC  ERODD
*
O$OGE  DAC  APPL2           >=
       DAC  EROGE
       DAC  ICOGE
       DAC  EROGE
       DAC  EROGE
       DAC  EROGE
.IF    .CNRA
.ELSE
       DAC  RCOGE
.FI
       DAC  SCOGE
       DAC  EROGE
       DAC  EROGE
       DAC  EROGE
*
O$OGT  DAC  APPL2             >
       DAC  EROGT
       DAC  ICOGT
       DAC  EROGT
       DAC  EROGT
       DAC  EROGT
.IF    .CNRA
.ELSE
       DAC  RCOGT
.FI
       DAC  SCOGT
       DAC  EROGT
       DAC  EROGT
       DAC  EROGT
*
O$OIN  DAC  APPL1            IN operator
       DAC  EROIN
       DAC  EROIN
       DAC  MSOIN
       DAC  EROIN
       DAC  PROIN
.IF    .CNRA
.ELSE
       DAC  EROIN
.FI
       DAC  SCOIN
       DAC  MSOIN
       DAC  TPOIN
       DAC  EROIN
*
       EJC
O$OLE  DAC  APPL2           <=
       DAC  EROLE
       DAC  ICOLE
       DAC  EROLE
       DAC  EROLE
       DAC  EROLE
.IF    .CNRA
.ELSE
       DAC  RCOLE
.FI
       DAC  SCOLE
       DAC  EROLE
       DAC  EROLE
       DAC  EROLE
*
O$OLT  DAC  APPL2             <
       DAC  EROLT
       DAC  ICOLT
       DAC  EROLT
       DAC  EROLT
       DAC  EROLT
.IF    .CNRA
.ELSE
       DAC  RCOLT
.FI
       DAC  SCOLT
       DAC  EROLT
       DAC  EROLT
       DAC  EROLT
*
O$PCM  DAC  PRPCM            prep for unary compd oper
*
.IF    .CNPF
.ELSE
*
*      /PROFILE/ pseudo-op. Planted at the head of each basic
*      block.
*
O$PFL  DAC  OPPFL
.FI
*
O$PLH  DAC  APPL1            prep for parallel assign to lhs
       DAC  ERPLH
       DAC  ERPLH
       DAC  ERPLH
       DAC  ERPLH
       DAC  PRPLH
.IF    .CNRA
.ELSE
       DAC  ERPLH
.FI
       DAC  ERPLH
       DAC  ERPLH
       DAC  TPPLH
       DAC  ERPLH
*
O$PLS  DAC  APPL2            + operator
       DAC  ERPLS
       DAC  ICPLS
       DAC  MSPLS
       DAC  ERPLS
       DAC  PRPLS
.IF    .CNRA
.ELSE
       DAC  RCPLS
.FI
       DAC  SCPLS
       DAC  MSPLS
       DAC  TPPLS
       DAC  ERPLS
*
O$PMI  DAC  PRMIT              prep map (or tuple) iter
O$PPI  DAC  PRPIT              prep iter
*
O$POP  DAC  OPPOP
O$PP2  DAC  OPPP2
*
O$POW  DAC  APPL1              POW  operator
       DAC  ERPOW
       DAC  ERPOW
       DAC  MSPOW
       DAC  ERPOW
       DAC  ERPOW
.IF    .CNRA
.ELSE
       DAC  ERPOW
.FI
       DAC  ERPOW
       DAC  MSPOW
       DAC  ERPOW
       DAC  ERPOW
*
O$QMC  DAC  APPX2            ? in compound oper
       DAC  B$OML
       DAC  OMQMC
       DAC  ERQMC
*
O$QMK  DAC  0                ? operator - never entered
*
       EJC
O$REM  DAC  APPL2            MOD operator
       DAC  ERREM
       DAC  ICREM
       DAC  MSREM
       DAC  ERREM
       DAC  ERREM
.IF    .CNRA
.ELSE
       DAC  ERREM
.FI
       DAC  ERREM
       DAC  MSREM
       DAC  ERREM
       DAC  ERREM
*
O$RND  DAC  APPL1            RANDOM operator
       DAC  ERRND
       DAC  ICRND
       DAC  MSRND
       DAC  ERRND
       DAC  PRRND
.IF    .CNRA
.ELSE
       DAC  ERRND
.FI
       DAC  ERRND
       DAC  MSRND
       DAC  TPRND
       DAC  ERRND
*
O$RNG  DAC  APPL1            range
       DAC  ERRNG
       DAC  ERRNG
       DAC  MSRNG
       DAC  ERRNG
       DAC  ERRNG
.IF    .CNRA
.ELSE
       DAC  ERRNG
.FI
       DAC  ERRNG
       DAC  MSRNG
       DAC  ERRNG
       DAC  ERRNG
*
O$RTN  DAC  OPRTN         return
*
O$SBA  DAC  APPL3          subscript assign  x(a) :=
       DAC  ERSBA
       DAC  ERSBA
       DAC  MSSBA
       DAC  ERSBA
       DAC  PRSBA
.IF    .CNRA
.ELSE
       DAC  ERSBA
.FI
       DAC  SCSBA
       DAC  MSSBA
       DAC  TPSBA
       DAC  ERSBA
*
O$SBM  DAC  APPL2           map ref  m{a}
       DAC  ERSBM
       DAC  ERSBM
       DAC  MSSBM
       DAC  ERSBM
       DAC  ERSBM
.IF    .CNRA
.ELSE
       DAC  ERSBM
.FI
       DAC  ERSBM
       DAC  MSSBM
       DAC  ERSBM
       DAC  ERSBM
       EJC
*
O$SBS  DAC  APPL2            subset
       DAC  ERSBS
       DAC  ERSBS
       DAC  MSSBS
       DAC  ERSBS
       DAC  ERSBS
.IF    .CNRA
.ELSE
       DAC  ERSBS
.FI
       DAC  ERSBS
       DAC  MSSBS
       DAC  ERSBS
       DAC  ERSBS
*
O$SLA  DAC  APPL4          slice assign  t(a..b) :=
       DAC  ERSLA
       DAC  ERSLA
       DAC  ERSLA
       DAC  ERSLA
       DAC  TPSLA          pair
.IF    .CNRA
.ELSE
       DAC  ERSLA
.FI
       DAC  SCSLA          string
       DAC  ERSLA
       DAC  TPSLA          tuple
       DAC  ERSLA
       EJC
*
*
O$SLC  DAC  APPL3          slice  t(a..b)
       DAC  ERSLC
       DAC  ERSLC
       DAC  ERSLC
       DAC  ERSLC
       DAC  PRSLC          pair
.IF    .CNRA
.ELSE
       DAC  ERSLC
.FI
       DAC  SCSLC          string
       DAC  ERSLC
       DAC  TPSLC          tuple
       DAC  ERSLC
       EJC
*
O$SMA  DAC  APPL3          curly subscript assign m{a} :=
       DAC  ERSMA
       DAC  ERSMA
       DAC  MSSMA          map
       DAC  ERSMA
       DAC  ERSMA
.IF    .CNRA
.ELSE
       DAC  ERSMA
.FI
       DAC  ERSMA
       DAC  MSSMA          set
       DAC  ERSMA
       DAC  ERSMA
*
O$STF  DAC  SETFM
*
O$SUB  DAC  APPL2          subscript ref
       DAC  ERSUB
       DAC  ERSUB
       DAC  MSSUB
       DAC  ERSUB
       DAC  PRSUB
.IF    .CNRA
.ELSE
       DAC  ERSUB
.FI
       DAC  SCSUB
       DAC  MSSUB
       DAC  TPSUB
       DAC  ERSUB
*
O$STM  DAC  OPSTM          incr stmt #
*
O$STR  DAC  OPSTR
       EJC
O$TPF  DAC  TPLFM          form tuple
*
O$TYP  DAC  OPTYP          type operator
*
O$VAL  DAC  APPX1          val
       DAC  B$SCL
       DAC  SCVAL
       DAC  ERVAL
*
O$WIT  DAC  APPL2          with
       DAC  ERWIT
       DAC  ERWIT
       DAC  MPWIT
       DAC  ERWIT
       DAC  PRWIT
.IF    .CNRA
.ELSE
       DAC  ERWIT
.FI
       DAC  ERWIT
       DAC  STWIT
       DAC  TPWIT
       DAC  ERWIT
       EJC
.IF    .CNPF
.ELSE
*
*      Profiler Constants.
*
PFCLW  DIC  +30              width of a table column
PFESA  DAC  PFES$            table entry size (address form)
*
*      Messages issued by the profiler at various stages.
*
*      First those used in indicating basic block structure.
*
PFM02  DAC  B$SCL
       DAC  18
       DTC  /End Profile Block /
PFM03  DAC  B$SCL
       DAC  2
       DTC  /at/
PFM05  DAC  B$SCL
       DAC  14
       DTC  /Procedure Call/
*
*      Now those used in listing the counts after execution.
*
PFM10  DAC  B$SCL
       DAC  15
       DTC  /Program Profile/
PFM15  DAC  B$SCL
       DAC  30
       DTC  /Basic  Number Execution Time  /
PFM16  DAC  B$SCL
       DAC  30
       DTC  /Block   of    Total  Per Excn /
PFM17  DAC  B$SCL
       DAC  30
       DTC  /Number Excns  (msec) (mcsec)  /
.FI
*
*      Bit constant used in processing declarations
*
PRCMX  DBC  PRCMV            mask out length of name
*
*      Pointers to system function entry points
*
F$AST  DAC  S$AST            assert
F$DAT  DAC  S$DAT            date
F$EOF  DAC  S$EOF            eof
F$GET  DAC  S$GET            get
F$HST  DAC  S$HST            host
F$NAT  DAC  S$NAT            newat
F$PRT  DAC  S$PRT            print
F$PTA  DAC  S$PTA            printa
F$PUT  DAC  S$PUT            put
F$REA  DAC  S$REA            read
F$RDA  DAC  S$RDA            reada
F$RDL  DAC  S$RDL            readl
F$TIM  DAC  S$TIM            time
*
*      Also string primitives
*
F$ANY  DAC  S$ANY            any
F$BRK  DAC  S$BRK            break
F$LEN  DAC  S$LEN            len
F$LPD  DAC  S$LPD            lpad
F$MCH  DAC  S$MCH            match
F$NAY  DAC  S$NAY            notany
F$RAN  DAC  S$RAN            rany
F$RBR  DAC  S$RBR            rbreak
F$RLN  DAC  S$RLN            rlen
F$RMC  DAC  S$RMC            rmatch
F$RNA  DAC  S$RNA            rnotany
F$RPD  DAC  S$RPD            rpad
F$RSP  DAC  S$RSP            rspan
F$SPN  DAC  S$SPN            span
       EJC
*
*
.IF    .CNRA
.ELSE
*
*      Real constants for general use. Note that the constants
*      starting at reav1 form a powers of ten table (GTSTG)
*
REAV0  DRC  +0.0             0.0
REAP1  DRC  +0.1             0.1
REAP5  DRC  +0.5             0.5
REAV1  DRC  +1.0             10**0
REAVT  DRC  +1.0E+1          10**1
       DRC  +1.0E+2          10**2
       DRC  +1.0E+3          10**3
       DRC  +1.0E+4          10**4
       DRC  +1.0E+5          10**5
       DRC  +1.0E+6          10**6
       DRC  +1.0E+7          10**7
       DRC  +1.0E+8          10**8
       DRC  +1.0E+9          10**9
REATT  DRC  +1.0E+10         10**10
.FI
       EJC
*
*      String constants (SCBLK format) for DTYPE procedure
*
SCATM  DAC  B$SCL             atom
       DAC  4
       DTC  /ATOM/
SCINT  DAC  B$SCL            Integer
       DAC  7
       DTC  /INTEGER/
*
SCSET  DAC  B$SCL             set maps
       DAC  3
       DTC  /SET/
.IF    .CNRA
.ELSE
*
SCREA  DAC  B$SCL            Real
       DAC  4
       DTC  /REAL/
.FI
*
SCSTR  DAC  B$SCL            String
       DAC  6
       DTC  /STRING/
*
SCTUP  DAC  B$SCL             tuple pair
       DAC  5
       DTC  /TUPLE/
*
SCTRU  DAC  B$SCL
       DAC  4
       DTC  /BOOL/
*      Datatype name table for DTYPE procedure. The order of
*      these entries is tied to the B$XXX definitions for blocks
*
SCNMT  DAC  0
       DAC  SCATM
       DAC  SCINT
       DAC  SCSET
       DAC  0
       DAC  SCTUP
.IF    .CNRA
.ELSE
       DAC  SCREA            RCBLK     real
.FI
       DAC  SCSTR            SCBLK     string
       DAC  SCSET
       DAC  SCTUP
       DAC  SCTRU
       EJC
*
.IF    .CNRA
.ELSE
*      String constant for real zero
*
SCRE0  DAC  B$SCL
       DAC  2
       DTC  /0./
.FI
*
*      Standard variable block. This block is used to initialize
*      the first fields of a newly constructed VRBLK.
*      Its format is tied to the VRBLK definitions (see GTNVR).
*
STNVR  DAC  B$VRL            VRGET
       DAC  B$VRS            VRSTO
       DAC  OMEGA            VRVAL
       DAC  0                VRNXT
       EJC
*
*      Messages used in end of run processing (STOPR)
*
STPM1  DAC  B$SCL            In statement
       DAC  12
       DTC  /IN STATEMENT/
*
STPM2  DAC  B$SCL
       DAC  14
       DTC  /STMTS EXECUTED/
*
STPM3  DAC  B$SCL
       DAC  13
       DTC  /RUN TIME-10th SEC/
*
STPM4  DAC  B$SCL
       DAC  12
       DTC  $MCSEC / STMT$
*
STPM5  DAC  B$SCL
       DAC  13
       DTC  /REGENERATIONS/
       EJC
*
*      Percentage at which sets and maps are rehashed
*
XPNPC  DIC  +70
*
C$YYY  DAC  0                Last location in Constant Section
*
       TTL  S E T L - S -- WORKING STORAGE SECTION
*
*      The working storage section contains areas which are
*      changed during execution of the program. The value
*      assembled is the initial value before execution starts.
*
*      All these areas are fixed length areas. Variable length
*      data is stored in the static or dynamic regions of the
*      allocated data areas.
*
*      The values in this area are described either as work
*      areas or as global values. A work area is used in an
*      ephemeral manner and the value is not saved from one
*      entry into a routine to another. A global value is a
*      less temporary location whose value is saved from one
*      call to another.
*
*      W$AAA marks the start of the Working Section whilst
*      W$YYY marks its end.  G$AAA marks the division between
*      temporary and global values.
*
*      Global values are further subdivided to facilitate
*      processing by the garbage collector.  R$AAA through
*      R$YYY are global values that may point into dynamic
*      storage and hance must be relocated after each garbage
*      collection.  They also serve as root pointers to all
*      allocated data that must be preserved.
*
*      Pointers between A$AAA and R$AAA are marked as adjustable
*      global values.  They may point into code, static storage,
*      or mark the limits of dynamic memory.  These pointers
*      must be adjusted when the Working Section is saved to a
*      file and subsequently reloaded at a different address.
*
*      A general part of the approach in this program is not
*      to overlap work areas between procedures even though a
*      small amount of space could be saved. Such overlap is
*      considered a source of program errors and decreases the
*      information left behind after a system crash of any kind.
*
*      The names of these locations are labels with five letter
*      (A-Y,$) names. As far as possible the order is kept
*      alphabetical by these names but in some cases there
*      are slight departures caused by other order requirements.
*
*      Unless otherwise documented, the order of work areas
*      does not affect the execution of the SETL-S program.
*
       SEC                   Start of working storage section
       EJC
*
*      Label to mark start of work area
*
W$AAA  DAC  0
*
*      Work loc for ADSEL procedure
*
ADSLN  DIC  +0               Length of block as integer
*
*      Work areas for ALLOC procedure
*
ALDYN  DAC  0                Amount of dynamic store
ALLIA  DIC  +0               Dump IA
ALLSV  DAC  0                Save WB in ALLOC
*
*      Work areas for ALOST procedure
*
ALSTA  DAC  0                Save WA in ALOST
*
*      Work locs for DFINT and DFFST procedures
*
DIRES  DAC  0                Result
DFFLG  DAC  0                Difference/intersection flag
REMCT  DAC  0                Flag pass one or two
REMDV  DIC  +0               Abs value of Divisor in ICREM
*
*      Work loc for division routines
*
DIVSV  DIC  +0               Save divisor
*
*      Work area for error processing.
*
ERCOD  DAC  0                Error message code
ERICH  DAC  0                Copy error reports to int chan if 1
ERLST  DAC  0                For LISTR when errors go to int.Ch.
ERRFT  DAC  0                Fatal error flag
ERRSN  DAC  0                Save nonterminal in syntax error
ERRSP  DAC  0                Error suppression flag
       EJC
*
*      Dump area for ERTEX
*
ERTWA  DAC  0                Save WA
ERTWB  DAC  0                Save WB
*
*      Work areas for EXPIC
*
EXPBS  DIC  +0               Base integer
EXPAC  DIC  +0               Integer accumulator
*
*      Work loc for FINDS
*
FINDL  DIC  +0               Save block length
*
*      Work loc for FMSET
*
FMSCT  DAC  0                Save loop counter
*      Work areas for GBCOL procedure
*
GBCFL  DAC  0                Garbage collector active flag
GBCLM  DAC  0                Pointer to last move block (pass 3)
GBCNM  DAC  0                Dummy first move block
GBCNS  DAC  0                Rest of dummy block (follows GBCNM)
.IF    .CSED
.IF    .CEPP
.ELSE
GBCMK  DAC  0                Bias when marking entry point
.FI
GBCIA  DIC  +0               Dump IA
GBCSD  DAC  0                First address beyond sediment
GBCSF  DAC  0                Free space within sediment
.FI
GBSVA  DAC  0                Save WA
GBSVB  DAC  0                Save WB
GBSVC  DAC  0                Save WC
*
*      Work area for GENST
*
GENIS  DAC  0                Zero/nonzero for non-iter/iter
*
*      Work areas for GTINT
*
GTINA  DAC  0                Save WA
GTINB  DAC  0                Save WB
*
*      Work areas for GTNUM procedure
*
GTNNF  DAC  0                Zero/nonzero for result +/-
GTNSI  DIC  +0               General integer save
.IF    .CNRA
.ELSE
GTNDF  DAC  0                0/1 For dec point so far no/yes
GTNES  DAC  0                Zero/nonzero exponent +/-
GTNEX  DIC  +0               Real exponent
GTNSC  DAC  0                Scale (places after point)
GTNSR  DRC  +0.0             General real save
GTNRD  DAC  0                Flag for ok real number
.FI
*
*      Work areas for GTSTG procedure
*
GTSSF  DAC  0                0/1 For result +/-
GTSVC  DAC  0                Save WC
GTSVB  DAC  0                Save WB
.IF    .CNRA
.ELSE
.IF    .CNCR
.ELSE
GTSES  DAC  0                Char + or - for exponent +/-
GTSRS  DRC  +0.0             General real save
.FI
.FI
*
*      Work areas for gtvar procedure
*
GTVRC  DAC  0                Save WC
*
*      Work loc for IOPUT
*
IOPWA  DAC  0                Save WA (arg count)
IOPWB  DAC  0                Save WB (i/o indicator)
*
*      Work loc for IOSRC
*
IOARG  DAC  0                Save argument
IOSXR  DAC  0                Save XR
*
*      Work areas for LABRF
*
LRNUM  DAC  0                save location for argument
*
*      Work areas for LABST
*
LBSTN  DAC  0                save location for argument
LSLAB  DAC  0                remember label of current CCBLK
*
*      Work locs for STNCL procedure
*
NCLXR  DAC  0                save XR
NCLXL  DAC  0                save XL
*
*      Work areas for prtsn procedure
*
PRSNA  DAC  0                Save WA
*
*      Work locs for GENPC - some also accessed by CODEG
*
PCACT  DAC  0                Arg count
PCLAB  DAC  0                Label for code
PRCSP  DAC  0                Save static pointer
       EJC
*
*      Work locations for procedure call
*
PCSNA  DAC  0                Save number of arguments supplied
PCSPC  DAC  0                Save PCBLK for called procedure
PCSVL  DAC  0                Save ptr past locals
PCSXS  DAC  0                Save stack pointer
.IF    .CNPF
.ELSE
*
*      Work locations for Profiler.
*
PFSIA  DIC  +0
.FI
*
*      Work areas for PRTST procedure
*
PRSVA  DAC  0                Save WA
PRSVB  DAC  0                Save WB
PRSVC  DAC  0                Save char counter
*
*      Work area for PRTNL
*
PRTSA  DAC  0                Save WA
PRTSB  DAC  0                Save WB
*
*      Work areas for pattern match routines
*
PSAVC  DAC  0                save cursor in pattern string
PSCHR  DAC  0                pattern string as single char
*
*      Work area for S$REA
*
RDCNT  DAC  0                Argument count for READ
.IF    .CREL
*
*      Work area for RELAJ routine
*
RLALS  DAC  0                Ptr to list of bounds and adjusts
*
*      Work area for RELDN routine
*
RLDCD  DAC  0                Save code adjustment
RLDST  DAC  0                Save static adjustment
RLDLS  DAC  0                Save list pointer
.FI
*
*      Work location for RPLIC procedure
*
RPLXR  DAC  0                Save location for XR
*
*      Work locs for procedure return
*
RTPCB  DAC  0                Save PCBLK
RTRSL  DAC  0                Save result
RTTMP  DAC  0                Temp count (CDGEN)
RTSLC  DAC  0                Save pointer past locals
RTXSB  DAC  0                Save old stack base
*
*      Work areas for scan procedure
*
SCNCH  DAC  0                Save character
SCNCN  DAC  0                0 if scanning name or constant
SCNNC  DAC  0                Set if concatenation not required
SCNSE  DAC  0                Start of current element
SCNOF  DAC  0                Save offset
SCNUD  DAC  0                User defined operator flag
*
*      Work loc for SCONC
*
SCNCR  DAC  0                Save result
*
*      Work locs for SCANX
*
SCXSE  DAC  0                start of scanned element
SCXEC  DAC  0                element count
SCXSC  DAC  0                set bracket count
SCXTC  DAC  0                tuple bracket count
*
*      Work areas for STOPR routine
*
STPSI  DIC  +0               Save value of stcount
STPTI  DIC  +0               Save time elapsed
*
*      Work locs for STRSB
*
STRBL  DAC  0                save XL
STRBR  DAC  0                save XR
*
*      Work area for SYMTS procedure
*
SYMHS  DIC  +0               Hash value
SYMNL  DAC  0                Proc no. ORed with name length
SYMNW  DAC  0                Number of words in name
SYMSA  DAC  0                Save WA
SYMSB  DAC  0                Save WB
SYMSC  DAC  0                Characters pointer (for name)
*
*      TNBLD word area
*
TNBXT  DAC  0                Save XT for sem RHS
*
*      UNION flag work area
*
UFLAG  DAC  0
*
*      Start of Global values in Working Section
*
G$AAA  DAC  0
*
*      Global values for ALLOC procedure
*
.IF    .CDBG
ALDBC  DAC  0                Debug entry count
.FI
ALFSF  DIC  +0               Factor in free store pcntage check
*
*      Global atom counter
*
ATNUM  DIC  +0               Current number
*
*      String to print atoms
*
ATSTR  DAC  B$SCL
       DAC  1
       DTC  /$/
*
*      Global values for CMPIL procedure
*
ACTLR  DAC  0                Current action - LALR version
CTOKN  DAC  0                LALR code for current token
SCNXL  DAC  0                XL value from SCANE
SCNXR  DAC  0                XR value from SCANE
CCSTN  DAC  1                Statement for current CCBLK
CMERC  DAC  0                Count of initial compile errors
CMPXS  DAC  0                Save stack ptr in case of errors
CMPSN  DAC  1                Number of next statement to compile
*
*      Global value used by CDGEN procedure
*
CDGSN  DAC  1                Nr of next stmt to be generated
.IF    .CNPF
.ELSE
*
*      Colon used in printing out CASE skeleton
*
COLON  DAC  B$SCL
       DAC  1                Chars are filled in at runtime
       DTC  / /
.FI
       EJC
*
*      Comma used as separator when printing sets, tuples
*
COMMA  DAC  B$SCL
       DAC  2
       DTC  /, /
*
*      Global value for compiling CONTINUE
*
CONTL  DAC  0                Destination label
*
*      Flag for suppression of compilation statistics.
*
CPSTS  DAC  0                Suppress comp stats if non zero
*
*      JVK - global for control card switches - for OSINT compat
*
CSWFL  DAC  1                0/1 FOR -NOFAIL/-FAIL
*
*      Global location used by PATCT procedure
*
CTMSK  DAC  0                last bit position used in R$CTP
*
*      Global value for CDWRD procedure
*
CWCOF  DAC  0                Next word offset in current CCBLK
.IF    .CSED
*
*      Global locations for dynamic storage pointers
*
DNAMS  DAC  0                size of sediment in baus
.FI
*
*      end-of-file flag
*
EOFLG  DAC  0                Initially clear
*
*      Global compile error flag
*
ERFLG  DAC  0                Non-zero to suppress TNBLD, CODG
*
*      Label used for YIELD
*
EXPRL  DAC  0
*
*      Count of temps inside EXPR
*
EXTMP  DAC  0
*
*      Flag for suppression of execution stats
*
EXSTS  DAC  0                Suppress exec stats if set
*
*      TVBLK for FALSE
*      Value is followed by an SCBLK giving STR representation,
*      which is filled in at initialisation
*
FALSE  DAC  B$TVL
       DAC  B$SCL
       DAC  2
       DTC  / F/
*
*      Global values for EXFAL and return
*
FLPRT  DAC  0                Location of fail offset for return
FLPTR  DAC  0                Location of failure offset on stack
*
*      Global location to count garbage collections (GBCOL)
*
.IF    .CSED
GBSED  DIC  +0               Factor in sediment pcntage check
.FI
GBCNT  DAC  0                Count of garbage collections
GBCST  DAC  0                Save entry stage
*
*      Global locations (constants) for GTSTG procedure
*
.IF    .CNRA
.ELSE
.IF    .CNCR
.ELSE
GTSRN  DRC  +0.0             Rounding factor 0.5*10**-CFP$S
GTSSC  DRC  +0.0             Scaling value 10**CFP$S
.FI
.FI
GTSWK  DAC  0                Ptr to work area for GTSTG
*
*      Global value for GTCOD and GTEXP
*
GTCEF  DAC  0                Save fail prt in case of error
*
*      Constant used bu HASHV to reduce to range
*
HSV$M  DIC  +0
*
*      Flag for header printing
*
HEADP  DAC  0                Header printed flag
       EJC
*
*      Global values for hash tables
*
HSHNB  DIC  +0               Symbol table number of buckets
*
*      Global values for init
*
ININX  DAC  0                Set non-zero to inhibit execution
INITR  DAC  0                Save terminal flag
*
*      Global values used during execution
*      Some from SPITBOL for compatability with OSINT
*
KVCOM  DAC  0                SPITBOL COMPARE
KVDMP  DAC  0                SPITBOL DUMP
KVFTR  DAC  0                SPITBOL PROFILE
KVPFL  DAC  0                SPITBOL PROFILE
KVSTC  DIC  +0               Count of statements executed
KVSTN  DAC  0                Nr of stmt executing
*
*      Value of highest compiler-generated label used so far
*
LBNUM  DAC  CFP$B
*
*      Count of temps inside loop
*
LPTMP  DAC  0
*
*      Global values for LISTR procedure
*
LSTLC  DAC  0                Count lines on source list page
LSTLN  DAC  0                Line number
LSTNO  DAC  0                Line listing number
LSTNP  DAC  0                Max number of lines on page
LSTPF  DAC  1                Set nonzero if current image listed
LSTPG  DAC  0                Current source list page number
LSTPO  DAC  0                Offset to   page nnn   message
LSTSN  DAC  0                Stmt nr to put on current image
LSTSW  DAC  1                Listing switch
*
*      SCBLKs for left set and tuple brackets -
*      filled in during initialisation
*
LSETB  DAC  B$SCL
.IF    .CSBR
       DAC  1
       DTC  / /
.ELSE
       DAC  2
       DTC  /  /
.FI
*
LTUPB  DAC  B$SCL
       DAC  1
       DTC  / /
       EJC
*
*      Maximum size of SETL-S objects
*
MXLEN  DAC  0                Initialised by SYSMX call
*
.IF    .CNPF
.ELSE
*
*      Profiler work locations and run-time-initialised values.
*
PFBBN  DAC  0                basic block nr being profiled
PFCOF  DAC  0                column offset in profile table
PFETM  DIC  +0               ending time of basic block
PFSTE  DIC  +0               (integer) size of a table entry
PFNBB  DAC  0                number of basic blocks
PFNCL  DAC  0                nr of cols to print in table
PFSTM  DIC  +0               start time of basic block
.FI
*
*      JVK - pattern match global - for OSINT compat.
*
PMHBS  DAC  0
*
*      Global values for interface polling (SYSPL)
*
POLCT  DAC  1                Counter for polling interval
*
*      SETL source program procedure number
*
PRCNO  DAC  0                Procedure number
*
*      Flags used for standard file listing options
*
PRICH  DAC  0                Printer on interactive channel
PRSTD  DAC  0                Tested by PRTPG
PRSTO  DAC  0                Standard listing option flag
*
*      Global values for print procedures
*
PRBUF  DAC  0                Ptr to print bfr in static
PRECL  DAC  0                Extended/compact listing flag
PRLEN  DAC  0                Length of print buffer in chars
PRLNW  DAC  0                Length of print buffer in words
PROFS  DAC  0                Offset to next location in PRBUF
PRTEF  DAC  0                Endfile flag
*
*      Global values for string primitives
*
PMSSL  DAC  0                Save len of result
*
*      Global value for compiling QUIT
*
QUITL  DAC  0                destination label
*
*      Error recovery switch
*
RCVSW  DAC  0
*
*      Global EOF flag for READR
*
RDEOF  DAC  0
*
*      Global sign info for Random
*
RNDSN  DAC  0
*
*      Global value shared by Range and Domain
*
RNDMS  DAC  0
RNDSV  DAC  0
RNGDM  DAC  0
*
*      Global - Amount of memory reserved for end of execution
*
RSMEM  DAC  0                Reserve memory
       EJC
*
*      SCBLKs for right set and tuple brackets -
*      filled in during initialisation
*
RSETB  DAC  B$SCL
.IF    .CSBR
       DAC  1
       DTC  / /
.ELSE
       DAC  2
       DTC  /  /
.FI
*
RTUPB  DAC  B$SCL
       DAC  1
       DTC  / /
*
*      Adjustable global values
*
*      All the pointers in this section can point to the
*      dynamic or the static region.
*      When a save file is reloaded, these pointers must
*      be adjusted if static or dynamic memory is now
*      at a different address.  See routine RELOC for
*      additional information.
*
*      Some values cannot be moved here because of adjacency
*      constraints.  They are handled specially by RELOC et al.
*      These values are KVRTN,
*
*      Values GTSWK, KVALP, and PRBUF are reinitialized by
*      procedure INSTA, and do not need to appear here.
*
*      Values FLPRT, FLPTR, GTCEF, and STBAS point into the
*      stack and are explicitly adjusted by OSINT's restart
*      procedure.
*
A$AAA  DAC  0                Start of Adjustable values
CMPSS  DAC  0                Save subroutine stack ptr
DNAMB  DAC  0                Start of dynamic area
DNAMP  DAC  0                Next available loc in dynamic area
DNAME  DAC  0                End of available dynamic area
HSHTB  DAC  0                Symbol table start address
HSHTE  DAC  0                Symbol table pointer past end
INISS  DAC  0                Save subroutine stack ptr
PFTBL  DAC  0                table origin address
STATB  DAC  0                Start of static area
STATE  DAC  0                End of static area
*
*      Relocatable global values
*
*      All the pointers in this section can point to blocks in
*      the dynamic storage area and must be relocated by the
*      garbage collector. They are identified by r$xxx names.
*
R$AAA  DAC  0                Start of relocatable values
R$ACT  DAC  0                Ptr to LALR action table
R$CCB  DAC  0                Ptr to CCBLK being built (CDWRD)
R$CHK  DAC  0                Ptr to LALR check table
R$CIM  DAC  0                Ptr to current compiler input STR
R$CNI  DAC  0                Ptr to next compiler input string
R$COD  DAC  0                Pointer to current CDBLK or exblk
R$CSV  DAC  0                CDGEN save
R$CTP  DAC  0                Ptr to current char table CTBLK
R$ETX  DAC  NULLS            Pointer to errtext string
R$FCB  DAC  0                FCBLK chain head
R$IO1  DAC  0                 ioput arg1
R$IO2  DAC  0                 ioput arg2
R$FIN  DAC  0                Ptr to selected input
R$FOU  DAC  0                Ptr to selected output
R$LBC  DAC  0
R$LBR  DAC  0                List of references made in CCBLK
R$LBV  DAC  0                Pointer to label table
R$LHS  DAC  0                Ptr to LALR LHS table
R$PCB  DAC  0                Pointer to current PCBLK
R$PMS  DAC  0                Pointer to str primitive search string
R$PPS  DAC  0                Pointer to str prim pattern string
R$PSB  DAC  0                Pointer to str prim substring
R$PVB  DAC  0                Pointer to PVBLK chain
R$RDI  DAC  0                pointer to current input line
R$RDS  DAC  0                pointer to partially built strings
R$RHS  DAC  0                Ptr to LALR RHS table
R$SCP  DAC  0                Save pointer from last SCANE call
.IF    .CSFN
R$SFC  DAC  NULLS            Current source file name
R$SFN  DAC  0                Ptr to source file name table
.FI
R$SNM  DAC  0                Ptr to LALR Symbol Number Mapping
R$SRP  DAC  0                Save pointer from last reduction
R$STL  DAC  0                Source listing SUB-title
R$STV  DAC  0                Save state ptr in error recovery
R$TRI  DAC  NULLS            Terminal read input SCBLK
R$TTL  DAC  NULLS            Source listing title
R$URS  DAC  0
R$UST  DAC  0                work loc for UNION
R$YYY  DAC  0                Last relocatable location
       EJC
*
*      Global locations used in scan procedure
*
SCNIL  DAC  0                Length of current input image
SCNPT  DAC  0                Pointer to next location in R$CIM
SCNRS  DAC  0                Set non-zero to signal rescan
SCNRT  DAC  0                Save nonterminal
SCNTP  DAC  0                Save syntax type from last call
*
*      Globals for SCANX
*
SCXCP  DAC  0                character pointer
SCXIL  DAC  0                input line length
*
*      Globals for SLICT
*
SLCIC  DAC  0                source index counter
SLCIE  DAC  0                ending index
SLCTC  DAC  0                target index counter
*
*      Globals for SLTPI
*
SLTIE  DAC  0                source end index
SLTIC  DAC  0                source index counter
SLTTC  DAC  0                target index counter
*
*      Global value for indicating STAGE
*
STAGE  DAC  0                Initial value = do syntax tables
       EJC
*
*      Global stack pointer
*
STBAS  DAC  0                Pointer past stack base
*
*      Stack switch - set nonzero by CDGEN if a compiled
*      statement has not cleared the stack
*
STKSW  DAC  0
*
*      Global value for time keeping
*
TIMSX  DIC  +0               Time at start of execution
TIMUP  DAC  0                Set when time up occurs
*
*      Terminal read S$REA globals
*
TRXCP  DAC  0                Current offset pointer
TRXIL  DAC  0                Length of current input line
*
*      TVBLK for TRUE
*      The value is followed by an SCBLK giving the
*      STR representation - filled in during initialisation
*
TRUE$  DAC  B$TVL
       DAC  B$SCL
       DAC  2
       DTC  / T/
       EJC
*
*      Label to mark end of work area / start of WDBLKs
*
YYYYY  DAC  0
       EJC
*
*      The following area is not strictly a work area but is
*      placed in the working storage section since each entry
*      contains a field which is altered during execution to
*      hold a hash chain pointer. The entries here are for the
*      reserved words of the language which are inserted
*      into the symbol table during compiler initialisation.
*
*      Reserved word blocks (WDBLKs)
*
W$ABS  DAC  WD$OP             ABS  operator
       DAC  WOP10
       DAC  O$ABS
       DAC  0
       DAC  3
       DTC  /ABS/
*
W$AND  DAC  WD$OP             AND  operator
       DAC  WOP03
       DAC  O$AND
SCAND  DAC  0
       DAC  3
       DTC  /AND/
*
W$ARB  DAC  WD$OP             ARB  operator
       DAC  WOP10
       DAC  O$ARB
       DAC  0
       DAC  3
       DTC  /ARB/
       EJC
*
W$CHR  DAC  WD$OP             CHAR  operator
       DAC  WOP10
       DAC  O$CHR
       DAC  0
       DAC  4
       DTC  /CHAR/
*
W$DOM  DAC  WD$OP             DOMAIN  operator
       DAC  WOP10
       DAC  O$DOM
       DAC  0
       DAC  6
       DTC  /DOMAIN/
*
W$EVN  DAC  WD$OP             EVEN  operator
       DAC  WOP10
       DAC  O$EVN
       DAC  0
       DAC  4
       DTC  /EVEN/
*
W$FIX  DAC  WD$OP             FIX  operator
       DAC  WOP10
       DAC  O$FIX
       DAC  0
       DAC  3
       DTC  /FIX/
*
W$FLO  DAC  WD$OP             FLOAT  operator
       DAC  WOP10
       DAC  O$FLO
       DAC  0
       DAC  5
       DTC  /FLOAT/
*
W$FRM  DAC  WD$OP             FROM  operator
       DAC  WOP11
       DAC  O$FRM
       DAC  0
       DAC  4
       DTC  /FROM/
       EJC
*
W$FRB  DAC  WD$OP            FROMB operator
       DAC  WOP11
       DAC  O$FRB
       DAC  0
       DAC  5
       DTC  /FROMB/
*
W$FRE  DAC  WD$OP             FROME  operator
       DAC  WOP11
       DAC  O$FRE
       DAC  0
       DAC  5
       DTC  /FROME/
*
W$IAT  DAC  WD$OP             IS_ATOM  operator
       DAC  WOP04
       DAC  O$IAT
       DAC  0
       DAC  7
       DTC  /IS_ATOM/
*
W$IBO  DAC  WD$OP             IS_BOOLEAN
       DAC  WOP04
       DAC  O$IBO
       DAC  0
       DAC  10
       DTC  /IS_BOOLEAN/
*
W$IIN  DAC  WD$OP             IS_INTEGER
       DAC  WOP04
       DAC  O$IIN
       DAC  0
       DAC  10
       DTC  /IS_INTEGER/
*
W$IMA  DAC  WD$OP             IS_MAP
       DAC  WOP04
       DAC  O$IMA
       DAC  0
       DAC  6
       DTC  /IS_MAP/
*
W$IMP  DAC  WD$OP             IMP  operator
       DAC  WOP01
       DAC  O$IMP
SCIMP  DAC  0
       DAC  3
       DTC  /IMP/
*
W$$IN  DAC  WD$OP             IN operator
       DAC  WOPIN
       DAC  O$OIN
       DAC  0
       DAC  2
       DTC  /IN/
*
W$INC  DAC  WD$OP             INCS  operator
       DAC  WOP05
       DAC  O$INC
       DAC  0
       DAC  4
       DTC  /INCS/
*
W$ISE  DAC  WD$OP             IS_SET  operator
       DAC  WOP04
       DAC  O$ISE
       DAC  0
       DAC  6
       DTC  /IS_SET/
*
W$IST  DAC  WD$OP             IS_STRING  operator
       DAC  WOP04
       DAC  O$IST
       DAC  0
       DAC  9
       DTC  /IS_STRING/
*
W$ITU  DAC  WD$OP             IS_TUPLE  operator
       DAC  WOP04
       DAC  O$ITU
       DAC  0
       DAC  8
       DTC  /IS_TUPLE/
*
W$LES  DAC  WD$OP             LESS  operator
       DAC  WOP07
       DAC  O$LES
       DAC  0
       DAC  4
       DTC  /LESS/
       EJC
*
W$LSF  DAC  WD$OP             LESSF  operator
       DAC  WOP07
       DAC  O$LSF
       DAC  0
       DAC  5
       DTC  /LESSF/
*
W$MAX  DAC  WD$OP             MAX  operator
       DAC  WOP07
       DAC  O$MAX
       DAC  0
       DAC  3
       DTC  /MAX/
*
W$MIN  DAC  WD$OP             MIN  operator
       DAC  WOP07
       DAC  O$MIN
       DAC  0
       DAC  3
       DTC  /MIN/
*
W$NOT  DAC  WD$OP             NOT  operator
       DAC  WOP04
       DAC  O$NOT
       DAC  0
       DAC  3
       DTC  /NOT/
*
W$NIN  DAC  WD$OP             NOTIN  operator
       DAC  WOP05
       DAC  O$NIN
       DAC  0
       DAC  5
       DTC  /NOTIN/
*
W$NPW  DAC  WD$OP             NPOW  operator
       DAC  WOP09
       DAC  O$NPW
       DAC  0
       DAC  4
       DTC  /NPOW/
*
W$ODD  DAC  WD$OP             ODD  operator
       DAC  WOP10
       DAC  O$ODD
       DAC  0
       DAC  3
       DTC  /ODD/
*
W$IOR  DAC  WD$OP              INCLUSIVE OR  operator
       DAC  WOP02
       DAC  O$IOR
SC$OR  DAC  0
       DAC  2
       DTC  /OR/
       EJC
*
W$POW  DAC  WD$OP             POW  operator
       DAC  WOP10
       DAC  O$POW
       DAC  0
       DAC  3
       DTC  /POW/
*
W$RND  DAC  WD$OP
       DAC  WOP10
       DAC  O$RND
       DAC  0
       DAC  6
       DTC  /RANDOM/
*
W$RNG  DAC  WD$OP             RANGE  operator
       DAC  WOP10
       DAC  O$RNG
       DAC  0
       DAC  5
       DTC  /RANGE/
*
W$REM  DAC  WD$OP             REM  operator
       DAC  WOP08
       DAC  O$REM
       DAC  0
       DAC  3
       DTC  /MOD/
*
W$DVI  DAC  WD$OP             DIV (integer division)  operator
       DAC  WOP08
       DAC  O$DVI
       DAC  0
       DAC  3
       DTC  /DIV/
*
W$STR  DAC  WD$OP             STR  operator
       DAC  WOP10
       DAC  O$STR
       DAC  0
       DAC  3
       DTC  /STR/
       EJC
*
W$SBS  DAC  WD$OP             SUBSET  operator
       DAC  WOP05
       DAC  O$SBS
       DAC  0
       DAC  6
       DTC  /SUBSET/
*
W$TYP  DAC  WD$OP             TYPE  operator
       DAC  WOP10
       DAC  O$TYP
       DAC  0
       DAC  4
       DTC  /TYPE/
*
W$VAL  DAC  WD$OP             VAL  operator
       DAC  WOP10
       DAC  O$VAL
       DAC  0
       DAC  3
       DTC  /VAL/
       EJC
*
W$WIT  DAC  WD$OP             WITH  operator
       DAC  WOP07
       DAC  O$WIT
       DAC  0
       DAC  4
       DTC  /WITH/
*
W$CAS  DAC  WD$KW            CASE  keyword
       DAC  WTCAS
       DAC  WTCAS
SCCAS  DAC  0
       DAC  4
       DTC  /CASE/
*
W$CST  DAC  WD$KW             CONST  keyword
       DAC  WTCST
       DAC  WTCST
       DAC  0
       DAC  5
       DTC  /CONST/
       EJC
*
W$CNT  DAC  WD$KW             CONT  keyword
       DAC  WTCNT
       DAC  WTCNT
       DAC  0
       DAC  4
       DTC  /CONT/
*
W$CNU  DAC  WD$KW             CONTINUE  keyword
       DAC  WTCNT
       DAC  WTCNT
SCCNU  DAC  0
       DAC  8
       DTC  /CONTINUE/
*
W$DNG  DAC  WD$KW             DOING  keyword
       DAC  WTDNG
       DAC  WTDNG
SCDNG  DAC  0
       DAC  5
       DTC  /DOING/
*
W$ELS  DAC  WD$KW             ELSE  keyword
       DAC  WTELS
       DAC  WTELS
SCELS  DAC  0
       DAC  4
       DTC  /ELSE/
       EJC
*
W$ELF  DAC  WD$KW             ELSEIF  keyword
       DAC  WTELF
       DAC  WTELF
SCELF  DAC  0
       DAC  6
       DTC  /ELSEIF/
*
W$END  DAC  WD$KW             END  keyword
       DAC  WTEND
       DAC  WTEND
SCEND  DAC  0
       DAC  3
       DTC  /END/
*
W$EXS  DAC  WD$KW             EXISTS  keyword
       DAC  WTEXS
       DAC  WTEXS
SCEXS  DAC  0
       DAC  6
       DTC  /EXISTS/
*
W$EXP  DAC  WD$KW             EXPR  keyword
       DAC  WTEXP
       DAC  WTEXP
SCEXP  DAC  0
       DAC  4
       DTC  /EXPR/
       EJC
*
W$FOR  DAC  WD$KW             FOR  keyword
       DAC  WTFOR
       DAC  WTFOR
SCFOR  DAC  0
       DAC  3
       DTC  /FOR/
*
W$FRL  DAC  WD$KW             FORALL  keyword
       DAC  WTFRL
       DAC  WTFRL
SCFRL  DAC  0
       DAC  6
       DTC  /FORALL/
*
       EJC
*
W$$DO  DAC  WD$KW             DO  keyword
       DAC  WT$DO
       DAC  WT$DO
SC$DO  DAC  0
       DAC  2
       DTC  /DO/
*
W$$IF  DAC  WD$KW             IF  keyword
       DAC  WT$IF
       DAC  WT$IF
SC$IF  DAC  0
       DAC  2
       DTC  /IF/
*
W$INI  DAC  WD$KW             INIT  keyword
       DAC  WTINI
       DAC  WTINI
SCINI  DAC  0
       DAC  4
       DTC  /INIT/
*
W$LOO  DAC  WD$KW             LOOP  keyword
       DAC  WTLOO
       DAC  WTLOO
SCLOO  DAC  0
       DAC  4
       DTC  /LOOP/
       EJC
*
W$NXS  DAC  WD$KW             NOTEXISTS  keyword
       DAC  WTNXS
       DAC  WTNXS
SCNXS  DAC  0
       DAC  9
       DTC  /NOTEXISTS/
*
W$$OF  DAC  WD$KW             OF  keyword
       DAC  WT$OF
       DAC  WT$OF
SC$OF  DAC  0
       DAC  2
       DTC  /OF/
*
       EJC
*
W$PAS  DAC  WD$KW             PASS  keyword
       DAC  WTPAS
       DAC  PASSS
       DAC  0
       DAC  4
       DTC  /PASS/
*
W$PRC  DAC  WD$KW             PROC  keyword
       DAC  WTPRC
       DAC  WTPRC
       DAC  0
       DAC  4
       DTC  /PROC/
*
W$PRO  DAC  WD$KW             PROCEDURE  keyword
       DAC  WTPRC
       DAC  WTPRC
SCPRO  DAC  0
       DAC  9
       DTC  /PROCEDURE/
*
W$PRG  DAC  WD$KW             PROG  keyword
       DAC  WTPRG
       DAC  WTPRG
       DAC  0
       DAC  4
       DTC  /PROG/
       EJC
*
W$PRM  DAC  WD$KW             PROGRAM  keyword
       DAC  WTPRG
       DAC  WTPRG
       DAC  0
       DAC  7
       DTC  /PROGRAM/
*
W$QUI  DAC  WD$KW             QUIT  keyword
       DAC  WTQUI
       DAC  WTQUI
SCQUI  DAC  0
       DAC  4
       DTC  /QUIT/
       EJC
*
W$RTN  DAC  WD$KW             RETURN  keyword
       DAC  WTRTN
       DAC  WTRTN
SCRTN  DAC  0
       DAC  6
       DTC  /RETURN/
*
W$$ST  DAC  WD$KW             ST (such that)  keyword
       DAC  WT$ST
       DAC  WT$ST
SC$ST  DAC  0
       DAC  2
       DTC  /ST/
*
W$STP  DAC  WD$KW             STEP  keyword
       DAC  WTSTP
       DAC  WTSTP
SCSTP  DAC  0
       DAC  4
       DTC  /STEP/
*
W$STO  DAC  WD$KW             STOP  keyword
       DAC  WTSTO
       DAC  O$END
       DAC  0
       DAC  4
       DTC  /STOP/
       EJC
*
W$TRM  DAC  WD$KW             TERM  keyword
       DAC  WTTRM
       DAC  WTTRM
SCTRM  DAC  0
       DAC  4
       DTC  /TERM/
*
W$THN  DAC  WD$KW             THEN  keyword
       DAC  WTTHN
       DAC  WTTHN
SCTHN  DAC  0
       DAC  4
       DTC  /THEN/
*
W$UNT  DAC  WD$KW             UNTIL  keyword
       DAC  WTUNT
       DAC  WTUNT
SCUNT  DAC  0
       DAC  5
       DTC  /UNTIL/
*
W$VAR  DAC  WD$KW            VAR keyword
       DAC  WTVAR
       DAC  WTVAR
       DAC  0
       DAC  3
       DTC  /VAR/
*
W$WHE  DAC  WD$KW             WHERE  keyword
       DAC  WT$ST
       DAC  WT$ST
       DAC  0
       DAC  5
       DTC  /WHERE/
       EJC
*
W$WHI  DAC  WD$KW             WHILE  keyword
       DAC  WTWHI
       DAC  WTWHI
SCWHI  DAC  0
       DAC  5
       DTC  /WHILE/
*
W$YLD  DAC  WD$KW             YIELD  keyword
       DAC  WTYLD
       DAC  WTYLD
SCYLD  DAC  0
       DAC  5
       DTC  /YIELD/
*
       EJC
*
*      System Constants etc
*
WDTRU  DAC  WD$KW
       DAC  T$RNM
       DAC  TRUE$
       DAC  0
       DAC  4
       DTC  /TRUE/
*
WDFAL  DAC  WD$KW
       DAC  T$RNM
       DAC  FALSE
       DAC  0
       DAC  5
       DTC  /FALSE/
*
WD$OM  DAC  WD$KW
       DAC  T$RNM
       DAC  OMEGA
       DAC  0
       DAC  2
       DTC  /OM/
       EJC
*
*      The following are really just system library functions
*      but they appear, for various reasons, in the grammar
*      either explicitly or as system constants.
*
W$AST  DAC  WD$KW
       DAC  WTAST
       DAC  F$AST
       DAC  0
       DAC  6
       DTC  /ASSERT/
*
W$DAT  DAC  WD$KW
       DAC  T$RNM
       DAC  F$DAT
       DAC  0
       DAC  4
       DTC  /DATE/
*
W$GET  DAC  WD$KW
       DAC  WTRDA
       DAC  F$GET
       DAC  0
       DAC  3
       DTC  /GET/
*
W$NAT  DAC  WD$KW
       DAC  T$RNM
       DAC  F$NAT
       DAC  0
       DAC  5
       DTC  /NEWAT/
       EJC
W$PRT  DAC  WD$KW
       DAC  WTPRT
       DAC  F$PRT
       DAC  0
       DAC  5
       DTC  /PRINT/
*
W$PTA  DAC  WD$KW
       DAC  WTPRT
       DAC  F$PTA
       DAC  0
       DAC  6
       DTC  /PRINTA/
*
W$PUT  DAC  WD$KW
       DAC  WTPRT
       DAC  F$PUT
       DAC  0
       DAC  3
       DTC  /PUT/
*
W$REA  DAC  WD$KW
       DAC  WTREA
       DAC  F$REA
       DAC  0
       DAC  4
       DTC  /READ/
*
W$RDA  DAC  WD$KW
       DAC  WTRDA
       DAC  F$RDA
       DAC  0
       DAC  5
       DTC  /READA/
*
W$RDL  DAC  WD$KW
       DAC  WTREA
       DAC  F$RDL
       DAC  0
       DAC  5
       DTC  /READL/
*
W$TIM  DAC  WD$KW
       DAC  T$RNM
       DAC  F$TIM
       DAC  0
       DAC  4
       DTC  /TIME/
*
*      String Primitives
*
W$ANY  DAC  WD$KW
       DAC  T$FNA
       DAC  F$ANY
       DAC  0
       DAC  3
       DTC  /ANY/
*
W$BRK  DAC  WD$KW
       DAC  T$FNA
       DAC  F$BRK
       DAC  0
       DAC  5
       DTC  /BREAK/
*
W$LEN  DAC  WD$KW
       DAC  T$FNA
       DAC  F$LEN
       DAC  0
       DAC  3
       DTC  /LEN/
*
W$LPD  DAC  WD$KW
       DAC  T$FNA
       DAC  F$LPD
       DAC  0
       DAC  4
       DTC  /LPAD/
*
W$MCH  DAC  WD$KW
       DAC  T$FNA
       DAC  F$MCH
       DAC  0
       DAC  5
       DTC  /MATCH/
*
W$NAY  DAC  WD$KW
       DAC  T$FNA
       DAC  F$NAY
       DAC  0
       DAC  6
       DTC  /NOTANY/
*
W$RAN  DAC  WD$KW
       DAC  T$FNA
       DAC  F$RAN
       DAC  0
       DAC  4
       DTC  /RANY/
*
W$RBR  DAC  WD$KW
       DAC  T$FNA
       DAC  F$RBR
       DAC  0
       DAC  6
       DTC  /RBREAK/
*
W$RLN  DAC  WD$KW
       DAC  T$FNA
       DAC  F$RLN
       DAC  0
       DAC  4
       DTC  /RLEN/
*
W$RMC  DAC  WD$KW
       DAC  T$FNA
       DAC  F$RMC
       DAC  0
       DAC  6
       DTC  /RMATCH/
*
W$RNA  DAC  WD$KW
       DAC  T$FNA
       DAC  F$RNA
       DAC  0
       DAC  7
       DTC  /RNOTANY/
*
W$RPD  DAC  WD$KW
       DAC  T$FNA
       DAC  F$RPD
       DAC  0
       DAC  4
       DTC  /RPAD/
*
W$RSP  DAC  WD$KW
       DAC  T$FNA
       DAC  F$RSP
       DAC  0
       DAC  5
       DTC  /RSPAN/
*
W$SPN  DAC  WD$KW
       DAC  T$FNA
       DAC  F$SPN
       DAC  0
       DAC  4
       DTC  /SPAN/
*
*      System functions
*
W$EOF  DAC  WD$KW
       DAC  T$FNA
       DAC  F$EOF
       DAC  0
       DAC  3
       DTC  /EOF/
*
W$HST  DAC  WD$KW
       DAC  T$FNA
       DAC  F$HST
       DAC  0
       DAC  4
       DTC  /HOST/
*
W$INP  DAC  WD$KW
       DAC  T$FNA
       DAC  INPUT
       DAC  0
       DAC  5
       DTC  /INPUT/
*
W$OUT  DAC  WD$KW
       DAC  T$FNA
       DAC  OUTPT
       DAC  0
       DAC  6
       DTC  /OUTPUT/
       EJC
*
*      Lexical classes
*
WDOP1  DAC  WD$LX             lexical class OP1
       DAC  WOP01
       DAC  WOP01
       DAC  0
       DAC  4
       DTC  /$OP1/
*
WDOP2  DAC  WD$LX             lexical class OP2
       DAC  WOP02
       DAC  WOP02
       DAC  0
       DAC  4
       DTC  /$OP2/
*
WDOP3  DAC  WD$LX             lexical class OP3
       DAC  WOP03
       DAC  WOP03
       DAC  0
       DAC  4
       DTC  /$OP3/
*
WDOP4  DAC  WD$LX             lexical class OP4
       DAC  WOP04
       DAC  WOP04
       DAC  0
       DAC  4
       DTC  /$OP4/
*
       EJC
WDOP5  DAC  WD$LX             lexical class OP5
       DAC  WOP05
       DAC  WOP05
       DAC  0
       DAC  4
       DTC  /$OP5/
*
WDOP7  DAC  WD$LX             lexical class OP7
       DAC  WOP07
       DAC  WOP07
       DAC  0
       DAC  4
       DTC  /$OP7/
*
WDOP8  DAC  WD$LX             lexical class OP8
       DAC  WOP08
       DAC  WOP08
       DAC  0
       DAC  4
       DTC  /$OP8/
*
       EJC
WDOP9  DAC  WD$LX             lexical class OP9
       DAC  WOP09
       DAC  WOP09
       DAC  0
       DAC  4
       DTC  /$OP9/
*
WDO10  DAC  WD$LX            lexical class OP10
       DAC  WOP10
       DAC  WOP10
       DAC  0
       DAC  5
       DTC  /$OP10/
*
WDO11  DAC  WD$LX            lexical class OP11
       DAC  WOP11
       DAC  WOP11
       DAC  0
       DAC  5
       DTC  /$OP11/
*
WDAOP  DAC  WD$LX             lexical class ASSOP
       DAC  WOPAS
       DAC  WOPAS
       DAC  0
       DAC  6
       DTC  /$ASSOP/
*
       EJC
WDFNM  DAC  WD$LX             lexical class FNAME
       DAC  T$FNA
       DAC  T$FNA
       DAC  0
       DAC  6
       DTC  /$FNAME/
*
WDSTR  DAC  WD$LX             lexical class STRING
       DAC  T$STR
       DAC  T$STR
       DAC  0
       DAC  7
       DTC  /$STRING/
*
WDNUM  DAC  WD$LX             lexical class NUMBER
       DAC  T$CON
       DAC  T$CON
       DAC  0
       DAC  7
       DTC  /$NUMBER/
*
WDNAM  DAC  WD$LX            lexical class NAME
       DAC  T$VAR
       DAC  T$VAR
       DAC  0
       DAC  5
       DTC  /$NAME/
*
       EJC
WDSYC  DAC  WD$LX             lexical class SYSCON
       DAC  T$RNM
       DAC  T$RNM
       DAC  0
       DAC  7
       DTC  /$SYSCON/
*
       EJC
WDERR  DAC  WD$LX            special error symbol/class
       DAC  ERR$$
       DAC  O$ERR
       DAC  0
       DAC  6
       DTC  /$ERROR/
       EJC
WDYYY  DAC  0                To mark end of WDBLK entries
*
*      Label to mark end of Working Storage Section
*
W$YYY  DAC  0
       EJC
*
       TTL  S P I T B O L -- MINIMAL CODE
       SEC                   START OF PROGRAM SECTION
S$AAA  ENT  BL$$I            MARK START OF CODE
*
.IF    .CREL
       TTL  S P I T B O L -- RELOCATION
*
*      RELOCATION
*      THE FOLLOWING SECTION PROVIDES SERVICES TO OSINT TO
*      RELOCATE PORTIONS OF THE WORKSPACE.  IT IS USED WHEN
*      A SAVED MEMORY IMAGE MUST BE RESTARTED AT A DIFFERENT
*      LOCATION.
*
*      RELAJ -- RELOCATE A LIST OF POINTERS
*
*      (WA)                  PTR PAST LAST POINTER OF LIST
*      (WB)                  PTR TO FIRST POINTER OF LIST
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELAJ            CALL TO PROCESS LIST OF POINTERS
*      (WB)                  DESTROYED
*
RELAJ  PRC  E,0              ENTRY POINT
       MOV  XR,-(XS)         SAVE XR
       MOV  WA,-(XS)         SAVE WA
       MOV  XL,RLALS         SAVE PTR TO LIST OF BOUNDS
       MOV  WB,XR            PTR TO FIRST POINTER TO PROCESS
*
*      MERGE HERE TO CHECK IF DONE
*
RLAJ0  MOV  RLALS,XL         RESTORE XL
       BNE  XR,(XS),RLAJ1    PROCEED IF MORE TO DO
       MOV  (XS)+,WA         RESTORE WA
       MOV  (XS)+,XR         RESTORE XR
       EXI                   RETURN TO CALLER
*
*      MERGE HERE TO PROCESS NEXT POINTER ON LIST
*
RLAJ1  MOV  (XR),WA          LOAD NEXT POINTER ON LIST
       LCT  WB,=RNSI$        NUMBER OF SECTIONS OF ADJUSTERS
*
*      MERGE HERE TO PROCESS NEXT SECTION OF STACK LIST
*
RLAJ2  BGT  WA,RLEND(XL),RLAJ3 OK IF PAST END OF SECTION
       BLT  WA,RLSTR(XL),RLAJ3 OR IF BEFORE START OF SECTION
       ADD  RLADJ(XL),WA     WITHIN SECTION, ADD ADJUSTMENT
       MOV  WA,(XR)          RETURN UPDATED PTR TO MEMORY
       BRN  RLAJ4            DONE WITH THIS POINTER
*
*      HERE IF NOT WITHIN SECTION
*
RLAJ3  ADD  *RSSI$,XL        ADVANCE TO NEXT SECTION
       BCT  WB,RLAJ2         JUMP IF MORE TO GO
*
*      HERE WHEN FINISHED PROCESSING ONE POINTER
*
RLAJ4  ICA  XR               INCREMENT TO NEXT PTR ON LIST
       BRN  RLAJ0            JUMP TO CHECK  FOR COMPLETION
       ENP                   END PROCEDURE RELAJ
       EJC
*
*      RELCR -- CREATE RELOCATION INFO AFTER SAVE FILE RELOAD
*
*      (WA)                  ORIGINAL S$AAA CODE SECTION ADR
*      (WB)                  ORIGINAL C$AAA CONSTANT SECTION ADR
*      (WC)                  ORIGINAL G$AAA WORKING SECTION ADR
*      (XR)                  PTR TO START OF STATIC REGION
*      (CP)                  PTR TO START OF DYNAMIC REGION
*      (XL)                  PTR TO AREA TO RECEIVE INFORMATION
*      JSR  RELCR            CREATE RELOCATION INFORMATION
*      (WA,WB,WC,XR)         DESTROYED
*
*      A BLOCK OF INFORMATION IS BUILT AT (XL) THAT IS USED
*      IN RELOCATING POINTERS.  THERE ARE RNSI$ INSTANCES
*      OF A RSSI$ WORD STRUCTURE.  EACH INSTANCE CORRESPONDS
*      TO ONE OF THE REGIONS THAT A POINTER MIGHT POINT INTO.
*      THE LAYOUT OF THIS STRUCTURE IS SHOWN IN THE DEFINITIONS
*      SECTION, TOGETHER WITH SYMBOLIC DEFINITIONS OF THE
*      ENTRIES AS OFFSETS FROM XL.
*
RELCR  PRC  E,0              ENTRY POINT
       ADD  *RLSI$,XL        POINT PAST BUILD AREA
       MOV  WA,-(XL)         SAVE ORIGINAL CODE ADDRESS
       MOV  =S$AAA,WA        COMPUTE ADJUSTMENT
       SUB  (XL),WA          AS NEW S$AAA MINUS ORIGINAL S$AAA
       MOV  WA,-(XL)         SAVE CODE ADJUSTMENT
       MOV  =S$YYY,WA        END OF TARGET CODE SECTION
       SUB  =S$AAA,WA        LENGTH OF CODE SECTION
       ADD  1(XL),WA         PLUS ORIGINAL START ADDRESS
       MOV  WA,-(XL)         END OF ORIGINAL CODE SECTION
       MOV  WB,-(XL)         SAVE CONSTANT SECTION ADDRESS
       MOV  =C$AAA,WB        START OF CONSTANTS SECTION
       MOV  =C$YYY,WA        END OF CONSTANTS SECTION
       SUB  WB,WA            LENGTH OF CONSTANTS SECTION
       SUB  (XL),WB          NEW C$AAA MINUS ORIGINAL C$AAA
       MOV  WB,-(XL)         SAVE CONSTANT ADJUSTMENT
       ADD  1(XL),WA         LENGTH PLUS ORIGINAL START ADR
       MOV  WA,-(XL)         SAVE AS END OF ORIGINAL CONSTANTS
       MOV  WC,-(XL)         SAVE WORKING GLOBALS ADDRESS
       MOV  =G$AAA,WC        START OF WORKING GLOBALS SECTION
       MOV  =W$YYY,WA        END OF WORKING SECTION
       SUB  WC,WA            LENGTH OF WORKING GLOBALS
       SUB  (XL),WC          NEW G$AAA MINUS ORIGINAL G$AAA
       MOV  WC,-(XL)         SAVE WORKING GLOBALS ADJUSTMENT
       ADD  1(XL),WA         LENGTH PLUS ORIGINAL START ADR
       MOV  WA,-(XL)         SAVE AS END OF WORKING GLOBALS
       MOV  STATB,WB         OLD START OF STATIC REGION
       MOV  WB,-(XL)         SAVE
       SUB  WB,XR            COMPUTE ADJUSTMENT
       MOV  XR,-(XL)         SAVE NEW STATB MINUS OLD STATB
       MOV  STATE,-(XL)      OLD END OF STATIC REGION
       MOV  DNAMB,WB         OLD START OF DYNAMIC REGION
       MOV  WB,-(XL)         SAVE
       SCP  WA               NEW START OF DYNAMIC
       SUB  WB,WA            COMPUTE ADJUSTMENT
       MOV  WA,-(XL)         SAVE NEW DNAMB MINUS OLD DNAMB
       MOV  DNAMP,WC         OLD END OF DYNAMIC REGION IN USE
       MOV  WC,-(XL)         SAVE AS END OF OLD DYNAMIC REGION
       EXI
       ENP
       EJC
*
*      RELDN -- RELOCATE POINTERS IN THE DYNAMIC REGION
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      (XR)                  PTR TO FIRST LOCATION TO PROCESS
*      (WC)                  PTR PAST LAST LOCATION TO PROCESS
*      JSR  RELDN            CALL TO PROCESS BLOCKS IN DYNAMIC
*      (WA,WB,WC,XR)         DESTROYED
*
*      PROCESSES ALL BLOCKS IN THE DYNAMIC REGION.  WITHIN A
*      BLOCK, POINTERS TO THE CODE SECTION, CONSTANT SECTION,
*      WORKING GLOBALS SECTION, STATIC REGION, AND DYNAMIC
*      REGION ARE RELOCATED AS NEEDED.
*
RELDN  PRC  E,0              ENTRY POINT
       MOV  RLCDA(XL),RLDCD  SAVE CODE ADJUSTMENT
       MOV  RLSTA(XL),RLDST  SAVE STATIC ADJUSTMENT
       MOV  XL,RLDLS         SAVE LIST POINTER
*
*      MERGE HERE TO PROCESS THE NEXT BLOCK IN DYNAMIC
*
RLD01  ADD  RLDCD,(XR)       ADJUST BLOCK TYPE WORD
       MOV  (XR),XL          LOAD BLOCK TYPE WORD
       LEI  XL               LOAD ENTRY POINT ID (BL$XX)
*
*      BLOCK TYPE SWITCH. NOTE THAT BLOCKS WITH NO RELOCATABLE
*      FIELDS JUST RETURN TO RLD05 TO CONTINUE TO NEXT BLOCK.
*
*      NOTE THAT DFBLKS DO NOT APPEAR IN DYNAMIC, ONLY IN STATIC.
*      CCBLKS AND CMBLKS ARE NOT LIVE WHEN A SAVE FILE IS
*      CREATED, AND CAN BE SKIPPED.  SAME OF LRBLKs AND LTBLKs.
*
*      FURTHER NOTE:  STATIC BLOCKS OTHER THAN VRBLKS DISCOVERED
*      WHILE SCANNING DYNAMIC MUST BE ADJUSTED AT THIS TIME.
*      SEE PROCESSING OF FFBLK FOR EXAMPLE.
*
       EJC
*
*      RELDN (CONTINUED)
*
       BSW  XL,BL$$$,RLD05   SWITCH ON BLOCK TYPE
       IFF  BL$AC,RLD05      ACBLK
       IFF  BL$AT,RLD05      ATBLK
       IFF  BL$CC,RLD05      CCBLK
       IFF  BL$CD,RLD07      CDBLK
       IFF  BL$CK,RLD05      CKBLK
       IFF  BL$CM,RLD05      CMBLK
       IFF  BL$CT,RLD05      CTBLK
       IFF  BL$EF,RLD08      EFBLK
       IFF  BL$IC,RLD05      ICBLK
       IFF  BL$IO,RLD13      IOBLK
       IFF  BL$LR,RLD05      LRBLK
       IFF  BL$LT,RLD05      LTBLK
       IFF  BL$MP,RLD09      MPBLK
       IFF  BL$OM,RLD10      OMEGA
       IFF  BL$PC,RLD14      PCBLK
       IFF  BL$PF,RLD05      PFBLK
       IFF  BL$PR,RLD03      PRBLK
.IF    .CNRA
.ELSE
       IFF  BL$RC,RLD05      RCBLK
.FI
       IFF  BL$RU,RLD05      RUBLK
       IFF  BL$SC,RLD05      SCBLK
       IFF  BL$SN,RLD05      SNBLK
       IFF  BL$ST,RLD09      STBLK
       IFF  BL$TP,RLD11      TPBLK
       IFF  BL$TV,RLD10      TVBLK
       IFF  BL$VC,RLD17      VCBLK
       IFF  BL$XN,RLD05      XNBLK
       IFF  BL$XR,RLD20      XRBLK
       ESW                   END OF JUMP TABLE
*
*      PRBLK
*
RLD03  MOV  *OFFS4,WA        LOAD LENGTH
       MOV  *PRDOM,WB        SET OFFSET TO 1ST RELOC FLD
*
*      MERGE HERE TO PROCESS POINTERS IN A BLOCK
*
*      (XR)                  PTR TO CURRENT BLOCK
*      (WC)                  PTR PAST LAST LOCATION TO PROCESS
*      (WA)                  LENGTH (RELOC FLDS + FLDS AT START)
*      (WB)                  OFFSET TO FIRST RELOC FIELD
*
RLD04  ADD  XR,WA            POINT PAST LAST RELOC FIELD
       ADD  XR,WB            POINT TO FIRST RELOC FIELD
       MOV  RLDLS,XL         POINT TO LIST OF BOUNDS
       JSR  RELAJ            ADJUST POINTERS
       EJC
*
*      RELDN (CONTINUED)
*
*
*      MERGE HERE TO ADVANCE TO NEXT BLOCK
*
*      (XR)                  PTR TO CURRENT BLOCK
*      (WC)                  PTR PAST LAST LOCATION TO PROCESS
*
RLD05  MOV  (XR),WA          BLOCK TYPE WORD
       JSR  BLKLN            GET LENGTH OF BLOCK
       ADD  WA,XR            POINT TO NEXT BLOCK
       BLT  XR,WC,RLD01      CONTINUE IF MORE TO PROCESS
       MOV  RLDLS,XL         RESTORE XL
       EXI                   RETURN TO CALLER IF DONE
*
*      CDBLK
*
RLD07  MOV  CDLEN(XR),WA     LOAD LENGTH
       MOV  *CDCOD,WB        DO NOT PROCESS CDFAL WORD
       BRN  RLD04            JUMP BACK
*
*      EFBLK
*
*      IF THE EFCOD WORD POINTS TO AN XNBLK, THE XNBLK TYPE
*      WORD WILL NOT BE ADJUSTED.  SINCE THIS IS IMPLEMENTATION
*      DEPENDENT, WE WILL NOT WORRY ABOUT IT.
*
RLD08  MOV  *EFRSL,WA        SET LENGTH
       MOV  *EFCOD,WB        AND OFFSET
       BRN  RLD04            ALL SET
*
*      MPBLK, STBLK
*
RLD09  MOV  STLEN(XR),WA     LOAD LENGTH
       MOV  *STSI$,WB        SET OFFSET
       BRN  RLD04            ALL SET
*
*      OMEGA, TVBLK
*
*      These are all fixed blocks in static, hence not done
*      here.  It's not clear that the related pointers in these,
*      or SCBLKs in the constant or working sections, are being
*      properly relocated.  Same problem with the keywords. JVK
*
RLD10  MOV  *OFFS2,WA        POINT PAST 2ND B$SCL FIELD
       MOV  *OFFS1,WB        OFFSET ONE (ONLY RELOC FIELD IS 2)
       BRN  RLD04            JUMP BACK
       EJC
*
*      RELDN (CONTINUED)
*
*      TPBLK
*
RLD11  MOV  TPLEN(XR),WA     SET LENGTH
       MOV  *TPSI$,WB        SET OFFSET
       BRN  RLD04            ALL SET
*
*      IOBLK
*
RLD13  MOV  *IOOFS,WA        POINT PAST FIFTH FIELD
       MOV  *OFFS1,WB        OFFSET IS ONE (RELOC FLD 2 TO 5)
       BRN  RLD04            ALL SET
*
*      PCBLK
*
RLD14  MOV  *PCSI$,WA        LENGTH
       MOV  *OFFS1,WB        SET OFFSET
       BRN  RLD04            ALL SET
*
*      VCBLK
*
RLD17  MOV  OFFS2(XR),WA     LOAD LENGTH
       MOV  *VCSI$,WB        SET OFFSET
       BRN  RLD04
*
*      XRBLK
*
RLD20  MOV  XRLEN(XR),WA     LOAD LENGTH
       MOV  *XRPTR,WB        SET OFFSET
       BRN  RLD04            JUMP BACK
       ENP                   END PROCEDURE RELDN
       EJC
*
*      RELOC -- RELOCATE STORAGE AFTER SAVE FILE RELOAD
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELOC            RELOCATE ALL POINTERS
*      (WA,WB,WC,XR)         DESTROYED
*
*      THE LIST OF BOUNDARIES AND ADJUSTMENTS POINTED TO BY
*      REGISTER XL IS CREATED BY A CALL TO RELCR, WHICH SHOULD
*      BE CONSULTED FOR INFORMATION ON ITS STRUCTURE.
*
RELOC  PRC  E,0              ENTRY POINT
       MOV  RLDYS(XL),XR     OLD START OF DYNAMIC
       MOV  RLDYE(XL),WC     OLD END OF DYNAMIC
       ADD  RLDYA(XL),XR     CREATE NEW START OF DYNAMIC
       ADD  RLDYA(XL),WC     CREATE NEW END OF DYNAMIC
       JSR  RELDN            RELOCATE POINTERS IN DYNAMIC
       JSR  RELWS            RELOCATE POINTERS IN WORKING SECT
       JSR  RELST            RELOCATE POINTERS IN STATIC
       EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE RELOC
       EJC
*
*      RELST -- RELOCATE POINTERS IN THE STATIC REGION
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELST            CALL TO PROCESS BLOCKS IN STATIC
*      (WA,WB,WC,XR)         DESTROYED
*
*      ONLY VRBLKS ON THE HASH CHAIN AND ANY PROFILE BLOCK ARE
*      PROCESSED.  OTHER STATIC BLOCKS (DFBLKS) ARE PROCESSED
*      DURING PROCESSING OF DYNAMIC BLOCKS.
*
*      GLOBAL WORK LOCATIONS WILL BE PROCESSED AT THIS POINT,
*      SO POINTERS THERE CAN BE RELIED UPON.
*
*      (JVK) THERE ARE SCBLKs, ICBLKs, AND TVBLKs IN BOTH
*      THE CONSTANT AND WORKING SECTIONS.  IT'S NOT CLEAR
*      HOW THE POINTERS IN THOSE ARE BEING RELOCATED.
*
RELST  PRC  E,0              ENTRY POINT
       MOV  PFTBL,XR         PROFILE TABLE
       BZE  XR,RLS01         BRANCH IF NO TABLE ALLOCATED
       ADD  RLCDA(XL),(XR)   ADJUST BLOCK TYPE WORD
*
*      HERE AFTER DEALING WITH PROFILER
*
RLS01  MOV  HSHTB,WC         POINT TO START OF HASH TABLE
       MOV  WC,WB            POINT TO FIRST HASH BUCKET
       MOV  HSHTE,WA         POINT BEYOND HASH TABLE
       JSR  RELAJ            ADJUST BUCKET POINTERS
*
*      LOOP THROUGH SLOTS IN HASH TABLE
*
RLS02  BEQ  WC,HSHTE,RLS05   DONE IF NONE LEFT
       MOV  WC,XR            ELSE COPY SLOT POINTER
       ICA  WC               BUMP SLOT POINTER
       SUB  *VRNXT,XR        SET OFFSET TO MERGE INTO LOOP
*
*      LOOP THROUGH VRBLKS ON ONE HASH CHAIN
*
RLS03  MOV  VRNXT(XR),XR     POINT TO NEXT VRBLK ON CHAIN
       BZE  XR,RLS02         JUMP FOR NEXT BUCKET IF CHAIN END
       MOV  *VRLEN,WA        OFFSET OF FIRST LOC PAST PTR FIELDS
       MOV  *VRGET,WB        OFFSET OF FIRST LOCATION IN VRBLK
       BNZ  VRLEN(XR),RLS04  JUMP IF NOT SYSTEM VARIABLE
       MOV  *VRSI$,WA        OFFSET TO INCLUDE VRSVP FIELD
*
*      MERGE HERE TO PROCESS FIELDS OF VRBLK
*
RLS04  ADD  XR,WA            CREATE END PTR
       ADD  XR,WB            CREATE START PTR
       JSR  RELAJ            ADJUST POINTERS IN VRBLK
       BRN  RLS03            CHECK FOR ANOTHER VRBLK ON CHAIN
*
*      HERE WHEN ALL VRBLKS PROCESSED
*
RLS05  EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE RELST
       EJC
*
*      RELWS -- RELOCATE POINTERS IN THE WORKING SECTION
*
*      (XL)                  LIST OF BOUNDARIES AND ADJUSTMENTS
*      JSR  RELWS            CALL TO PROCESS WORKING SECTION
*      (WA,WB,WC,XR)         DESTROYED
*
*      POINTERS BETWEEN A$AAA AND R$YYY ARE EXAMINED AND
*      ADJUSTED IF NECESSARY.  THE POINTER KVRTN IS ALSO
*      ADJUSTED ALTHOUGH IT LIES OUTSIDE THIS RANGE.
*      DNAME IS EXPLICITLY ADJUSTED BECAUSE THE LIMITS
*      ON DYNAMIC REGION IN STACK ARE TO THE AREA ACTIVELY
*      IN USE (BETWEEN DNAMB AND DNAMP), AND DNAME IS OUTSIDE
*      THIS RANGE.
*
RELWS  PRC  E,0              ENTRY POINT
       MOV  =A$AAA,WB        POINT TO START OF ADJUSTABLES
       MOV  =R$YYY,WA        POINT TO END OF ADJUSTABLES
       JSR  RELAJ            RELOCATE ADJUSTABLE POINTERS
       ADD  RLDYA(XL),DNAME  ADJUST PTR MISSED BY RELAJ
       EXI                   RETURN TO CALLER
       ENP                   END PROCEDURE RELWS
.FI
*
       TTL  S E T L - S -- INITIALISATION
*
*      Initialisation.
*      The following section receives control from the system
*      at the start of a run with the registers set as follows.
*
*      (WA)                  points past stack base
*      (XR)                  points to first word of data area
*      (XL)                  points to last word of data area
*
START  PRC  E,0              Entry - Start of program section
       MOV  WA,XS            Discard return
       JSR  SYSTM            Initialise timer
       STI  TIMSX            Store time
       MOV  XR,STATB         Start address of static
       MOV  *E$SRS,RSMEM     Reserve memory
       MOV  XS,STBAS         Store stack base
       SSS  INISS            Save S-R stack ptr
*
*      Now convert free store percentage to a suitable factor
*      for easy testing in ALLOC routine.
*
       LDI  INTVH            Get 100
       DVI  ALFSP            Form 100 / ALFSP
       STI  ALFSF            Store the factor
*
*      Initialise constant for HASHV
*
       MOV  =CFP$M,WA        single word integer
       MTI  WA
       STI  HSV$M
.IF    .CSED
*
*      Now convert free sediment percentage to a suitable factor
*      for easy testing in GBCOL routine.
*
       LDI  INTVH            Get 100
       DVI  GBSDP            Form 100 / GBSDP
       STI  GBSED            Store the factor
.FI
.IF    .CNRA
.ELSE
*
*      Initialize values for real conversion routine
*
       LCT  WB,=CFP$S        Load counter for significant digits
       LDR  REAV1            Load 1.0
*
*      Loop to compute 10**(max number significant digits)
*
INI03  MLR  REAVT            * 10.0
       BCT  WB,INI03         Loop till done
       STR  GTSSC            Store 10**(max sig digits)
       LDR  REAP5            Load 0.5
       DVR  GTSSC            Compute 0.5*10**(max sig digits)
       STR  GTSRN            Store as rounding bias
.FI
*
.IF    .CNPF
.ELSE
*
*      Initialise Profiler values.
*
       MTI  PFESA            get table entry size
       STI  PFSTE            store integer form for later
.FI
       EJC
*      Initialise SCBLKs for STRGV
*
       MOV  =LSETB,XR
       PSC  XR
.IF    .CSBR
       MOV  =CH$OS,WA
       SCH  WA,(XR)
.ELSE
*
*      Be satisfied with alternate
*
       MOV  =CH$OL,WA        less than
       SCH  WA,(XR)+
       SCH  WA,(XR)
.FI
       CSC  XR
*
       MOV  =RSETB,XR
       PSC  XR
.IF    .CSBR
       MOV  =CH$CS,WA
       SCH  WA,(XR)
.ELSE
       MOV  =CH$OG,WA           use greater than
       SCH  WA,(XR)+
       SCH  WA,(XR)
.FI
       CSC  XR
*
       MOV  =LTUPB,XR
       PSC  XR
.IF    .CTBR
       MOV  =CH$OT,WA        use opening tuple bracket
.ELSE
       MOV  =CH$OP,WA        use simple parenthesis
.FI
       SCH  WA,(XR)
       CSC  XR
*
       MOV  =RTUPB,XR
       PSC  XR
.IF    .CTBR
       MOV  =CH$CT,WA
.ELSE
       MOV  =CH$CP,WA
.FI
       SCH  WA,(XR)
       CSC  XR
       EJC
*
*      Now stick sharp signs into TRUE and FALSE
*
       MOV  =TRUE$,XR
       ICA  XR
       PSC  XR               this is the SCBLK
       MOV  =CH$NM,WA        aka number sign
       SCH  WA,(XR)
       CSC  XR
*
       MOV  =FALSE,XR
       ICA  XR
       PSC  XR
       SCH  WA,(XR)          same here
       CSC  XR
       EJC
*
*      Also sign to precede atoms on printing
*
       MOV  =ATSTR,XR
       PSC  XR,(XL)
       SCH  WA,(XR)
       CSC  XR
.IF    .CNPF
.ELSE
*
*      Fill in colon used in printing CASE skeleton
*
       MOV  =COLON,XR
       PSC  XR
       MOV  =CH$CL,WA
       SCH  WA,(XR)
       CSC  XR
.FI
       JSR  PRPAR            Read parameters
*
*      Now compute starting address for dynamic store and if
*      necessary request more memory.
*
       SUB  *E$SRS,XL        Allow for reserve memory
       MOV  PRLEN,WA         Get print buffer length
       ADD  =CFP$A,WA        ADD no of chars in alphabet
       ADD  =NSTMX,WA        ADD chars for GTSTG bfr
       CTB  WA,8             Convert to BAUS, allowing a margin
       MOV  STATB,XR         Point to static base
       ADD  WA,XR            Increment for above buffers
       ADD  *E$HNB,XR        Increment for hash table
       ADD  *E$STS,XR        Bump for initial static block
       JSR  SYSMX            Get MXLEN
       MOV  WA,MXLEN         Store as MXLEN
       BGT  XR,WA,INI06      Skip if static hi exceeds MXLEN
       MOV  WA,XR            Use MXLEN instead
       ICA  XR               Make bigger than MXLEN
*
*      Here to store values which mark initial division
*      of data area into static and dynamic
*
INI06  MOV  XR,DNAMB         Dynamic base adrs
       MOV  XR,DNAMP         Dynamic ptr
       BNZ  WA,INI07         Skip if non-zero MXLEN
       DCA  XR               Point a word in front
       MOV  XR,MXLEN         Store as MXLEN
*
*      Loop here if necessary till enough memory obtained
*      so that DNAME is above DNAMB
*
INI07  MOV  XL,DNAME         Store dynamic end address
       BLT  DNAMB,XL,INI09   Skip if high enough
       JSR  SYSMM            Request more memory
       ADD  XR,XL            Bump by amount obtained
       BNZ  XR,INI07         Try again
       MOV  =ENDMO,XR        Point to failure message
       MOV  ENDML,WA         Message length
       JSR  SYSPR            Print it (PRTST not yet usable)
       PPM                   Should not fail
       JSR  SYSEJ            Pack up (STOPR not yet usable)
       EJC
*
*      INITIALIZE STRUCTURES AT START OF STATIC REGION
*
INI09  MOV  STATB,XR         POINT TO STATIC AGAIN
       JSR  INSTA            INITIALIZE STATIC
*
*      Initialise hash headers in symbol table
*
       MOV  XR,HSHTB         Ptr to symbol table start
       MOV  =E$HNB,WC        Get number of hash headers
       MTI  WC               Convert to integer
       STI  HSHNB            Store for use in SYMTS
       LCT  WC,WC            Prepare count of hash headers
*
*      Loop to clear hash tables
*
INI11  ZER  (XR)+            Blank a word
       BCT  WC,INI11         Loop
       MOV  XR,HSHTE         Ptr past end of symbol table
*
*      Allocate buffer for GTSTG
*
       MOV  =NSTMX,WA        Get max num chars in output number
       CTB  WA,SCSI$         No of BAUS needed
       MOV  XR,GTSWK         Store bfr adrs
       ADD  WA,XR            Bump for work bfr
       MOV  XR,STATE         Current end address for static
       EJC
*
*      Now load up the global symbol table with all the reserved
*      word WDBLKs
*
       MOV  =YYYYY,WA        Last workarea address
       ICA  WA               Point past it to first WDBLK
       MOV  WA,XL            Get a copy
       ADD  *WDSOF,XL        Point to pseudo SCBLK for name
*
*      Loop here to process all reserved words
*
INI12  MOV  XL,XR            Copy string ptr into right reg.
       JSR  SYMTS            Insert entry in global table
       MOV  WDNML(XR),WB     XR is WDBLK ptr. Get name length
       CTB  WB,WDCHS         Length of block in BAUs
       ADD  WB,WA            Bump to next WDBLK
       ADD  WB,XL            Bump to next name
       MOV  WA,XR            For indexing first word
       BNZ  (XR),INI12       Zero word marks end of WDBLKs
       EJC
*
*      Check for expiry date
*
INI13  JSR  SYSDC            Call date check
       MOV  XS,FLPTR         In case stack overflows in compiler
*
*      Set up LALR parse tables
*
       MOV  *SNSI$,WA        comput size of symno map
       ADD  *RUSI$,WA          rhs
       ADD  *CKSI$,WA          check table
       ADD  *RUSI$,WA          lhs
       ADD  *ACSI$,WA          and action table combined
       MOV  WA,WB
       ZER  XL               JVK in case gbcol
       JSR  ALLOC            make room in dynamic region
       MOV  XR,R$SNM         first part is symno map
       MOV  WB,WA            recover size
       BTW  WA                 in words
       JSR  SYSPT            copy parse tables
       MOV  =B$SNM,(XR)      symno block type
       ADD  *SNSI$,XR        get start of RHS
       MOV  XR,R$RHS
       MOV  =B$RUL,(XR)        and set type
       ADD  *RUSI$,XR        get start of check map
       MOV  XR,R$CHK
       MOV  =B$CHK,(XR)
       ADD  *CKSI$,XR        then start of LHS
       MOV  XR,R$LHS
       MOV  =B$RUL,(XR)
       ADD  *RUSI$,XR        to start of action map
       MOV  XR,R$ACT
       MOV  =B$ACT,(XR)
*
*      Set up for init compile stage
*
       MOV  =STGIC,STAGE     Set stage marker
       ADD  =PRCNC,PRCNO      Start with main prog
*
*      Now compile source input code - JVK.  Not use B$ACP
*
       JSR  CMPIL            JVK - call compiler
*
       ZER  R$TTL            Forget title
       ZER  R$STL              and subtitle
       ZER  R$ACT            and parse action tables
       ZER  R$CHK
       ZER  R$LHS            and parser lhs & rhs tables
       ZER  R$RHS
       ZER  R$SNM            and sym no map
       ZER  R$SRP            and reduce save ptr
       ZER  R$LBV            and label table
       ZER  R$CIM            Forget compiler input image
       ZER  R$CCB              and code construct block
       MOV  R$PVB,XR         point to PVBLK chain
*
*      Loop through, unsetting PVVAL fields, to make
*      PCBLKs recoverable.
*
INI14  BZE  XR,INI15         jump if end of chain
       ZER  PVVAL(XR)        clear one
       MOV  (XR),XR          link is in word 0
       BRN  INI14
INI15  ZER  XL               Clear dud value
       ZER  WB               dont shift static
.IF    .CSED
       ZER  DNAMS            Clear sediment too
       JSR  GBCOL            Clear garbage left from compile
       MOV  XR,DNAMS         Record new sediment size
.ELSE
       JSR  GBCOL            Clear garbage left from compile
.FI
*
       BNZ  CPSTS,INIX0      Skip if no listing of comp stats
       JSR  PRTNL            JVK subst
*      JSR  PRTPG            Eject page
*
*      Print compile statistics
*
       MOV  DNAMP,WA         Next available loc
       SUB  STATB,WA         Minus start
       BTW  WA               Convert to words
       MTI  WA               Convert to integer
       MOV  =ENCM1,XR        Point to /memory used (words)/
       JSR  PRTMI            Print message
       MOV  DNAME,WA         End of memory
       SUB  DNAMP,WA         Minus next available loc
       BTW  WA               Convert to words
       MTI  WA               Convert to integer
       MOV  =ENCM2,XR        Point to /memory available (words)/
       JSR  PRTMI            Print line
       MTI  CMERC            Get count of errors as integer
       MOV  =ENCM3,XR        Point to /compile errors/
       JSR  PRTMI            Print it
       MTI  GBCNT            Garbage collection count
       MOV  =STPM5,XR        Point to /storage regenerations/
       JSR  PRTMI            Print GBCOL count
       JSR  SYSTM            Get time
       SBI  TIMSX            Get compilation time
       MOV  =ENCM4,XR        Point to compilation time (msec)/
       JSR  PRTMI            Print message
       ADD  =NUM05,LSTLC     Bump line count
       EJC
*
*      Prepare now to start execution
*
INIX0  BNZ  ININX,INIX2      Jump if execution supressed
*
*      Reset timer
*
.IF    .CNPF
       JSR  SYSTM            Get time again
       STI  TIMSX            Store for end run processing
.ELSE
*
*      Allocate space for the PFBLK to hold the profile
*      counts, and initialise it and a few other relevant
*      things.
*
       ICV  PFNBB            allow for reference to 0th block
       MTI  PFNBB            get nr of blocks as integer
       MLI  PFSTE            mult by entry size
       MFI  WA               get back address-style
       ICV  WA               allow for type word
       WTB  WA               convert to bytes
       JSR  ALOST            get space in static
       MOV  =B$PFC,(XR)+     set type word
       MOV  XR,PFTBL         copy adr of table origin
       BTW  WA               get nr of words back
       LCT  WA,WA            prepare to scan table
INI16  ZER  (XR)+            zero the table
       BCT  WA,INI16         all of it now
       ZER  PFBBN            set 1st block nr to profile
       JSR  SYSTM            get time started
       STI  PFSTM            stash it
.FI
       ZER  GBCNT            Initialise collect count
       JSR  SYSBX            Call before starting execution
       JSR  PRTNL            JVK-subst
*      JSR  PRTPG            Eject printer
*
*      Merge when listing file set for execution
*
INIY0  ZER  -(XS)            Set failure location on stack
       MOV  XS,FLPTR         Save ptr to failure offset word
       MOV  R$COD,XR         Load ptr to entry code block
       MOV  =STGXT,STAGE     Set STAGE for execute time
       ICV  KVSTC            Start counting statements
       BRI  (XR)             Start xeq with first statement
*
*      Here if execution is suppressed
*
INIX2  JSR  PRTNL            Print a blank line
       MOV  =ENCM5,XR        Point to /execution suppressed/
       JSR  PRTST            Print string
       JSR  PRTNL            Output line
       ZER  WA               Clear ABEND code
       MOV  =NINI9,WB        Special code for exec suppressed
       ZER  XL               No FCB chain
       JSR  SYSEJ
       ENP                   END PROCEDURE START
*
*      HERE FROM OSINT TO RESTART A SAVE FILE OR LOAD MODULE.
*
RSTRT  PRC  E,0              ENTRY POINT
       MOV  STBAS,XS         DISCARD RETURN
       ZER  XL
       BRN  INIY0            RESUME EXECUTION
       ENP
       EJC
*
       TTL  S E T L - S -- SETL OPERATOR ROUTINES
*
*      This section includes all routines which can be accessed
*      directly from the generated code except system functions.
*
*      These entry points may usefully be considered as the
*      opcodes of a Setl-s abstract machine.  They are grouped
*      loosely by function with the operations corresponding
*      to the Setl language operators at the end.
*
*      Routines called from the code to perform internal
*      operations
*
*
*      JFCLR -- jump on false and clear
*
*      Used inside arith loops to clear up temps on exit
*
JFCLR  ENT
       MOV  (XS)+,XR
       BEQ  XR,=FALSE,JFCL1
       ICP
       BRN  EXITS
JFCL1  ADD  *NUM03,XS
       BRN  EXITS
       EJC
*
*      JMPNO -- jump if not omega
*
*      (XS)                   left operand value
*      Used for ? operator
*
JMPNO  ENT
       MOV  (XS),XR           retrieve left oper
       BNE  XR,=OMEGA,JNOM1   if not omega, take label
       ICP                    if omega, skip label, exec rhs
       ICA  XS                and discard lhs
JNOM1  BRN  EXITS
*
*      JUMPF -- jump on false
*
*      (CP)                  ptr to ptr to destination
*      1(CP)                  next codeword
*
JUMPF  ENT
       MOV  (XS)+,XR          get Boolean value
       BEQ  XR,=FALSE,EXITS  jump if false
       ICP                   else skip
       BRN  EXITS
*
*      JUMPT -- jump on true
*
*      (CP)                  ptr to ptr to destination
*      1(CP)                  next codeword
*
JUMPT  ENT
       MOV  (XS)+,XR          get Boolean value
       BEQ  XR,=TRUE$,EXITS   jump if true
       ICP                   else skip
       BRN  EXITS
       EJC
*
*      JUMPN -- jump if next element not there
*
*      (XS)                  Iterator variable
*      1(XS)                  Iterator domain value
*      (CP)                  Jump dest. if no next element
*      1(CP)                  Next codeword
*
JUMPN  ENT
JMPN0  MOV  OFFS1(XS),XR         get value
       BEQ  (XR),=B$PRL,JMPN2 jump with pair
       BEQ  (XR),=B$TPL,JMPN1 jump with tuple
       BEQ  (XR),=B$SCL,JMPN5
*
*
*      Otherwise, it must be a set-like object
*
       MOV  (XS),XL          get offset thing
       JSR  NEXTS            call for next element
       BNZ  WB,JMPNX         jump if last
       MOV  XL,(XS)          update stacked version
       BEQ  XR,=OMEGA,JMPN0  not interested in OM
       ICP                   skip past fail pointer
       BRN  EXIXR
*
*      Here for next from a tuple
*
JMPN1  MOV  (XS),WA          get offset
       JSR  TPELT            call for tuple element
       PPM  JMPNX            next codeword if exhausted
JMPN4  ICP                   else skip
       ICV  (XS)             bump offset for next time
       BRN  EXIXR            and carry on
       EJC
*
*      Here with a PRBLK
*
JMPN2  BGT  (XS),=NUM02,JMPNX next codeword if through
       MOV  (XS),WA
       WTB  WA
       ADD  WA,XR            else add offset
       MOV  (XR),XR          load element
       BRN  JMPN4            merge back to continue
*
*      Here with SCBLK
*
JMPN5  BGE  (XS),SCLEN(XR),JMPNX jump if finished
       PLC  XR,(XS)          prepare to load next char
       LCH  WB,(XR)          load it
       MOV  =NUM01,WA
       JSR  ALOCS            allocate single character string
       MOV  XR,XL            copy pointer
       PSC  XL
       SCH  WB,(XL)          store the character
       CSC  XL
       BRN  JMPN4
*
*      Here if fail -- pop iterator temps bfore jumping
*
JMPNX  ADD  *NUM02,XS
       BRN  EXITS
*
*      JMPNM -- jump if next domain element not there
*
*      1(XS)                 Original map or tuple
*      (XS)                  Iterator variable
*      (CP)                  Jump dest. if no next element
*      1(CP)                 Next codeword
*      Result:  Maps:  Push map, then next domain elt
*               Tuples, etc.:  Push orig, then icblk for iter index
*      Note:  For maps, we use only one entry per domain elt
*      (i.e. per pair chain)
*
JMPNM  ENT
JPNM0  MOV  OFFS1(XS),XR         get orig source
       BEQ  (XR),=B$PRL,JPNM3 jump with pair
       BEQ  (XR),=B$TPL,JPNM1 jump with tuple
       BEQ  (XR),=B$SCL,JPNM5
*
*      Here it must be a map
*
       MOV  (XS),XL          get offset thing
       ICA  (XS)             update iter to next dom elt
       JSR  NEXTS            call for next element
       BNZ  WB,JPNMX         jump if last
       BEQ  XR,=OMEGA,JPNM0  not interested in OM
       ICP                   skip past fail pointer
       MOV  PRDOM(XR),XR     get domain elt from pair
       MOV  OFFS1(XS),XL
       MOV  XL,-(XS)         push orig map again
       BRN  EXIXR            then push dom elt
*
*      Here for next from a tuple
*
JPNM1  BGT  (XS),TPNEL(XR),JPNMX get offset, check if done
JPNM2  LDI  (XS)
       ICV  (XS)             bump offset for next time
       MOV  XR,-(XS)         push tuple again
       ICP                   skip label
       BRN  EXINT            create ICBLK for offset
       EJC
*
*      Here with a PRBLK
*
JPNM3  MOV  (XS),WA          get offset
       BGT  WA,=NUM02,JPNMX  check if done
       BRN  JPNM2            merge back
*
*      Here with SCBLK
*
JPNM5  MOV  (XS),WA          get offset
       BGT  WA,SCLEN(XR),JPNMX jump if finished
       BRN  JPNM2            merge back
*
*      Here if fail -- pop iterator temps before jumping
*
JPNMX  ADD  *NUM02,XS
       BRN  EXITS
*
*      JMPNC -- jump if no next elt in compd oper
*
*      (XS)                  accumulator
*      1(XS)                 iterator
*      2(XS)                 iterator domain
*      (CP)                  jump dest if no next value
*
JMPNC  ENT
JMNC0  MOV  OFFS2(XS),XR         get value
       BEQ  (XR),=B$PRL,JMNC2 jump with pair
       BEQ  (XR),=B$TPL,JMNC1 jump with tuple
       BNE  (XR),=B$SCL,JMNC3 jump if set or map
       ERB  152,illegal operand for compound oper
*
*      Here for a set-like object
*
JMNC3  MOV  OFFS1(XS),XL     get offset thing
       JSR  NEXTS            call for next element
       BNZ  WB,JMNCX         jump if last
       MOV  XL,OFFS1(XS)     update iterator
       BEQ  XR,=OMEGA,JMNC0  not interested in OM
       ICP                   skip past fail pointer
       BRN  EXIXR
*
*      Here for next from a tuple
*
JMNC1  MOV  OFFS1(XS),WA     get offset
       JSR  TPELT            call for tuple element
       PPM  JMNCX            next codeword if exhausted
JMNC4  ICP                   else skip
       ICV  OFFS1(XS)        bump offset for next time
       BRN  EXIXR            and carry on
       EJC
*
*      Here with a PRBLK
*
JMNC2  BGT  OFFS1(XS),=NUM02,JMNCX next codeword if through
       MOV  OFFS1(XS),WA
       WTB  WA
       ADD  WA,XR            else add offset
       MOV  (XR),XR          load element
       BRN  JMNC4            merge back to continue
*
*      Here if fail -- pop iterator temps before jumping
*
JMNCX  MOV  (XS)+,XR
       ADD  *NUM02,XS
       BRN  EXIXR
*
*      OPCOP -- copy
*
*      Inserted before simple assignments which would
*      otherwise lead to shared pointers
*
OPCOP  ENT
       MOV  (XS)+,XR         load srgument
       JSR  COPYV            copy value
       MOV  XL,XR            we want the copy
       BRN  EXIXR
*
*      Operator routines called directly from code
*
OPEND  ENT
       MOV  =ENDMS,XR
       BRN  STOPR
*
*
*      OPPAS -- pass
*
*      This is a no-op for the SETL PASS statement
*
OPPAS  ENT
       BRN  EXITS            next codeword
       EJC
*
.IF    .CNPF
.ELSE
*
*      /PROFILE/ pseudo-op, called at the end of each
*      basic block.
*
OPPFL  ENT
       LCW  XR               load nr of block exiting
       MTI  XR               into integer accumulator
       MLI  PFSTE            make table entry offset
       MFI  XR               convert to address
       ADD  PFTBL,XR         add table origin
       LDI  (XR)             load count of executions so far
       ADI  INTV1            bump by one
       STI  (XR)             and put it back
       JSR  SYSTM            get current time
       STI  PFETM            end time - save for a sec
       SBI  PFSTM            make time used this block
       ADI  CFP$I(XR)        add previous block total
       STI  CFP$I(XR)        and put back new total
       LDI  PFETM            re-load saved end time
       STI  PFSTM            stash as start of next block
       BRN  EXITS            continue executing code
.FI
*
OPPOP  ENT
       ICA  XS
       BRN  EXITS
*
OPPP2  ENT
       ADD  *NUM02,XS
       BRN  EXITS
*
       EJC
*
OPSTM  ENT
       ICV  KVSTC            count it
       ICV  KVSTN            increment statement number
       BRN  EXITS
*
*      RETURN a value from a procedure
*
*      OPRTN resets locals and arguments to their pre-entry
*      values, cleans up the stack, and leaves the result.
*
*      It picks up the link from the stack, and resumes
*      calling code.
*      See B$PCC for details of stacked values
*
OPRTN  ENT
       MOV  (XS)+,RTRSL      save result
       MOV  (XS)+,RTPCB      unstack PCBLK
       MOV  (XS)+,R$COD      restore CDBLK pointer
       MOV  (XS)+,WA         this was CP offset
       ADD  R$COD,WA         make absolute
       LCP  WA               and reset code pointer
       MOV  (XS)+,RTXSB      old stack pointer
       MOV  (XS)+,WB         number of args supplied
       MOV  (XS)+,KVSTN      restore stmt number
       ICV  KVSTC              and count return
*
*      Loop to restore args and locals
*
       MOV  RTPCB,XR         point to PCBLK
       MOV  PCLOC(XR),RTSLC  pointer past locals
       MOV  PCARG(XR),XR     point to first argument
       MOV  RTXSB,XT         point to first stacked value
RTN01  BEQ  XR,RTSLC,RTN02   jump if done
       MOV  -(XT),VRVAL(XR)  reset a value
       JSR  NXTVR            point to next VRBLK
       BRN  RTN01
*
*      Check for zero-level exit
*
RTN02  MOV  RTPCB,XR         JVK-get PCBLK again
       BNE  PCSAV(XR),RTXSB,RTN03 check save area not here
       ZER  PCSAV(XR)        clear if it was
*
*      Clean up stack
*
RTN03  MOV  RTXSB,XS         point past arg values
       WTB  WB               JVK-offset
       ADD  WB,XS            point before them
       MOV  RTRSL,-(XS)      stack result
       BRN  EXITS            return to caller
       EJC
*
OPSTR  ENT
       MOV  (XS)+,XR
       JSR  STRGV
       BRN  EXIXR
       EJC
*
*      PRMIT -- prepare map (or tuple) iterator variable
*
*      Prepares a variable to control iteration through the
*      argument at (XS), such as a = m(b) - see prpit
*
PRMIT  ENT
       MOV  (XS),XR          load argument
       BEQ  (XR),=B$PRL,PRM10
       BEQ  (XR),=B$STL,PRM20
       BEQ  (XR),=B$MPL,PRM25
       BEQ  (XR),=B$TPL,PRM10
       BEQ  (XR),=B$SCL,PRM10 string
PRM00  ERB  153,illegal type for iterator variable
*
*      Here for tuples, pairs, and strings
*
PRM10  MOV  =NUM01,-(XS)     start at index 1
       BRN  EXITS
*
*      Here for set, must be a map
*
PRM20  JSR  CHKMP
       PPM  PRM25            if okay, merge with map
       BRN  PRM00            else error
*
*      Here for a map
*
PRM25  MOV  *STSI$,-(XS)     initial value
       BRN  EXITS
       EJC
*
*      PRPCM -- prepare unary compound operator
*
*      Prepares for iteration of compound operator over the
*      argument at (XS).  See PRPIT for forms of the iterator.
*      Results:  2(XS)    orig argument
*                1(XS)    iterator
*                (XS)     accumulator
*
PRPCM  ENT
       MOV  (XS),XR          load argument
       BEQ  (XR),=B$PRL,PRPC1
       BEQ  (XR),=B$TPL,PRPC2
       BEQ  (XR),=B$STL,PRPC4
       BEQ  (XR),=B$MPL,PRPC4
       ERB  151,illegal operand for compound oper
*
*      Here for pair
*
PRPC1  MOV  =NUM02,-(XS)     init iterator after 1st
       MOV  PRDOM(XR),-(XS)  get 1st elt
       BRN  EXITS
*
*      Here for tuple
*
PRPC2  BNZ  TPNEL(XR),PRPC3
       MOV  =NUM01,-(XS)     here if null tuple
       MOV  =OMEGA,-(XS)     return omega
       BRN  EXITS
*
PRPC3  MOV  =NUM02,-(XS)     init iter past 1st
       MOV  =NUM01,WA        get 1st elt
       JSR  TPELT
       PPM
       MOV  XR,-(XS)         and init accumulator
       BRN  EXITS
*
*      Here for set-like objects
*
PRPC4  BNZ  STNEL(XR),PRPC5
       MOV  *STSI$,-(XS)     here if null set
       MOV  =OMEGA,-(XS)     return omega
       BRN  EXITS
*
PRPC5  MOV  *STSI$,XL
PRPC6  MOV  (XS),XR
       JSR  NEXTS            retrieve 1st elt
       BEQ  XR,=OMEGA,PRPC6  loop past omegas
       MOV  XL,-(XS)         store updated iterator
       MOV  XR,-(XS)         place 1st elt in accumulator
       BRN  EXITS
       EJC
*
*      PRPIT -- prepare iterator variable
*
*      Prepares a variable to control iteration through the
*      argument at (XS)
*      Possibilities are -
*      Tuple - iterator is simple offset, initialised to 1
*
*      A copy of the argument is made to allow for the
*      possibility of the original being modified
*
PRPIT  ENT
       MOV  (XS),XR          load argument
       BEQ  (XR),=B$PRL,PRP10
       BEQ  (XR),=B$STL,PRP20
       BEQ  (XR),=B$MPL,PRP20
       BEQ  (XR),=B$TPL,PRP10
       BEQ  (XR),=B$SCL,PRP30 string
*
       ERB  180,inaapropriate type of object for iterator
*
PRP10  MOV  =NUM01,-(XS)     push iterator vble
       BRN  EXITS
*
*      Here for a set-like object
*
PRP20  MOV  *STSI$,-(XS)     initial value
       BRN  EXITS
*
*      String needs offset starting at 0
*
PRP30  ZER  -(XS)
       BRN  EXITS
       EJC
*
*      RVNEG -- reverse if negative
*
*      This operation pops the top stack item, and if it
*      is negative, swaps the next two stack items.  This
*      is used in compiling arithmetic loops, since it is
*      not known at compile-time whether the loop is going
*      forwards or backwards, and hence whether the test
*      should be a greater or less than one. By using
*      REVNEG to test the step, we need only compile one
*      test.
*
RVNEG  ENT
       MOV  (XS)+,XR         pop item to test
       LDI  ICVAL(XR)        load value
       IGT  EXITS            no-op unless negative or 0
       IEQ  RVNG1            trap 0 step
*
*      If neg, swap top two stack items
*
       MOV  (XS)+,WA
       MOV  (XS)+,WB
       MOV  WA,-(XS)
       MOV  WB,-(XS)
       BRN  EXITS
*
*      If 0 step, force loop termination
*
RVNG1  ICA  XS               discard lim
       ICA  XS                 and ctr
       MOV  =INTON,-(XS)     set ctr = 1
       MOV  =INT$R,-(XS)       and limit = 0
       BRN  EXITS            to force terminate
       EJC
*
*      Routines to load stack temporaries
*
*      STKLn loads the value, on entry, at n(XS), pushing the
*      stack.  We use XR as intermediate register because of a
*      possible ambiguity in instructions which address XS in
*      both operands, and also increment/decrement it
*
STKL0  ENT
       MOV  (XS),XR
       BRN  EXIXR
*
STKL1  ENT
       MOV  OFFS1(XS),XR
       BRN  EXIXR
*
STKL2  ENT
       MOV  OFFS2(XS),XR
       BRN  EXIXR
*
STKL3  ENT
       MOV  OFFS3(XS),XR
       BRN  EXIXR
*
*      General case - offset is in next codeword
*
STKLN  ENT
       LCW  XR               JVK-repair for translator
       MOV  XR,XT
       WTB  XT                   need byte offset
       ADD  XS,XT
       MOV  (XT),XR
       BRN  EXIXR
       EJC
*
*      Routines to store stack temporaries
*
*      STKSn pops the stack into XR, and then stores the value
*      in XR to n(XS), using the new value of XS
*
STKS0  ENT
       MOV  (XS)+,XR
       MOV  XR,(XS)
       BRN  EXITS
*
STKS1  ENT
       MOV  (XS)+,XR
       MOV  XR,OFFS1(XS)
       BRN  EXITS
*
STKS2  ENT
       MOV  (XS)+,XR
       MOV  XR,OFFS2(XS)
       BRN  EXITS
*
*      General case - offset is in next codeword
*
STKSN  ENT
       LCW  XR               JVK-repair for translator
       MOV  XR,XT
       WTB  XT                   need byte offset
       MOV  (XS)+,XR
       ADD  XS,XT
       MOV  XR,(XT)
       BRN  EXITS
       EJC
*
*      SETFM -- form a set
*
*      SETFM is called from the compiled code to form
*      a set from enumerated elements.  On entry, the
*      elements are on the stack, with the number of elements
*      in the next codeword
*
SETFM  ENT
       LCW  XR
       MOV  XR,WA            get number of elements
       JSR  FMSET            call routine to form set
       BRN  EXIXR
*
*      TPLFM -- form a tuple
*
*      This routine is called to form a tuple from enumerated
*      elements.  On entry, the elements are on the stack at
*      1(XS) onwards.
*      (XS)                  Required cardinality
*
TPLFM  ENT
       LCW  XR               get cardinality from codeword
       MOV  XR,WA            copy it
       JSR  FMTPL
       BRN  EXIXR
       EJC
*
       TTL  SETL-S           operator application routines
*
*      These routines are enterd via the O$XXX blocks to
*      perform type checking and select an operator evaluation
*      routine - they continue by entering that routine.
*
*      (XR)                  ptr to operator block (O$XXX label)
*
*
       EJC
*
*      APPL1 -- apply a monadic operator
*
*      The operator block has a vector of routine entry points
*      On exit merges to APPLY to select the correct one
*
APPL1  ENT
       MOV  (XS),XL          load operand
       BRN  APPLY
       EJC
*
*      APPL2 -- apply a dyadic operator
*
*      The operator block has a vector of routine entry points.
*      On exit, merges to APPLY to select the correct one,
*      according to the type of the LEFT operand (at 1(XS))
*
APPL2  ENT
       MOV  OFFS1(XS),XL     load left operand
       BRN  APPLY
       EJC
*
*      APPL3 -- apply operator with three operands JVK
*
*      As above, uses a vector of routine entry points.
*      In case of O$SBA store into subscripted var, three
*      operands are needed.  Select the item to store into
*      and merge to APPLY
*
APPL3  ENT
       MOV  OFFS2(XS),XL     load subscripted item
       BRN  APPLY
*
*      APPL4 -- apply operator with four operands JVK
*
*      As in prior cases, uses a vector of routine entry points.
*      In case of O$SLA store into a slice, four operands are
*      needed.  Select the item to store into and merge to APPLY
*
APPL4  ENT
       MOV  OFFS3(XS),XL     load sliced item
       BRN  APPLY
       EJC
*
*      APPX1 -- apply a dyadic operator
*
*      The operator block has the legitimate type code,
*      the operator routine address, and an error routine
*      address
*
*      On exit merges to APPX to do the checking.
*
APPX1  ENT
       MOV  (XS),XL          load operand
       BRN  APPLX
       EJC
*
*      APPX2 -- apply a dyadic operator
*
*      As APPX2, but checked on LEFT operand (expand)
*
APPX2  ENT
       MOV  OFFS1(XS),XL     load left operand
       BRN  APPLX
       EJC
       EJC
*
       TTL  SETL-S operator routines
*       The first two letters of the labels in this section
*      are the two letter block codes for the type of the
*      operand (first operand for dyadic operators). The
*      three remaining letters are a code for the operator.
*      Exception - in a few cases the final letter has been
*      replaced by $ to avoid name clashes.
*
*      The operator jump vectors contain pointers to these
*      entry points, which are actually entered from APPxx.
*
*
*      The entries are arranged in alphabetical order of
*      code.
       EJC
*
*      ABS operator entered via APPL1 s
*
*      error cases
*
ERABS  ENT
       ERB  080,illegal or undefined operand type for ABS
*
*      Integer - return magnitude
*
ICABS  ENT
       LDI  ICVAL(XR)        Get integer value
       IGE  EXINT            Striaght out if non-negative
       NGI                   else negate it
       INO  EXINT            and exit with integer value
       BRN  EXIOV            overflow possible for 2s compl
*
.IF    .CNRA
*
*      Real -- return magnitude
.ELSE
RCABS  ENT
       LDR  RCVAL(XR)
       RGE  EXREA
       NGR
       BRN  EXREA
.FI
*
*      String - ABS operator is legal if the string is a
*      single character - return integer value of code
*
SCABS  ENT
       BNE  SCLEN(XR),=NUM01,SCAB1 check length
       PLC  XR
       LCH  XR,(XR)
       MTI  XR
       BRN  EXINT
*
SCAB1  ERB  198,ABS applied to string of length greater than 1
       EJC
*
*      ARB operator -- entered via APPL1
*
*      Error case
*
ERARB  ENT
       ERB  081,illegal or undefined operand type for ARB
*
*      Map or set - return arbitrary element
*
MSARB  ENT
       EJC
       MOV  XR,-(XS)
       MOV  *STSI$,XL        choose first
MSAB1  JSR  NEXTS            fetch an element
       BNZ  WB,MSAB3         might not be any
       BNE  XR,=OMEGA,MSAB2
       MOV  (XS),XR          dont want OMs
       BRN  MSAB1
MSAB2  MOV  XR,(XS)          leave on stack
       BRN  EXITS
MSAB3  ICA  XS               pop off set
       BRN  EXIOM            result is OM
       EJC
*
*      CHAR -- entered via APPX1
*
ERCHR  ENT
       ERB  100,illegal or undefined operand type for CHAR
*
*      Integer - returns char string for given code
*      Use mod of Spitbol routine
*
ICCHR  ENT
       LDI  ICVAL(XR)        load int value
       MFI  WC,ICHR9         move as word, jump if overflow
       BGT  WC,MXLEN,ICHR9     or if too small
       BGE  WC,=CFP$A,ICHR9  see if out of range of host set
       MOV  =NUM01,WA        if not set scblk allocation
       MOV  WC,WB            save char code
       JSR  ALOCS            allocate 1 bau scblk
       MOV  XR,XL            copy scblk pointer
       PSC  XL               get set to stuff char
       SCH  WB,(XL)+         stuff it
       ZER  XL
       BRN  EXIXR
*
*      Here if char argument not in range
*
ICHR9  ERB  101,CHAR argument not in range
       EJC
*
*      DIV -- entered via APPL2
*
*      Error cases
*
ERDIV  ENT
       BRN  XEDIV
*
.IF .CNRA
.ELSE
*      Integer - form real quotient
*
ICDIV  ENT
       MOV  (XS)+,XL         load integer dividend
       BNE  (XR),=B$RCL,ICDI1 jump unless real divisor
       LDI  ICVAL(XL)        load int value
       ITR                   float it
       DVR  RCVAL(XR)        perfrom division
       RNO  EXREA
       BRN  EXROV
*
ICDI1  BNE  (XR),=B$ICL,XEDVI error exit if not int
       LDI  ICVAL(XR)
       ITR
       STR  DIVSV            save dividend
       LDI  ICVAL(XL)        now load left value
       ITR
       DVR  DIVSV            perfrom division
       RNO  EXREA
       BRN  EXROV
       EJC
.FI
.IF    .CNRA
.ELSE
*
*      Real - perfrom division, floating an integer
*      divisor if necessary
*
RCDIV  ENT
       MOV  (XS)+,XL         unstack dividend
       BNE  (XR),=B$RCL,RCDI1
       LDR  RCVAL(XL)
       DVR  RCVAL(XR)
       RNO  EXREA
       BRN  EXROV
*
RCDI1  BNE  (XR),=B$ICL,XEDVI this is an error
       LDI  ICVAL(XR)        load divisor
       ITR
       STR  DIVSV            save real value
       LDR  RCVAL(XL)
       DVR  DIVSV
       RNO  EXREA
       BRN  EXROV
       EJC
.FI
*
*      DOMAIN -- return domain set of a map
*
*      Entered via APPL1 but a further check is required to
*      see whether an object which is ostensibly a set in
*      fact contains only pairs.
*      Merge with RANGE to perform the actual operation.
*
*      Error case
*
ERDOM  ENT
       BRN  XEDMR
*
*      Map/set - form domain if actually a map
*
MSDOM  ENT
       MNZ  RNGDM
       BRN  EXRND
*
*      DVI (integer division) -- entered via APPX2
*
*      Error case
ERDVI  ENT
       BRN  XEDVI
       EJC
*
*      Integer -- perfrom integer division, no fixing
*      of real divisor allowed
*
ICDVI  ENT
       MOV  (XS)+,XL
       BNE  (XR),=B$ICL,XEDVI error non-integer
       LDI  ICVAL(XL)
       DVI  ICVAL(XR)
       INO  EXINT
       BRN  EXIOV
       EJC
*
*      EQUALS operator -- entered via APPL2
*
*      This operator can be applied to operands of all
*      types - even OM
*
*      Integer
*
ICEQL  ENT
       MOV  (XS)+,XL         get left operand
       BNE  (XR),=B$ICL,EXFAL FALSE if right not integer
       JSR  ICCMP            compare the values
       PPM  EXFAL            L less than R
       PPM  EXTRU            L = R
       PPM  EXFAL
*
*      Maps and sets - these can be equal to each other
*      since it is possible fro a set to contain only pairs
*      without knowing about it
*
MSEQL  ENT
       MOV  (XS)+,XL
       BEQ  (XR),=B$STL,MSEQ1 jump with set
       BNE  (XR),=B$MPL,EXFAL fail unless map
*
*      Here both operands are either sets or maps -
*      any combination might still give equality
*
MSEQ1  JSR  STCMP
       PPM  EXTRU
       PPM  EXFAL
       EJC
*
*      Pairs - have to check other operand for tuple
*      of length 2
*
PREQL  ENT
       MOV  (XS)+,XL
       BEQ  (XR),=B$PRL,PREQ1
       BNE  (XR),=B$TPL,EXFAL
       BNE  STNEL(XR),=NUM02,EXFAL
       JSR  TUPPR
PREQ1  JSR  PRCMP
       PPM  EXTRU
       PPM  EXFAL
       EJC
.IF    .CNRA
.ELSE
*
*      Reals
*
RCEQL  ENT
       MOV  (XS)+,XL
       BNE  (XR),=B$RCL,EXFAL
       JSR  RCCMP
       PPM  EXFAL
       PPM  EXTRU
       PPM  EXFAL
.FI
*
*      Strings
*
SCEQL  ENT
       MOV  (XS)+,XL         load string 1
       BNE  (XR),=B$SCL,EXFAL false if non string
       JSR  LCOMP
       PPM  EXFAL
       PPM  EXTRU
       PPM  EXFAL
*
*      Tuples - must check right operand for pair
*
TPEQL  ENT
       BEQ  (XR),=B$TPL,TPEQ1 jump if both TPBLKs
       BEQ  (XR),=B$PRL,TPEQ2 jump if other PRBLK
       ICA  XS               fails
       BRN  EXFAL
TPEQ2  MOV  XR,XL
       JSR  PRTUP            convert pair
*
*      Merge to compare TPBLKs
*
TPEQ1  MOV  (XS)+,XL         recover left arg
       JSR  TPCMP            and compare
       PPM  EXTRU
       PPM  EXFAL
*
*      Other types - a simple equality test on addresses is
*      sufficient since they will be unique
*
VLEQL  ENT
       MOV  (XS)+,XL
       BEQ  XR,XL,EXTRU
       BRN  EXFAL
       EJC
*
*      EVEN operator -- entered via APPX1
*
EREVN  ENT
       ERB  040,operand of EVEN is not integer
*
*      Integer case, check last bit
*
ICEVN  ENT
       MOV  ICVAL(XR),WB
       MOV  BITS1,WA         set mask bit
       ANB  WB,WA            check right bit
       BZE  WA,EXTRU
       BRN  EXFAL
*
*      ** operator -- entered via APPL2
*      exponentiation
*
EREXP  ENT
       ERB  006,exponentiation not yet implemented
*
*      Integer exponentiation
*
ICEXP  ENT
       MOV  (XS)+,XL         get left operand
       BEQ  (XR),=B$ICL,ICE10  integer exponent
       ERB  021,non integer exponents not supported
*
*      Here for integer exponent
*
ICE10  LDI  ICVAL(XR)
       IGE  ICE11            check sign of exponent
       ERB  022,negative exponents not supported
*
*      Here positive or 0 integer exponent
*
ICE11  JSR  EXPIC            perform expon
       BRN  EXIXR
*
.IF    .CNRA
*
*      FIX and FLOAT are illegal
*
ERFIX  ENT
       ERB  112,cannot use FIX without real arithmetic
ERFLO  ENT
       ERB  113,cannot use FLOAT without real arithmetic
.ELSE
*
*      FIX operator -- entered via APPX1
*
ERFIX  ENT
       ERB  083,illegal or undefined operand type for FIX
*
*      Real - ok case
*
RCFIX  ENT
       LDR  RCVAL(XR)        load the real value
       RTI  RCFOV            FIX it
       INO  EXINT            exit with integer if no overflow
       BRN  EXIOV
*
RCFOV  ERB  157,overflow FIXing real operand
*
*      FLOAT operator -- entered via APPX1
*
*      Errors
*
ERFLO  ENT
       ERB  084,illegal or undefined operand type for FLOAT
*
*      Integer - ok
*
ICFLO  ENT
       LDI  ICVAL(XR)        load the integer value
       ITR                   FLOAT it
       BRN  EXREA
       EJC
.FI
*
*      FROMB operator -- entered via APPL2
*
*      Extract element from tuple/pair. In compiled
*      code this operator is followed by a store into
*      the left operand, then one into the right, in case
*      a pair becomes a tuple.
*
*      Errors
*
ERFRB  ENT
       ERB  124,non-tuple right argument for FROMB
*
PRFRB  ENT
       MOV  XR,-(XS)         save operand
       MOV  =NUM01,WA        nels of result
       JSR  ALOTS            allocate block for tuple
       MOV  =B$TPL,(XR)      set type word
       MOV  (XS)+,XL         JVK-recover pair
       MOV  XR,-(XS)         new value of right
       ADD  *TPSI$,XR        point to first slot
       MOV  PRRNG(XL),(XR)   place into tuple
       MOV  PRDOM(XL),XR     this is the result
       BRN  EXIXR
*
*      Extract from tuple
*
TPFRB  ENT
       MOV  XR,-(XS)         re-stack for re-assigning
       BZE  TPNEL(XR),EXIOM  gives OM if empty
       DCV  TPNEL(XR)        count extraction
       MOV  TPNEL(XR),WA     get length
       WTB  WA               JVK-convert to bytes PC
       ADD  *STSI$,XR        point to first element
       MOV  (XR),-(XS)       stack as result
       MOV  XR,XL            copy pointer
       ICA  XL               point to new first element
       MVW                   move lot up
       MOV  =OMEGA,(XR)      clear last entry
       BRN  EXITS
       EJC
*
*      FROME operator -- entered via APPL1
*
*      Extract element from end of pair/tuple
*      In compiled code, operator is followed by a store
*      into left operand, then one into right, in case a
*      pair becomes a tuple
*
*      Errors
*
ERFRE  ENT
       ERB  125,non-tuple operand for FROME
*
*      Pair - extract range, and reform into tuple
*
PRFRE  ENT
       MOV  XR,-(XS)         save PRBLK
       MOV  =NUM01,WA
       JSR  ALOTS
       MOV  =B$TPL,(XR)      tuple of length 1
       MOV  (XS)+,XL         JVK-recover pair
       MOV  XR,-(XS)         new right operand value
       ADD  *TPSI$,XR        point to first
       MOV  PRDOM(XL),(XR)   this one is left
       MOV  PRRNG(XL),XR     this is result
       BRN  EXIXR
*
*      Tuple - extract from end
*
TPFRE  ENT
       MOV  XR,-(XS)         re-stack for re-assignment
       BZE  TPNEL(XR),EXIOM  OM result if empty
*
*      ADTEL knows about fiddling cardinality of
*      tuples, so use it by assigning OM to last element
*
       MOV  XR,XL            copy tuple pointer
       MOV  TPNEL(XR),WA     load cardinality
       JSR  TPELT            fetch last element
       PPM
       MOV  XR,-(XS)         stack as result
       MOV  =OMEGA,XR
       JSR  ADTEL            assign OM to end
       BRN  EXITS
       EJC
*
*      FROM -- entered via APPL1
*      Single entry point for maps and sets
*      Extract an element from its operand (FROM right in
*      SETL source).  The compiled code follows this
*      operator by a store into the left operand.
*
*      Errors
*
ERFRM  ENT
       ERB  126,non-set operand for FROM
*
*      Map or set -- extract arbitrary element
*
*      Suggest ARB could be usefully recoded like this.
*
MSFRM  ENT
       BZE  STNEL(XR),EXIOM  if empty, return om
       MOV  XR,XL            copy block pointer
       MOV  STLEN(XR),WA     and load its length
       WTB  WA               JVK for byte addr
       ADD  WA,XR            point to end
       ADD  *STSI$,XL        point to first slot
MSFM0  BZE  (XL),MSFM1       jump with dead entry
       BEQ  (XL),=OMEGA,MSFM1 or OM
       BRN  MSFM2            jump with ok entry
MSFM1  ICA  XL               point to next
       BLT  XL,XR,MSFM0      loop if not off end
       BRN  EXIOM            OM if exhausted
*
*      Found something
*
MSFM2  SUB  WA,XR            point back to start of block
       DCV  STNEL(XR)        count removed element
       MOV  (XL),XR          point to item
       BEQ  (XR),=B$PRL,MSFM4 jump with pair
MSFM3  ZER  (XL)             delete entry
       BRN  EXIXR
*
*      Remove a pair
*
MSFM4  BLO  PRNXT(XR),DNAMB,MSFM3 jump if singleton
       MOV  PRNXT(XR),(XL)   unhook a pair
       BRN  EXIXR
       EJC
*
*      IS_ATOM operator -- entered directly, since legal
*      for any operand (including OM)
*
OPIAT  ENT
       MOV  (XS)+,XR        pop operand
       BEQ  (XR),=B$ATL,EXTRU
       BRN  EXFAL
*
*      IS_BOOLEAN operator -- entered directly for any operand
*
OPIBO  ENT
       MOV  (XS)+,XR        pop operand
       BEQ  (XR),=B$TVL,EXTRU
       BRN  EXFAL
*
*      IS_INTEGER operator -- entered directly for any operand
*
OPIIN  ENT
       MOV  (XS)+,XR        pop operand
       BEQ  (XR),=B$ICL,EXTRU
       BRN  EXFAL
*
*      IS_MAP operator -- entered directly for any operand
*
OPIMA  ENT
       MOV  (XS)+,XR        pop operand
       BEQ  (XR),=B$MPL,EXTRU     ok if map
       BNE  (XR),=B$STL,EXFAL     also check if set
       JSR  CHKMP           see if it is map
       PPM  EXTRU           ok
       BRN  EXFAL
*
*      INCS operator -- entered via APPL2
*      but a single entry point is common to sets
*      and maps
*
*      Errors
*
ERINC  ENT
       ERB  085,illegal or undefined operand type for INCS
*
*      Maps and sets
*
MSINC  ENT
       ZER  WA
       MOV  (XS)+,XL
       BEQ  (XR),=B$STL,STNC1
       BEQ  (XR),=B$MPL,STNC1
       ERB  141,right operand of INCS not a set
*
STNC1  JSR  STNCL            check inclusion
       PPM  EXTRU
       PPM  EXFAL
       EJC
*
*      IS_SET operator -- entered directly for any operand
*
OPISE  ENT
       MOV  (XS)+,XR         pop operand
       BEQ  (XR),=B$STL,EXTRU  ok if set
       BEQ  (XR),=B$MPL,EXTRU    or map
       BRN  EXFAL
*
*      IS_STRING operator -- entered directly for any operand
*
OPIST  ENT
       MOV  (XS)+,XR         pop operand
       BEQ  (XR),=B$SCL,EXTRU
       BRN  EXFAL
*
*      IS_TUPLE operator -- entered directly for any operand
*
OPITU  ENT
       MOV  (XS)+,XR         pop operand
       BEQ  (XR),=B$TPL,EXTRU  ok if tuple
       BEQ  (XR),=B$PRL,EXTRU    or pair
       BRN  EXFAL
*
*      LESS operator -- entered via APPL2
*      A single entry point is common to sets and maps
*
*      Errors
*
ERLES  ENT
       ERB  086,illegal or undefined operand type for LESS
*
*      Maps and sets -- remove left operand if present
*
MSLES  ENT
       MOV  (XS),XL          load STBLK ptr - leave stacked
       BEQ  (XR),=B$PRL,MSLS1 jump with pair
       BNE  (XR),=B$TPL,MSLS0 jump if not tuple
       BNE  TPNEL(XR),=NUM02,MSLS0 of length 2
       JSR  TUPPR            convert
       BRN  MSLS1            merge with PRBLK
*
MSLS0  JSR  FINDS            look for it
       PPM  MSLS2
       PPM  EXITS
       PPM  EXITS
*
MSLS2  ZER  (XL)             remove entry
       BRN  MSLS9
*
*      Pairs are more tricky
*
MSLS1  MOV  XR,-(XS)         stack argument
       MOV  PRDOM(XR),XR     load domain
       JSR  FINDD
       PPM  MSLS3
       PPM  MSLS8
       PPM  MSLS8
*
*      Here if domain entry was found
*
MSLS3  MOV  XL,WB            save pointer
       MOV  (XS),XL          reload arg
       MOV  WB,(XS)          stack pointer
       BGT  PRNXT(XR),MXLEN,MSLS5 jump if multi-ranged
       JSR  COMPV            compare
       PPM  MSLS4
       PPM  MSLS8
*
MSLS4  MOV  (XS)+,XL         fetch entry pointer
       ZER  (XL)             remove pair
       BRN  MSLS9
*
       EJC
*      Here we have to follow a chain
*
MSLS5  JSR  COMPV
       PPM  MSLS7
       PPM  MSLS6
*
*      No good - keep looking
*
MSLS6  MOV  XR,(XS)          stack last entry
       ADD  *PRNXT,(XS)
       MOV  PRNXT(XR),XR     chain on
       BGT  XR,MXLEN,MSLS5   loop if more
*
*      Merge here to pop stack and fail
*
MSLS8  ICA  XS
       BRN  EXITS
*
*      Remove a pair from the chain
*
MSLS7  MOV  (XS)+,XL         load last element
       MOV  PRNXT(XR),(XL)   unhook this
MSLS9  MOV  (XS),XR
       DCV  STNEL(XR)
       BRN  EXITS
       EJC
*
*      LESSF -- entered via APPL2
*      A single entry point is common to sets and maps
*
*      Errors
*
ERLSF  ENT
       ERB  087,illegal or undefined operand type for LESSF
*
*      Maps and sets - if operand turns out to be a map
*      remove pairs for right operand domain value, if any
*
MSLSF  ENT
       MOV  (XS),XL          load left operand
       BEQ  (XL),=B$MPL,MSLF1 jump if known map
       MOV  XR,-(XS)         else restack xr
       MOV  XL,XR            move over
       JSR  CHKMP            see whether map
       PPM  MSLF0            yes
       ERB  169,left operand of LESSF not a map
*
*      Here after successful check
*
MSLF0  MOV  XR,XL
       MOV  (XS)+,XR
*
*      Merge with a map to do removal
*
MSLF1  JSR  FINDD            look for domain
       PPM  MSLF2            found
       PPM  EXITS
       PPM  EXITS
MSLF2  ZER  (XL)             remove all pairs
       ZER  WA
MSLF3  ICV  WA
       MOV  PRNXT(XR),XR
       BHI  XR,DNAMB,MSLF3
*
       MOV  (XS),XR
       SUB  WA,STNEL(XR)
       BRN  EXITS
       EJC
*
*      max operator -- entered via APPL2
*      integer binary operator
*
ERMAX  ENT
       ERB  023,illegal or undefined operand for max
*
ICMAX  ENT
       MOV  (XS)+,XL         get left operand
       BNE  (XR),=B$ICL,XEMAX  check both integers
       LDI  ICVAL(XL)        compute difference
       SBI  ICVAL(XR)
       IOV  ICMA5            jump if overflow
*
       ILT  ICMA1
       MOV  XL,XR            place larger in XR
*
ICMA1  BRN  EXIXR            merge to return
*
*      overflow cases
*
ICMA5  IGT  ICMA6
       MOV  XL,XR
ICMA6  BRN  EXIXR
*
*      min operator -- entered via APPL2
*
ERMIN  ENT
       ERB  024,illegal or undefined operand for min
*
ICMIN  ENT
       MOV  (XS)+,XL         get left operand
       BNE  (XR),=B$ICL,XEMIN  check both integers
       LDI  ICVAL(XL)
       SBI  ICVAL(XR)
       IOV  ICMI5            jump if overflow
*
       IGT  ICMI1
       MOV  XL,XR            place smaller in XR
*
ICMI1  BRN  EXIXR            merge to return
*
*      here for overflow cases
ICMI5  ILT  ICMI6
       MOV  XL,XR            reverse on overflow
*
ICMI6  BRN  EXIXR
       EJC
*
*      - operator -- entered via APPL2
*      integer, real or set difference
*
*      Errors
*
ERMNS  ENT
       ERB  093,illegal or undefined operand type for -
*
*      Integer subtraction
*
ICMNS  ENT
       MOV  (XS)+,XL
       BNE  (XR),=B$ICL,XEMNS
       LDI  ICVAL(XL)
       SBI  ICVAL(XR)
       INO  EXINT
       BRN  EXIOV
       EJC
*
*      Compute set difference
*
MSMNS  ENT
       MOV  (XS)+,XL
       BEQ  (XR),=B$STL,MSM10
       BEQ  (XR),=B$MPL,MSM10
       BRN  XEMNS
*
MSM10  MNZ  DFFLG            set difference flag
       JSR  DFINT            perfom operation
       BRN  EXIXR
       EJC
.IF    .CNRA
.ELSE
*
*      Real subtraction
*
RCMNS  ENT
       MOV  (XS)+,XL
       BNE  (XR),=B$RCL,XEMNS
       LDR  RCVAL(XL)
       SBR  RCVAL(XR)
       RNO  EXREA
       BRN  EXROV
       EJC
.FI
*
*      Monadic minus -- entered via APPL1
*
*      Errors
*
ERMMN  ENT
       ERB  088,non-numeric operand for monadic -
*
ICMMN  ENT
       LDI  ICVAL(XR)        load the value
       NGI                   negate it
       INO  EXINT
       BRN  EXIOV
*
*
*
.IF    .CNRA
.ELSE
RCMMN  ENT
       LDR  RCVAL(XR)        load the real value
       NGR                   get negation
       BRN  EXREA            cannot overflow, question mark
.FI
       EJC
*
*      * operator -- entered via APPL2
*      multiplication or set intersection
*
*      Errors
*
ERMUL  ENT
       ERB  089,illegal or undefined operand type for *
*
*      Integer multiplication
*
ICMUL  ENT
       MOV  (XS)+,XL         get left operand
       LDI  ICVAL(XL)        load its value
       BEQ  (XR),=B$ICL,ICM10 integer
       BEQ  (XR),=B$SCL,ICM20 string
       BEQ  (XR),=B$PRL,ICM30 pair
       BEQ  (XR),=B$TPL,ICM31 tuple
       BRN  XEMUL
*
*      Here for integer multiplication
*
ICM10  MLI  ICVAL(XR)        perform multiplication
       INO  EXINT            exit if no overflow
       BRN  EXIOV
*
*      Here for integer * string
*
ICM20  JSR  RPLIC            perform replication
       BRN  EXIXR
*
*      Here for integer * pair
*
ICM30  MOV  XR,XL            copy PRBLK
       JSR  PRTUP            convert to tuple
*
*      Merge with integer * tuple
*
ICM31  JSR  RPLTP            perform replication
       BRN  EXIXR
       EJC
*
*      Maps or sets - perform intersection
*
MSMUL  ENT
       MOV  (XS)+,XL
       BEQ  (XR),=B$STL,MSIT1
       BEQ  (XR),=B$MPL,MSIT1
       BRN  XEMUL
*
MSIT1  ZER  DFFLG            not the difference
       JSR  DFINT            do intersection
       BRN  EXIXR
*
*      Pair * - replication
*
PRMUL  ENT
       MOV  (XS)+,XL         get left operand
       BNE  (XR),=B$ICL,XEMUL check type
       LDI  ICVAL(XR)        load replication count
       JSR  PRTUP            convert pair to tuple
       JSR  RPLTP            replicate tuple
       BRN  EXIXR
       EJC
.IF    .CNRA
.ELSE
*
*      Real multiplication
*
RCMUL  ENT
       MOV  (XS)+,XL         get left operand
       BNE  (XR),=B$RCL,XEMUL check type
       LDR  RCVAL(XL)        load its value
       MLR  RCVAL(XR)        perform multiplication
       RNO  EXREA
       BRN  EXROV
*
.FI
*
*      String * - replication
*
SCMUL  ENT
       MOV  (XS)+,XL         get left operand
       BNE  (XR),=B$ICL,XEMUL check type
       LDI  ICVAL(XR)        load replication count
       MOV  XL,XR            copy SCBLK pointer
       JSR  RPLIC            do replicate
       BRN  EXIXR
*
*      Tuple * - replication
*
TPMUL  ENT
       BNE  (XR),=B$ICL,XEMUL check type
       LDI  ICVAL(XR)        load replication count
       MOV  (XS)+,XR           and recover TPBLK
       JSR  RPLTP            replicate tuple
       BRN  EXIXR
       EJC
*
*
*      NOTEQUALS operator -- entered via APPL2
*
*      This operator can be applied to operands of all
*      types - even OM
*
*      Integer
*
ICNEQ  ENT
       MOV  (XS)+,XL         get left operand
       BNE  (XR),=B$ICL,EXTRU true if right not integer
       JSR  ICCMP            compare the values
       PPM  EXTRU            L less than R
       PPM  EXFAL            L = R
       PPM  EXTRU
*
*      Maps and sets - these can be equal to each other
*      since it is possible fro a set to contain only pairs
*      without knowing about it
*
MSNEQ  ENT
       MOV  (XS)+,XL
       BEQ  (XR),=B$STL,MSNQ1 jump with set
       BNE  (XR),=B$MPL,EXTRU succeed unless map
*
*      Here both operands are either sets or maps -
*      any combination might still give equality
*
MSNQ1  JSR  STCMP
       PPM  EXFAL
       PPM  EXTRU
       EJC
*
*      Pairs - have to check other operand for tuple
*      of length 2
*
PRNEQ  ENT
       MOV  (XS)+,XL
       BEQ  (XR),=B$PRL,PRNQ1
       BNE  (XR),=B$TPL,EXTRU
       BNE  STNEL(XR),=NUM02,EXTRU
       JSR  TUPPR
PRNQ1  JSR  PRCMP
       PPM  EXFAL
       PPM  EXTRU
       EJC
.IF    .CNRA
.ELSE
*
*      Reals
*
RCNEQ  ENT
       MOV  (XS)+,XL
       BNE  (XR),=B$RCL,EXTRU
       JSR  RCCMP
       PPM  EXTRU
       PPM  EXFAL
       PPM  EXTRU
.FI
*
*      Strings
*
SCNEQ  ENT
       MOV  (XS)+,XL         load string 1
       BNE  (XR),=B$SCL,EXTRU true if non string
       JSR  LCOMP
       PPM  EXTRU
       PPM  EXFAL
       PPM  EXTRU
*
*      Tuples - must check right operand for pair
*
TPNEQ  ENT
       MOV  (XS)+,XL
       BEQ  (XR),=B$TPL,TPNQ1 jump if both TPBLKs
       BNE  (XR),=B$PRL,EXTRU succeed unless pair
       JSR  PRTUP            convert pair
*
*      Merge to compare TPBLKs
*
TPNQ1  JSR  TPCMP
       PPM  EXFAL
       PPM  EXTRU
*
*      Other types - a simple equality test on addresses is
*      sufficient since they will be unique
*
VLNEQ  ENT
       MOV  (XS)+,XL
       BEQ  XR,XL,EXFAL
       BRN  EXTRU
       EJC
*
*      NOTIN - complement of IN operator
*
*      Entered via APPL1 (sic) so that type checking is done
*      on right operand which is more useful.
*
ERNIN  ENT
       ERB  147,illegal right operand type for NOTIN
*
*      Maps and sets - membership test
*
MSNIN  ENT
       MOV  XR,XL
       MOV  (XS)+,XR
       BEQ  XR,=OMEGA,XEOIN
       JSR  FINDS
       PPM  EXFAL
       PPM  EXTRU
       PPM  EXTRU
*      Pair - check each of its values
*
PRNIN  ENT
       MOV  XR,XL
       MOV  (XS)+,XR
       BEQ  XR,=OMEGA,XEOIN
       MOV  XL,-(XS)
       MOV  PRDOM(XL),XL
       JSR  COMPV
       PPM  PRNN3
       PPM  PRNN2
*
PRNN2  MOV  (XS)+,XL
       MOV  PRRNG(XL),XL
       JSR  COMPV
       PPM  EXFAL
       PPM  EXTRU
*
PRNN3  ICA  XS
       BRN  EXFAL
*
*      String -- look for substring
SCNIN  ENT
       MOV  (XS)+,XL
       BEQ  XL,=OMEGA,XEOIN
       BEQ  XL,=NULLS,EXTRU  null string NOTIN anything
       BNE  (XL),=B$SCL,EXTRU
       JSR  STRSB
       PPM  EXTRU
       PPM  EXFAL
       EJC
*
*      Tuple - fetch each element in turn to check
*
TPNIN  ENT
       MOV  (XS)+,XL
       BEQ  XL,=OMEGA,XEOIN
       MOV  =NUM01,WA        first element
       MOV  XR,WC            save tuple
*
TPNN2  JSR  TPELT            fetch element
       PPM  EXTRU            succeed if exhausted
       JSR  COMPV
       PPM  EXFAL            fail if match
       PPM  TPNN3
*
TPNN3  MOV  WC,XR            reload tuple
       ICV  WA               next element
       BRN  TPNN2
       EJC
*
*      NOT -- logical negation
*      Entered via APPX1
*
ERNOT  ENT
       ERB  115,operand of NOT is not Boolean
*
*      For Booleans return complement
*      Cardinality -- entered via APPL1
*
*      Error case
*
TVNOT  ENT
       BEQ  XR,=TRUE$,EXFAL
       BRN  EXTRU
       EJC
*
*      NPOW operator -- entered via APPL2
*
ERNPW  ENT
       ERB  082,illegal or undefined operand type for NPOW
*
*      Integer NPOW Set
*
ICNPW  ENT
       MOV  (XS)+,XL          get ICBLK
       BEQ  (XR),=B$MPL,ICNP1 map ok
       BNE  (XR),=B$STL,XENPW   or set
ICNP1  JSR  FMNPW             create NPOW set
       BRN  EXIXR
*
*      Map/Set NPOW Integer
*
MSNPW  ENT
       MOV  XR,XL             save ICBLK
       MOV  (XS)+,XR          get set/map
       BNE  (XL),=B$ICL,XENPW error if operand not integer
       JSR  FMNPW
       BRN  EXIXR
       EJC
*
*      # operator -- entered via APPL1
*
ERNUM  ENT
       ERB  094,illegal or undefined operand type for #
*
*      For legal cases mostly just load value from operand block
*
MPNUM  ENT
       MTI  MPNEL(XR)
       BRN  EXINT
*
*      A pair is so called because it has two elements
*
PRNUM  ENT
       LDI  INTV2
       BRN  EXINT
       BRN  EXIXR
SCNUM  ENT
       MTI  SCLEN(XR)
       BRN  EXINT
STNU$  ENT
       MTI  STNEL(XR)
       BRN  EXINT
TPNUM  ENT
       MTI  TPNEL(XR)
       BRN  EXINT
       EJC
*
*      ODD operator -- entered via APPX1
*
ERODD  ENT
       ERB  041,operand of ODD is not integer
*
*      Integer case, check last bit
*
ICODD  ENT
       MOV  ICVAL(XR),WB
       MOV  BITS1,WA         set mask bit
       ANB  WB,WA            check right bit
       BZE  WA,EXFAL
       BRN  EXTRU
*
*      Greater than or equals -- entered via APPL2
*
*      Errors
*
EROGE  ENT
       BRN  EXCMP
*
*      Integer comparisons
*
ICOGE  ENT
       MOV  (XS)+,XL         load left operand
       BNE  (XR),=B$ICL,XECMP error if right not integer
       JSR  ICCMP            compare operands
       PPM  EXFAL
       PPM  EXTRU
       PPM  EXTRU
.IF    .CNRA
.ELSE
*
*      Reals
*
RCOGE  ENT
       MOV  (XS)+,XL         load left operand
       BNE  (XR),=B$RCL,XECMP type check
       JSR  RCCMP
       PPM  EXFAL
       PPM  EXTRU
       PPM  EXTRU
.FI
*
*      Strings
*
SCOGE  ENT
       MOV  (XS)+,XL         load left operand
       BNE  (XR),=B$SCL,XECMP type check
       JSR  LCOMP
       PPM  EXFAL
       PPM  EXTRU
       PPM  EXTRU
       EJC
*
*      Greater than -- entered via APPL2
*
*      Errors
*
EROGT  ENT
       BRN  EXCMP
*
*      integer comaprison
*
ICOGT  ENT
       MOV  (XS)+,XL         load left operand
       BNE  (XR),=B$ICL,XECMP error if right not integer
       JSR  ICCMP            compare operands
       PPM  EXFAL
       PPM  EXFAL
       PPM  EXTRU
*
.IF    .CNRA
.ELSE
*
*      Reals
*
RCOGT  ENT
       MOV  (XS)+,XL         load left operand
       BNE  (XR),=B$RCL,XECMP type check
       JSR  RCCMP
       PPM  EXFAL
       PPM  EXFAL
       PPM  EXTRU
.FI
*
*      Strings
*
SCOGT  ENT
       MOV  (XS)+,XL         load left operand
       BNE  (XR),=B$SCL,XECMP type check
       JSR  LCOMP
       PPM  EXFAL
       PPM  EXFAL
       PPM  EXTRU
       EJC
*
*      IN operator - membership test
*      Entered via APPL1 to give type checking on right operand
*
*      Errors
*
EROIN  ENT
       ERB  146,illegal operand type for IN
       EJC
*
*      Maps and sets -- perform mebership test
*
MSOIN  ENT
       MOV  XR,XL
       MOV  (XS)+,XR
       BEQ  XR,=OMEGA,XEOIN
       JSR  FINDS
       PPM  EXTRU
       PPM  EXFAL
       PPM  EXFAL
*
*      Pairs -- check for equality on each element
*
PROIN  ENT
       MOV  XR,XL
       MOV  (XS)+,XR
       BEQ  XR,=OMEGA,XEOIN
       MOV  XL,-(XS)
       MOV  PRDOM(XL),XL
       JSR  COMPV
       PPM  PRIN3
       PPM  PRIN2
*
PRIN2  MOV  (XS)+,XL
       MOV  PRRNG(XL),XL
       JSR  COMPV
       PPM  EXTRU
       PPM  EXFAL
*
PRIN3  ICA  XS
       BRN  EXTRU
*
*      String -- check for substring
*
SCOIN  ENT
       MOV  (XS)+,XL
       BEQ  XL,=OMEGA,XEOIN
       BEQ  XL,=NULLS,EXFAL  fails if null string
       BNE  (XL),=B$SCL,EXFAL
       JSR  STRSB
       PPM  EXFAL
       PPM  EXTRU
       EJC
*
*      Tuple -- check each element in turn
*
TPOIN  ENT
       MOV  (XS)+,XL         unstack operand sought
       BEQ  XL,=OMEGA,XEOIN
       MOV  =NUM01,WA
       MOV  XR,WC            save
*
TPIN2  JSR  TPELT
       PPM  EXFAL            fail if exhausted
       JSR  COMPV            compare values
       PPM  EXTRU            succeed if a match
       PPM  TPIN3
*
TPIN3  MOV  WC,XR
       ICV  WA               for next element
       BRN  TPIN2
       EJC
*
*      Less than or equal -- entered via APPL2
*
*      Errors
*
EROLE  ENT
       BRN  EXCMP
*
*      Integer comparison
*
ICOLE  ENT
       MOV  (XS)+,XL         load left operand
       BNE  (XR),=B$ICL,XECMP error if right not integer
       JSR  ICCMP            compare operands
       PPM  EXTRU
       PPM  EXTRU
       PPM  EXFAL
.IF    .CNRA
.ELSE
*
*      Reals
*
RCOLE  ENT
       MOV  (XS)+,XL         load left operand
       BNE  (XR),=B$RCL,XECMP type check
       JSR  RCCMP
       PPM  EXTRU
       PPM  EXTRU
       PPM  EXFAL
.FI
*
*      Strings
*
SCOLE  ENT
       MOV  (XS)+,XL         load left operand
       BNE  (XR),=B$SCL,XECMP type check
       JSR  LCOMP
       PPM  EXTRU
       PPM  EXTRU
       PPM  EXFAL
       EJC
*
*      Less than -- entered via APPL2
*
*      Errors
*
EROLT  ENT
       BRN  EXCMP
*
*      Integer comparison
*
ICOLT  ENT
       MOV  (XS)+,XL         load left operand
       BNE  (XR),=B$ICL,XECMP error if right not integer
       JSR  ICCMP            compare operands
       PPM  EXTRU
       PPM  EXFAL
       PPM  EXFAL
.IF    .CNRA
.ELSE
*
*      Reals
*
RCOLT  ENT
       MOV  (XS)+,XL         load left operand
       BNE  (XR),=B$RCL,XECMP type check
       JSR  RCCMP
       PPM  EXTRU
       PPM  EXFAL
       PPM  EXFAL
.FI
*
*      Strings
*
SCOLT  ENT
       MOV  (XS)+,XL         load left operand
       BNE  (XR),=B$SCL,XECMP type check
       JSR  LCOMP
       PPM  EXTRU
       PPM  EXFAL
       PPM  EXFAL
       EJC
*
*      Prepare rhs for parallel lhs assignment [a,b] :=
*
ERPLH  ENT
       ERB  105,illegal rhs type for compound assignment
*
*      Pair rhs
*
PRPLH  ENT
       MOV  XR,-(XS)         restore rhs
       LCW  WC               next word is # stores
       MOV  PRDOM(XR),-(XS)  load 1st value
       DCV  WC
       BZE  WC,PRLH2         jump if done
       MOV  PRRNG(XR),-(XS)  load 2nd
       DCV  WC
       BZE  WC,PRLH2
       LCT  WC,WC
PRLH1  MOV  =OMEGA,-(XS)     generate om for others
       BCT  WC,PRLH1
PRLH2  BRN  EXITS
*
*      Tuple rhs
*
TPPLH  ENT
       MOV  XR,-(XS)         restore rhs
       LCW  WC               next word has store count
       MOV  =NUM01,WA        init index
       MOV  XR,XL            save tuple
       LCT  WC,WC
TPLH1  MOV  XL,XR            retrieve orig tuple
       JSR  TPELT
       PPM  TPLH2
TPLH2  MOV  XR,-(XS)         store elt or om
       ICV  WA               next index
       BCT  WC,TPLH1         loop if more
       BRN  EXITS
*
*      + operator -- entered via APPL2
*
*      Errors
*
ERPLS  ENT
       ERB  095,illegal or undefined operand type for +
*
*      Integer addition
*
ICPLS  ENT
       MOV  (XS)+,XL         get left operand
       LDI  ICVAL(XL)        load value of left operand
       BNE  (XR),=B$ICL,XEPLS check type
       ADI  ICVAL(XR)        perform addition
       INO  EXINT
       BRN  EXIOV
*
*      Map or set union
*
MSPLS  ENT
       MOV  (XS)+,XL
       BEQ  (XR),=B$STL,MSPL1
       BEQ  (XR),=B$MPL,MSPL1
       BRN  XEPLS
*
MSPL1  JSR  UNION
       BRN  EXIXR
*
*      Pair - convert to tuple - JVK addition
*
PRPLS  ENT
       BEQ  (XR),=B$PRL,PRPL1  check right operand
       BEQ  (XR),=B$TPL,PRPL2
       BRN  XEPLS            illegal operand
PRPL1  MOV  XR,XL            convert right oper to tuple
       JSR  PRTUP              result in XR
       BRN  PRPL3
PRPL2  BNZ  TPNEL(XR),PRPL3  is right empty
       MOV  (XS)+,XR           then return left operand
       JSR  COPYV              copy if needed
       MOV  XL,XR
       BRN  EXIXR
PRPL3  MOV  (XS)+,XL         recover left pair
       MOV  XR,-(XS)         save right operand-tuple
       JSR  PRTUP            convert left to tuple
       MOV  XR,XL
       MOV  (XS)+,XR         recover right oper
       JSR  TCONC            concatenate
       BRN  EXIXR
.IF    .CNRA
.ELSE
*
*      Real addition
*
RCPLS  ENT
       MOV  (XS)+,XL         get left operand
       LDR  RCVAL(XL)        load real value
       BNE  (XR),=B$RCL,XEPLS check type
       ADR  RCVAL(XR)        perform addition
       RNO  EXREA
       BRN  EXROV
.FI
       EJC
*
*      String concatenation
*
SCPLS  ENT
       MOV  (XS)+,XL         get left operand
       BNE  (XR),=B$SCL,XEPLS check type
       JSR  SCONC            perform concatenation
       BRN  EXIXR
*
*      Tuple concatenation - JVK addition
*
TPPLS  ENT
       BEQ  (XR),=B$PRL,TPPL1  check type
       BEQ  (XR),=B$TPL,TPPL2
       BRN  XEPLS           illegal operand
TPPL1  MOV  XR,XL           convert right operand to tuple
       JSR  PRTUP
TPPL2  MOV  (XS)+,XL        retrieve left operand
       JSR  TCONC           perform concatenation
       BRN  EXIXR
*
*      POW operator -- entered via APPL1
*
ERPOW  ENT
       ERB  083,illegal or undefined operand type for POW
*
*      Map or set - form power set
*
MSPOW  ENT
       MOV  STNEL(XR),WC
       MOV  =CFP$N,WB       find word size
       SUB  =NUM06,WB         less 6 bits
       BLE  WC,WB,MSP01     limit size of original set
       ERB  084,set exceeds size limit for POW
*
MSP01  BNZ  WC,MSP02        check if set empty
       MOV  =NUM01,WA       if so, create power set
       JSR  ALOTS
       MOV  =B$STL,(XR)
       ZER  STNEL(XR)
       MOV  XR,XL
       MOV  =NLSET,XR       null set is only entry
       JSR  ADSEL
       MOV  XL,XR
       BRN  EXIXR
*
*      Here if one or more elts
*
MSP02  JSR  SETTP           convert set to tuple of elts
       MOV  XR,-(XS)        save tuple
       MOV  XL,-(XS)          and selector tuple
       MOV  =NUM01,WA
       MOV  TPNEL(XR),XL    set index reg
       LSX  WA,(XL)         compute size of power set
       MOV  WA,-(XS)        and save
       ZER  -(XS)           init counter
       JSR  ALOTS           allocate power set
       MOV  =B$STL,(XR)
       ZER  STNEL(XR)
       MOV  XR,-(XS)        and save
*
MSP03  MOV  OFFS2(XS),WB    retrieve limit
       MOV  OFFS1(XS),WC    and counter
       BGE  WC,WB,MSP04     jump if done
*
       MOV  OFFS3(XS),XL    retrieve selector tuple
       MOV  TPNEL(XL),-(XS) init loop ctr
       ADD  *TPSI$,XL       point to first entry
       MOV  BITS1,WA        init mask
*
MSP31  MOV  WA,WB
       ANB  WC,WB           check bit
       ZRB  WB,MSP32        jump if not set
       MOV  =NUM01,(XL)+    1 entry
       BRN  MSP33
MSP32  ZER  (XL)+           0 entry
MSP33  LSH  WA,1            shift mask bit
       DCV  (XS)            update ctr
       BNZ  (XS),MSP31
*
       ICA  XS              discard loop ctr
       MOV  OFFS3(XS),XL    retrieve selector
       MOV  OFFS4(XS),XR      and tuple
       JSR  SELST           form set from selected elements
       MOV  (XS),XL         retrieve power set
       JSR  ADSEL           and add new elt
       MOV  XL,(XS)         save if update
       ICV  OFFS1(XS)       increment counter
       BRN  MSP03
*
*      Now done, clean up and leave
*
MSP04  MOV  (XS)+,XR        retrieve power set
       ADD  *NUM04,XS       discard ctr, limit, selector, tuple
       BRN  EXIXR
       EJC
*
*      ? -- in compound operator, entered via APPX2
*
*      Never an error - just return (non-omega) left argument
*      Next code word jumps out of block
*
ERQMC  ENT
       MOV  (XS)+,XR        get left argument (not omega)
       ADD  *NUM02,XS       discard iterator temps
       BRN  EXIXR
*
*      Omega left argument - return right argument
*
OMQMC  ENT
       ICA  XS              discard left arg
       ICP                  omit jump out of block
       BRN  EXIXR           return right arg
*
*      REM -- entered via APPL2
*
*      Error
*
ERREM  ENT
       BRN  XEREM
*
*      Integer -- compute remainder
*
ICREM  ENT
       MOV  (XS)+,XL
       BNE  (XR),=B$ICL,XEREM
       BNZ  ICVAL(XR),IREM1  check if zero divisor
       ERB  108,zero divisor for MOD operator
*
IREM1  LDI  ICVAL(XR)      get right operand
       IGE  IREM2          check if negative
       NGI                 if not, switch
IREM2  STI  REMDV          save abs value of divisor
       LDI  ICVAL(XL)
       RMI  REMDV          divide
       IGE  IREM3
       ADI  REMDV          if negative result, add abs(divisor)
IREM3  BRN  EXINT
*
*      Sets - compute symmetric difference
*
MSREM  ENT
       MOV  (XS)+,XL
       BEQ  (XR),=B$STL,MSRM1
       BNE  (XR),=B$MPL,XEREM  error if not set or map
*
MSRM1  JSR  DFSST          compute symmetric difference
       BRN  EXIXR
       EJC
*
*      RANDOM -- entered via APPL1
*
ERRND  ENT
       ERB  104,illegal or undefined operand for RANDOM
*
*      Random - Integer
*
ICRND  ENT
       LDI  ICVAL(XR)
       IGE  IRND1
       NGI
       IOV  EXIOV
       MNZ  RNDSN              remember minus sign
       BRN  IRND2
IRND1  ZER  RNDSN
IRND2  ADI  INTV1              want range 0 .. num inclusive
       JSR  SYSRN              get a random number
       BZE  RNDSN,EXINT
       NGI
       INO  EXINT
       BRN  EXIOV
*
*      Maps & Sets - select random elt
*
MSRND  ENT
       LDI  STNEL(XR)
       IEQ  EXIOM              if null, return om
       MOV  XR,-(XS)           save set
       MOV  *STSI$,WA          init set iterator
       MOV  WA,-(XS)             and save
       JSR  SYSRN              get integer in 0 .. #t-1
       ADI  INTV1              set random index 1..#t
       MFI  WC
       LCT  WC,WC
MRND1  MOV  (XS),XL            get iterator
       MOV  OFFS1(XS),XR         and set
MRND2  JSR  NEXTS              get elt into XR
       BNE  XR,=OMEGA,MRND3    jump if real entry
       MOV  WA,XR
       BRN  MRND2              if om, try again
MRND3  MOV  XL,(XS)            update iterator
       BCT  WC,MRND1           repeat until done
       JSR  COPYV              and copy if needed
       MOV  XL,XR              and return copy
       ICA  XS
       ICA  XS
       BRN  EXIXR
*
*      Pairs
*
PRRND  ENT
       LDI  INTV2              select from 2 elts
       JSR  SYSRN              returns 0 or 1
       INE  PRND1
       MOV  PRDOM(XR),XR       if 0, return dom elt
       BRN  PRND2
PRND1  MOV  PRRNG(XR),XR       if 1, return range elt
PRND2  JSR  COPYV              make copy if needed
       MOV  XL,XR              and return it
       BRN  EXIXR
*
*      Tuples
*
TPRND  ENT
       LDI  TPNEL(XR)
       IEQ  EXIOM              if null, return om
       JSR  SYSRN              get integer in 0 .. #t-1
       ADI  INTV1              set random index 1..#t
       MFI  WA
       JSR  TPELT              select elt
       PPM
       JSR  COPYV              and copy if needed
       MOV  XL,XR              and return copy
       BRN  EXIXR
       EJC
*
*      RANGE -- entered via APPX1
*
*      Errors
*
ERRNG  ENT
       BRN  XEDMR
*
*
MSRNG  ENT
       ZER  RNGDM
       BRN  EXRND
*
*      Subscripted assignment -- f(x) on left
*
*      Entered via APPL2 with value to be assigned at (XS)
*
*      Errors
*
ERSBA  ENT
       ERB  091,illegal type of subscripted expression (lh)
*      Maps and sets - single valued assignment
*
MSSBA  ENT
       MOV  XR,WA              JVK-save rhs
       MOV  (XS)+,XR           now get index
       MOV  (XS),XL            and map
       MOV  WA,-(XS)
       BNE  (XL),=B$STL,MSBA1  jump if known map
       MOV  XR,WA
       MOV  XL,XR
       JSR  CHKMP
       PPM  MSBA2
       ERB  194,subscripted lh set was not a map
*
MSBA2  MOV  XR,XL
       MOV  WA,XR
*
MSBA1  JSR  FINDD            find domain
       PPM  MSBA5            found, XL pos in map
       PPM  MSBA4
       PPM  MSBA4
*
*      Here to replace element - find end of chain
*
MSBA5  ZER  WA
MSBA3  BLO  PRNXT(XR),DNAMB,MSBA6  jump if end of chain
       MOV  PRNXT(XR),XR
       ICV  WA
       BRN  MSBA3
*
*      Replace range at start of chain, resetting link
*
MSBA6  BEQ  (XS),=OMEGA,MSBA7  check rhs
       MOV  (XL),XL            insert
       MOV  PRNXT(XR),PRNXT(XL)
       MOV  (XS)+,PRRNG(XL)
       MOV  (XS)+,XR         return updated map
       SUB  WA,MPNEL(XR)     and correct #map
       BRN  EXIXR
       EJC
*
*      Here to assign OM -- remove pairs
*
MSBA7  ICV  WA
       ZER  (XL)             leave deleted marker
       MOV  (XS)+,XR
       MOV  (XS)+,XR         return updated map
       SUB  WA,MPNEL(XR)     and correct #map
       BRN  EXIXR
*
*      If no pairs existed, make one and add it in the
*      usual way, unless assigned value is OM
*
MSBA4  BNE  (XS),=OMEGA,MSBA8
       MOV  (XS)+,XR         OM is no-op
       MOV  (XS)+,XR         return map
       BRN  EXIXR
MSBA8  MOV  XR,-(XS)
       MOV  *PRSI$,WA        insert a new pair
       ZER  XL
       JSR  ALLOC
       MOV  =B$PRL,(XR)
       ZER  PRNXT(XR)
       MOV  (XS)+,PRDOM(XR)
       MOV  (XS)+,PRRNG(XR)
       MOV  (XS)+,XL         retrieve map
       JSR  ADSEL
       MOV  XL,XR            return updated map
       BRN  EXIXR
       EJC
*
*      Tuple element assignment
*
TPSBA  ENT
       MOV  XR,WA            JVK-save rhs
       MOV  (XS)+,XR         get index now
       MOV  (XS)+,XL         the tuple
       MOV  WA,-(XS)
       BNE  (XR),=B$ICL,TSBA2
       LDI  ICVAL(XR)        get value for subscript
       ILE  TSBA3            check in range
       MFI  WA,TSBA4
       MOV  (XS)+,XR
       JSR  ADTEL            add the element
       MOV  XL,XR            JVK-stack the updated tuple
       BRN  EXIXR
*
*      Lots of errors can occcur (Code shared with PRSBA)
*
TSBA2  ERB  192,tuple subscript not an integer (lh)
TSBA3  ERB  191,tuple subscript negative or zero(lh)
TSBA4  ERB  190,tuple subscript too large (lh)
       EJC
*
*      Pair element assignment
*
PRSBA  ENT
       MOV  XR,WA              JVK-save RHS
       MOV  (XS)+,XR           now get index
       MOV  (XS)+,XL              and pair
       MOV  WA,-(XS)
       BNE  (XR),=B$ICL,TSBA2
       LDI  ICVAL(XR)
       ILE  TSBA3
       MFI  WA,TSBA4
       MOV  (XS)+,XR
*
*      If subscript value is other than 1 or 2, we
*      want to make a tuple - likewise if assigned value
*      is OM
*
       MOV  WA,WB            copy value
       BEQ  XR,=OMEGA,PSBA1  jump with OM to assign
       DCV  WA
       BNZ  WA,PSBA2         was it 1
       MOV  XR,PRDOM(XL)
       MOV  XL,XR            JVK-push new pair
       BRN  EXIXR
PSBA2  DCV  WA               or was it 2
       BNZ  WA,PSBA1         no
       MOV  XR,PRRNG(XL)
       MOV  XL,XR            JVK-push new pair
       BRN  EXIXR
*
*      Here if we need a tuple
*
PSBA1  MOV  XR,-(XS)
       JSR  PRTUP            convert
       MOV  WB,WA            recover subs value
       MOV  XR,XL
       MOV  (XS)+,XR
       JSR  ADTEL            add the element
       MOV  XL,XR
       BRN  EXIXR
       EJC
*
*      String element assignment
*
SCSBA  ENT
       MOV  XR,WA            save rhs
       MOV  (XS)+,XR         get index now
       MOV  (XS)+,XL         and the string
       MOV  WA,-(XS)
       BNE  (XR),=B$ICL,SCSB2 check subscript type
       LDI  ICVAL(XR)        get value
       ILE  SCSB3            check in range
       MFI  WB,SCSB4
       BGT  WB,SCLEN(XL),SCSB4
       DCV  WB               convert index to offset
       MOV  (XS),XR          recover rhs
       BNE  (XR),=B$SCL,SCSB6 source must be char
       BNE  SCLEN(XR),=NUM01,SCSB5 of length one
       MOV  WB,-(XS)         save offset
       MOV  XL,XR            shift target string
       LDI  INTV1
       JSR  RPLIC            copy it once
       MOV  XR,XL
       MOV  (XS)+,WB         recover offset
       MOV  (XS)+,XR           and rhs
       MOV  XL,-(XS)         save target string
       PSC  XL,WB            prepare move at offset
       PLC  XR
       LCH  WA,(XR)          move the character
       SCH  WA,(XL)
       CSC  XL               and clean up
       MOV  (XS)+,XR         recover target string
       BRN  EXIXR            and return
*
*      Several possible errors
*
SCSB2  ERB  185,string subscript not an integer(lh)
SCSB3  ERB  184,string subscript negative or zero(lh)
SCSB4  ERB  183,string subscript too large(lh)
SCSB5  ERB  182,string too long for subscript assign(lh)
SCSB6  ERB  181,illegal rhs for string subscript assn(lh)
       EJC
*
*      Multi valued map reference (curly subscript)
*
*      Entered via APPL2
*
ERSBM  ENT
       ERB  092,illegal type for multi-value map reference
*
*      Maps and sets - have to check whether set is a map.
*
MSSBM  ENT
       MOV  (XS)+,XL
       BEQ  XR,=OMEGA,MSBM6
       BEQ  (XL),=B$MPL,MSBM1
       MOV  XR,WA
       MOV  XL,XR
       JSR  CHKMP
       PPM  MSBM2
       ERB  189,map reference to set which was not a map
*
MSBM2  MOV  XR,XL
       MOV  WA,XR
*
*      Look for domain
*
MSBM1  JSR  FINDD
       PPM  MSBM3
       PPM  MSBM4
       PPM  MSBM4
*
*      Here if it was not found
*
MSBM4  MOV  =NLSET,XR
       BRN  EXIXR
*
*      Otherwise, build a set from range elements
*
MSBM3  ZER  WA               clear a counter
MSBM5  MOV  PRRNG(XR),-(XS)  stack a element
       ICV  WA               count it
       MOV  PRNXT(XR),XR     follow chain link
       BHI  XR,=DNAMB,MSBM5  loop until end
*
       JSR  FMSET            make the set
       BRN  EXIXR
*
MSBM6  ERB  187,undefined subscript value
       EJC
*
*      SUBSET -- entered via APPX2
*
*      Errors
*
ERSBS  ENT
       ERB  096,illegal or undefined operand type for subset
*
*      Maps or sets -- complement of inclusion operator
*
MSSBS  ENT
       MOV  (XS)+,XL
       BEQ  (XR),=B$STL,STSB1
       BEQ  (XR),=B$MPL,STSB1
       ERB  140,right operand of SUBSET not a set
*
*      Swop over operands and test INCS
*
STSB1  MOV  XR,WA
       MOV  XL,XR
       MOV  WA,XL
       JSR  STNCL
       PPM  EXTRU
       PPM  EXFAL
       EJC
*
*      Slice assign  t(a..b):=y
*
ERSLA  ENT
ESLA0  ERB  205,illegal type for slice assign
*
*      String slice assign  s(i..j):=x
*
SCSLA  ENT
       BNE  (XR),=B$SCL,TSLA9   error if rhs not string
       MOV  XR,-(XS)
       MOV  OFFS1(XS),XR        get index j
       BNE  (XR),=B$ICL,SSL90   error if non-integer
       LDI  ICVAL(XR)
       ILT  SSL92               error if j < 0
       MOV  OFFS3(XS),XL        get string s
       SBI  SCLEN(XL)
       IGT  SSL93               error if j > #s
       MOV  OFFS2(XS),XL        get index i
       BNE  (XL),=B$ICL,SSL90   non-integer error
       LDI  ICVAL(XL)
       ILE  SSL91               error if i <= 0
       SBI  ICVAL(XR)
       SBI  INTV1
       IGT  SSL94               error if i > j+1
       INE  SSLA3
*
*      Here if i = j+1
*
       MOV  XL,XR
       LDI  ICVAL(XR)           get i again
       MOV  OFFS3(XS),XL        and string s
       SBI  SCLEN(XL)
       ILT  SSLA1               check if i > #s
*
*      Special case i = #s or #s + 1, concatenate s + x
*
       MOV  (XS),XR             retrieve rhs x
       JSR  SCONC               concat s+x
       ADD  =NUM04,XS
       BRN  EXIXR               return result
*
*      General case for i = j+1, form s(1..i) + x
SSLA1  LDI  ICVAL(XL)           target size = i + #x
       MOV  (XS),XR
       ADI  SCLEN(XR)
       MFI  WA
       JSR  ALOCS               allocate target block
       MOV  XR,-(XS)            and save
       PSC  XR
       MOV  OFFS3(XS),XL        get i
       MOV  ICVAL(XL),WA
       MOV  OFFS4(XS),XL        get source s
       PLC  XL
       MVC                      copy s(1..i)
       MOV  OFFS1(XS),XL        get rhs x
       MOV  SCLEN(XL),WA        # chars in x
       BZE  WA,SSLA2            skip if null string
       PLC  XL
       MVC
SSLA2  MOV  (XS)+,XR            retrieve target
       MOV  *NUM04,XS
       BRN  EXIXR
*
*      Here if 1 <= i <= j <= #s, form s(1.. i-1) + x + s(j+1 ..)
*
SSLA3  LDI  ICVAL(XL)           target size = i-1 + #x + #s - j
       SBI  INTV1
       MOV  (XS),XR             retrieve x
       ADI  SCLEN(XR)
       MOV  OFFS3(XS),XR        get s
       ADI  SCLEN(XR)
       MOV  OFFS1(XS),XR        get j
       SBI  ICVAL(XR)
       MFI  WA
       JSR  ALOCS               allocate target string
       MOV  XR,-(XS)            and save
       PSC  XR
       MOV  OFFS3(XS),XL        get i
       MOV  ICVAL(XL),WA
       DCV  WA
       BZE  WA,SSLA4            jump to skip
       MOV  OFFS4(XS),XL        else copy s(1 .. i-1)
       PLC  XL
       MVC
SSLA4  MOV  OFFS1(XS),XL        then x
       MOV  SCLEN(XL),WA
       BZE  WA,SSLA5            jump if x null string
       PLC  XL                  else copy x
       MVC
SSLA5  MOV  OFFS2(XS),XL        get j
       MOV  ICVAL(XL),WB        j+1 st letter at offset j
       MOV  OFFS4(XS),XL        get s
       MOV  SCLEN(XL),WA        xfer #s - j chars
       SUB  WB,WA
       BZE  WA,SSLA6
       PLC  XL,WB               copy s(j+1 ..)
       MVC
SSLA6  MOV  (XS)+,XR            return target
       ADD  *NUM04,XS
       BRN  EXIXR
*
*      Error cases
*
SSL90  ADD  *NUM04,XS           subscript non-integer
       BRN  XESLI
*
SSL91  ADD  *NUM04,XS           slice subscript 0 or neg
       BRN  XESL0
*
SSL92  ADD  *NUM04,XS           end slice index negative
       BRN  XESLN
*
SSL93  ADD  *NUM04,XS           end slice index exceeds length
       BRN  XESLE
*
SSL94  ADD  *NUM04,XS           here if i > j+1
       BRN  XESLL
*
*      Tuple and pair slice assign  t(i..j):=tt
*
TPSLA  ENT
       BEQ  (XR),=B$TPL,TSLA1   check RHS type
       BNE  (XR),=B$PRL,TSLA9   error if not tuple or pair
       MOV  XR,XL
       JSR  PRTUP               if pair, convert to tuple
*
TSLA1  MOV  XR,-(XS)            save rhs tuple
       MOV  OFFS2(XS),XL        get index i
       BNE  (XL),=B$ICL,TSL90   error if non-integer
       LDI  ICVAL(XL)
       ILE  TSLA7               error if i <= 0
       MOV  OFFS1(XS),XR        get index j
       BNE  (XR),=B$ICL,TSL90   error if non-integer
       SBI  ICVAL(XR)
       SBI  INTV1
       IGT  TSLA8               error if i > j+1
       ILT  TSLA3               jump if i < j+1
*
*      If i = j+1 form t(1..i) + tt
*
       MOV  OFFS3(XS),XR        retrieve t
       BEQ  (XR),=B$TPL,TSLA2
       MOV  XR,XL               convert pair to tuple
       JSR  PRTUP
       MOV  XR,OFFS3(XS)
TSLA2  MOV  =NUM01,WA           allocate target block
       JSR  ALOTS
       MOV  =B$TPL,(XR)         init block type
       MOV  XR,-(XS)              and save
*
       MOV  =NUM01,WA           init source index
       MOV  WA,WC                 and target index
       MOV  OFFS3(XS),XR        get index i
       MOV  ICVAL(XR),WB        source index limit
       MOV  OFFS4(XS),XR        source tuple t
       MOV  (XS),XL             target tuple
       JSR  SLTPI               insert t(1..i) into target
       MOV  XL,(XS)             update target
*
       MOV  OFFS1(XS),XR        source tuple tt
       MOV  =NUM01,WA           init source index
       MOV  TPNEL(XR),WB          and source limit
       JSR  SLTPI               insert tt into target
       MOV  XL,XR               result to XR
       ADD  *NUM05,XS           discard args
       BRN  EXIXR
*
*      If 1 <= i < j+1 form t(1.. i-1) + tt + t(j+1 ..)
*
TSLA3  MOV  OFFS3(XS),XR        retrieve t
       BEQ  (XR),=B$TPL,TSLA4
       MOV  XR,XL               convert pair to tuple
       JSR  PRTUP
       MOV  XR,OFFS3(XS)
TSLA4  ZER  WA                  allocate empty target block
       JSR  ALOTS
       MOV  =B$TPL,(XR)         init block type
       MOV  XR,-(XS)              and save
       MOV  XR,XL               init target for SLTPI
*
       MOV  =NUM01,WA           init source index
       MOV  WA,WC                 and target index
       MOV  OFFS3(XS),XR        get index i
       MOV  ICVAL(XR),WB        source index limit
       DCV  WB
       BGT  WA,WB,TSLA5         jump to skip t(1.. i-1)
*
       MOV  OFFS4(XS),XR        source tuple t
       JSR  SLTPI               insert t(1.. i-1) into target
       MOV  XL,(XS)             update target
*
TSLA5  MOV  OFFS1(XS),XR        source tuple tt
       MOV  =NUM01,WA           init source index
       MOV  TPNEL(XR),WB          and source limit
       BZE  WB,TSL51            skip if null tuple
       JSR  SLTPI               insert tt into target
       MOV  XL,(XS)               and update target
*
TSL51  MOV  OFFS2(XS),XR        get index j
       MOV  ICVAL(XR),WA
       ICV  WA                  start at j+1
       MOV  OFFS4(XS),XR        get source t
       MOV  TPNEL(XR),WB
       BGT  WA,WB,TSLA6         jump to skip t(j+1 ..)
       JSR  SLTPI               else copy it to target
       MOV  XL,(XS)             update target
TSLA6  MOV  (XS)+,XR            result to XR
       ADD  *NUM04,XS           discard args
       BRN  EXIXR
*
*      Error cases
*
TSLA7  ADD  *NUM04,XS           here if i <= 0
       BRN  XESL0
*
TSLA8  ADD  *NUM04,XS           here if i > j+1
       BRN  XESLL
*
TSLA9  ADD  *NUM03,XS           here if rhs not tuple or pair
       BRN  XESLT
*
TSL90  ADD  *NUM04,XS           here if non-integer subscript
       BRN  XESLI
       EJC
*
*      Slice  t(a..b)
*
ERSLC  ENT
ESLC0  ERB  102,illegal type of sliced expression
*
*      Pairs - take tuple slice
*
PRSLC  ENT
       MOV  OFFS1(XS),XL        get the pair
       MOV  XR,-(XS)            save end index
       JSR  PRTUP               convert pair to tuple
       MOV  XR,OFFS2(XS)        replace pair
       MOV  (XS)+,XR            recover end index
       MOV  =TPSLC,XL           get tuple entry point
       BRI  XL                  pretend it was tuple from start
*
*      String slice  s(i..j)
*
SCSLC  ENT
       BNE  (XR),=B$ICL,TSLC9   error if end index non-int
       MOV  (XS),XL             get end index
       BNE  (XL),=B$ICL,TSLC9   error if init index non-int
       MOV  XR,-(XS)            save end index
       MOV  OFFS2(XS),XL        get string
       LDI  ICVAL(XR)           get j
       ILT  SSLC7               error if neg
       SBI  SCLEN(XL)
       IGT  SSLC8               error if j > #s
*
       MOV  OFFS1(XS),XL        get i
       LDI  ICVAL(XL)
       ILE  TSLC7               error if i 0 or neg
       SBI  ICVAL(XR)
       SBI  INTV1
       IGT  TSLC8               error if i > j+1
       INE  SSLC1
*
*      Here if i = j+1, return null string
*
       ADD  *NUM03,XS           clear stack
       MOV  =NULLS,XR           return null string
       BRN  EXIXR
*
*      Here if 1 <= i <= j <= #s
*
SSLC1  MOV  (XS)+,XR
       LDI  ICVAL(XR)           target size = j - i + 1
       SBI  ICVAL(XL)
       ADI  INTV1
       MFI  WA
       JSR  ALOCS               allocate target block
       MOV  WC,WA               restore # chars
       MOV  (XS)+,XL            retrieve i block
       MOV  XR,-(XS)            save target
       MOV  ICVAL(XL),WB        get init offset
       DCV  WB                    based on 0..
       MOV  OFFS1(XS),XL        get source string
       PLC  XL,WB               set up xfer with offset
       PSC  XR
       MVC                      xfer WA chars
       MOV  (XS)+,XR            return target
       ICA  XS                  discard source
       BRN  EXIXR
*
*      Error cases
*
SSLC7  ADD  *NUM03,XS           here if j neg
       BRN  XESLN
*
SSLC8  ADD  *NUM03,XS           here if j > #s
       BRN  XESLE
       EJC
*
*      Tuple slice  t(i..j)
*
TPSLC  ENT
       BNE  (XR),=B$ICL,TSLC9  error if end index non-int
       MOV  (XS),XL        get init index
       BNE  (XL),=B$ICL,TSLC9  error of init index non-int
       MOV  XR,-(XS)       save end index
       MOV  OFFS2(XS),XR   get tuple
       LDI  ICVAL(XL)
       ILE  TSLC7          error if 0 or neg
       SBI  TPNEL(XR)
       SBI  INTV1
       IGT  TSLC8          error if i > #t + 1
       ILT  TSLC1
TSLC0  ADD  *NUM03,XS      clear stack
       MOV  =NLTUP,XR      if i = #t+1 or j+1 return null tuple
       BRN  EXIXR
*
TSLC1  LDI  ICVAL(XL)
       MOV  (XS),XR        retrieve end index
       SBI  ICVAL(XR)
       SBI  INTV1
       IGT  TSLC8          error if i > j+1
       IEQ  TSLC0          if i = j+1 return null tuple
*
*      Here for 1 <= i <= j (and i <= #t)
*
       JSR  SLICT         form slice t(i..j)
       BRN  EXIXR
*
*      Error cases
*
TSLC7  ADD  *NUM03,XS     Here if i <= 0
       BRN  XESL0
*
TSLC8  ADD  *NUM03,XS     Here if i>#t+1 or i>j+1
       BRN  XESLL
*
TSLC9  ICA  XS            Here if non-int index
       ICA  XS
       BRN  XESLI
*
*      Subscripted assignment -- m{x} on left
*
ERSMA  ENT
       ERB  327,illegal type of subscripted map expression (lh)
*
*      Maps and sets - multi-valued assignment
*
MSSMA  ENT
       BEQ  (XR),=B$STL,MSMA0  check that rhs is set
       BEQ  (XR),=B$MPL,MSMA0
       ERB  328,rhs of multi-valued map assign was not a set
*
MSMA0  MOV  XR,WA        save rhs
       MOV  (XS)+,XR     now get index
       MOV  (XS),XL        and the map
       MOV  XR,-(XS)     keep index
       MOV  WA,-(XS)       and the rhs
       BNE  (XL),=B$STL,MSMA2  jump if known to be map
       MOV  XR,WA
       MOV  XL,XR
       JSR  CHKMP
       PPM  MSMA1        set was map
       ERB  329,curly subscripted lh set was not a map
*
MSMA1  MOV  XR,XL
       MOV  WA,XR
*
MSMA2  JSR  FINDD
       PPM  MSMA3        found, XL pos in map
       PPM  MSMA6
       PPM  MSMA6
*
*      Here to delete existing elements
*
MSMA3  ZER  WA           count entries on pair chain
MSMA4  ICV  WA
       BLO  PRNXT(XR),DNAMB,MSMA5
       MOV  PRNXT(XR),XR
       BRN  MSMA4
*
MSMA5  ZER  (XL)         delete pair chain
       MOV  OFFS2(XS),XL recover map
       SUB  WA,MPNEL(XL)   and update # map
*
*      Merge to create pairs and add to the pair chain
*      in the usual way, unless the assigned value is {}
*
MSMA6  MOV  (XS),XR      recover rhs
       MOV  *STSI$,-(XS) initialize iterator
       MOV  STNEL(XR),-(XS) counter of # elts in rhs
*
MSMA7  BZE  (XS),MSMA8
       MOV  *PRSI$,WA
       ZER  XL           JVK in case gbcol
       JSR  ALLOC        create a new pair
       MOV  =B$PRL,(XR)
       ZER  PRNXT(XR)
       MOV  XR,-(XS)     save it
       MOV  OFFS4(XS),XL  retrieve index
       MOV  XL,PRDOM(XR) place as domain elt
       MOV  OFFS3(XS),XR retrieve rhs
       MOV  OFFS2(XS),XL   and iterator
MSM71  JSR  NEXTS
       BNE  XR,=OMEGA,MSM72  skip om entries
       MOV  WA,XR        recover map
       BRN  MSM71
MSM72  MOV  XL,OFFS2(XS) update iter
       MOV  XR,XL
       MOV  (XS)+,XR     retrieve pair
       MOV  XL,PRRNG(XR) set range elt
       MOV  OFFS4(XS),XL retrieve map
       JSR  ADSEL        add new pair to map
       MOV  XL,OFFS4(XS) and update
       DCV  (XS)         decr counter
       BRN  MSMA7
*
MSMA8  ADD  *NUM04,XS    pop stack
       MOV  (XS)+,XR     retrieve map
       BRN  EXIXR
       EJC
*
*      Subscription -- entered via APPL2
*
*      Errors
*
ERSUB  ENT
       ERB  090,illegal type of subscripted expression
*
*      Map reference, single-valued
*      Return range value
*
MSSUB  ENT
       MOV  (XS)+,XL
*
*      (XL) might be map, even if type word is B$STL
*
       BEQ  (XL),=B$MPL,MSSU0 jump if known map
       MOV  XR,WA
       MOV  XL,XR
       JSR  CHKMP
       PPM  MSSU5
       ERB  193,subscripted set was not a map
*
MSSU5  MOV  XR,XL
       MOV  WA,XR
*
*      Any type is legal subscript except OM
*
MSSU0  BNE  XR,=OMEGA,MSSU1
       ERB  188,undefined subscript value
*
MSSU1  JSR  FINDD            find domain
       PPM  MSSU2            found
       PPM  EXIOM
       PPM  EXIOM
*
MSSU2  BLO  PRNXT(XR),DNAMB,MSSU3
       BRN  EXIOM            single ref to multi-val map undef
MSSU3  MOV  PRRNG(XR),XR
       BRN  EXIXR
       EJC
*
*      It appears to be legal to subscript OM
*      You get OM
*
OMSUB  ENT
       BRN  EXITS
       EJC
*
*      Tuple subscription
*      Select element
*
TPSUB  ENT
       MOV  (XS)+,XL
       BEQ  (XR),=B$ICL,TPSU1
       ERB  076,tuple subscript is not an integer
*
TPSU1  LDI  ICVAL(XR)
       ILE  TPSU3
       MFI  WA,EXIOM
       MOV  XL,XR
       JSR  TPELT
       PPM  EXIOM
       BRN  EXIXR
*
TPSU3  ERB  196,negative or zero tuple subscript
       EJC
*
*      Pair subscription -- like tuples
*
PRSUB  ENT
       MOV  (XS)+,XL
       BEQ  (XR),=B$ICL,PRSU1
       ERB  075,pair subscript is not an integer
PRSU1  LDI  ICVAL(XR)
       ILE  PRSU4
       SBI  INTV1
       IGT  PRSU3
       MOV  PRDOM(XL),XR     subscript = 1
       BRN  EXIXR
*
PRSU3  SBI  INTV1            try for range
       IGT  EXIOM            no - return OM
       MOV  PRRNG(XL),XR
       BRN  EXIXR
*
PRSU4  ERB  195,negative or zero pair subscript
       EJC
*
*      String subscription
*
SCSUB  ENT
       MOV  (XS),XL          get string block
       BEQ  (XR),=B$ICL,SCSU1
       ERB  074,string subscript is not an integer
*
SCSU1  LDI  ICVAL(XR)        get integer value
       ILE  SCSU2            only pos subscripts
       MFI  WB,EXIOM         check in range
       BGT  WB,SCLEN(XL),EXIOM
       DCV  WB               convert index to offset
       MOV  =NUM01,WA        target string size
       ZER  XL                 in case gbcol
       JSR  ALOCS            allocate target SCBLK
       MOV  (XS)+,XL         recover string block
       MOV  XR,-(XS)           and save target
       PSC  XR               prepare to store
       PLC  XL,WB              and load at given offset
       LCH  WA,(XL)          move the character
       SCH  WA,(XR)
       CSC  XR                 and clean up
       MOV  (XS)+,XR         recover target block
       BRN  EXIXR              and return
*
SCSU2  ERB  186,negative or zero string subscript
       EJC
*
*      TYPE is entered directly, being legal for everything but
*      OM.  Returns string giving datatype of object.
*
OPTYP  ENT
       MOV  (XS)+,XR         pop operand
       BEQ  XR,=OMEGA,OPTP1  error if OM
       JSR  DTYPE            find the type
       BRN  EXIXR
*
OPTP1  ERB  149,TYPE operator applied to OM
       EJC
*
*      VAL -- entered via APPX1
*
*      Returns numeric value of suitable strings
*
*      Errors
*
ERVAL  ENT
       BRN  XEVAL
*
*      Strings -- use an old SPITBOL procedure to do this
*
SCVAL  ENT
       ZER  WA
       JSR  GTNUM
       PPM  XEVAL
       BRN  EXIXR
*
       EJC
*
*      WITH -- entered via APPL2
*
*      Errors
*
ERWIT  ENT
       ERB  097,illegal or undefined left operand type for WITH
*
*      Map -- make sure new member is a pair
*
MPWIT  ENT
       ZER  WA
       MOV  (XS)+,XL         load the map
       JSR  ADSEL            add the element
       BNE  (XR),=B$PRL,MPW02 jump with non pair
MPW00  MOV  XL,XR
       BRN  EXIXR
*
*      Here left operand has ceased to be a map
*
MPW02  MOV  =B$STL,(XL)
       BRN  MPW00
       EJC
*
*
*      Pair -- must convert to tuple
*
PRWIT  ENT
       MOV  (XS)+,XL         get the pair
       MOV  XR,-(XS)         and save new element
       JSR  PRTUP            convert to TPBLK
       MOV  (XS)+,XL         recover new element
       MOV  XR,-(XS)         stack the TPBLK
       MOV  XL,XR            get element in right register
       MOV  =TPWIT,XL        get tuple entry point
       BRI  XL               pretend it was that all along
       EJC
*
*      Add an element to a set
*
STWIT  ENT
       ZER  WA
       MOV  (XS)+,XL         load set
       JSR  ADSEL
       MOV  XL,XR
       BRN  EXIXR
       EJC
*
*      Tuple -- add element at end of set
*
TPWIT  ENT
       MOV  (XS)+,XL         pop tuple
       MOV  TPNEL(XL),WA     get number of elements
       ICV  WA               next entry
       JSR  ADTEL            go add element
       MOV  XL,XR            copy tuple
       BRN  EXIXR
O$ERR  ENT
       ERB  298,internal error caused execution of O$ERR
*
*
       TTL  S E T L - S -- BLOCK ACTION ROUTINES
*
*      The first word of every block in dynamic storage and the
*      VRGET, VRSTO and VRTRA fields of a VRBLK contain a
*      pointer to an entry point in the program. All such entry
*      points are in the following section.
*
*      The entry points in this section have labels of the
*      form B$XXY where XX is the two character block type for
*      the corresponding block and Y is any letter.
*
*      In some cases, the pointers serve no other purpose than
*      to identify the block type. In this case the routine
*      is never executed and thus no code is assembled.
*
*      For each of these entry points corresponding to a block
*      an entry point identification is assembled (bl$xx).
*
*      The exact entry conditions depend on the manner in
*      which the routine is accessed and are documented with
*      the individual routines as required.
*
*      The order of these routines is alphabetical.
*      The symbol B$AAA defines the first location for block
*      routines and symbol B$YYY defines the last entry point.
*
B$AAA  ENT  BL$$I            Entry point of first block routine
       EJC
*
*      ACBLK
*
*      The routine for the action block is never entered.
*
B$ACT  ENT  BL$AC
*
*      ATBLK
*
*      The routine for an ATBLK is entered from the compiled
*      code to load an atom onto the stack.
*
B$ATL  ENT  BL$AT
       BRN  EXITS
       EJC
*
*      CCBLK
*
*      The routine for CCBLK is never entered
*
B$CCT  ENT  BL$CC            Entry point (CCBLK)
       EJC
*
*      CDBLK
*
*      The routine for a CDBLK is entered to execute the next
*      statement block.
*      (XR)                  ptr to CDBLK
*
B$CDS  ENT  BL$CD
       BRN  STMGO
*
*      CKBLK
*
*      The routine for a CKBLK is never entered
*
B$CHK  ENT  BL$CK
*
*      CMBLK
*
*      The routine for a CMBLK is never entered
*
B$CMT  ENT  BL$CM
       EJC
*
*      CTBLK
*
*      The routine for a CTBLK is never entered
*
B$CTT  ENT  BL$CT
       EJC
*
*      EFBLK
*
*      The routine for EFBLKs is not yet implemented - JVK
*
B$EFC  ENT  BL$EF
       ERB  025,Load ext funtions not yet implemented
*
*      ICBLK
*
*      The routine for ICBLK is executed from the generated
*      code to load an integer value onto the stack.
*
*      (XR)                  pointer to ICBLK
*
B$ICL  ENT  BL$IC            Entry point (ICBLK)
       BRN  EXIXR            Stack XR and obey next code word
       EJC
*
*      IOBLK
*
*      The routine for an IOBLK is never entered
*
B$IOT  ENT  BL$IO
*
*      LRBLK
*
*      The routine for a LRBLK is never entered
*
B$LRB  ENT  BL$LR
       EJC
*
*      LTBLK
*
*      The routine for a LTBLK is never entered
*
B$LTB  ENT  BL$LT
*
*      MPBLK
*
*      The routine for an MPBLK is entered from the
*      compiled code to load a map onto the stack.
*
B$MPL  ENT  BL$MP
       BRN  EXIXR
       EJC
*
*      OM
*
*      OM is a unique object of type BL$OM
*      The routine for OM is entered from the
*      compiled code to load the undefined value.
*
B$OML  ENT  BL$OM
       BRN  EXIXR
       EJC
*
*      PCBLK                  procedure
*
*      The routine for a PCBLK is entered to call a SETL-s
*      procedure.  On entry, the values of arguments to the
*      call are on the stack, and the next code-word contains
*      an argument count.  B$PCC stacks previous values of
*      locals and arguments, and also the code pointer for
*      return and the number of arguments supplied.
*
*      The PCBLK contains pointers into the static area.
*      PCARG points to the VRBLK for the first argument,
*      PCLOC points past the last VRBLK for locals.  These
*      VRBLKs will be contiguous, because staic is not allocated
*      except to VRBLKs, during parsing.  IT IS IMPORTANT THAT
*      THIS CONTINUE TO BE THE CASE.
*
       EJC
B$PCC  ENT  BL$PC
       CHK
       MOV  XS,PCSXS         save entry stack pointer
*
*      Start off by stacking pre-entry values of args and locs
*
       BNZ  PCSAV(XR),BPC01  jump if save pointer set (rec call)
       MOV  XS,PCSAV(XR)     first entry, set it here
*
*      Loop to stack values
*
BPC01  MOV  XR,XL
       MOV  PCARG(XL),XR     point to start
       MOV  PCLOC(XL),WA     point past end
       MOV  WA,PCSVL         save end pointer
BPC02  BGE  XR,WA,BPC03      jump if finished
       MOV  VRVAL(XR),-(XS)  stack value
       JSR  NXTVR            point to next VRBLK
       BRN  BPC02            loop
*
*      Set arguments to values supplied by caller
*
BPC03  MOV  XL,WB            JVK-keep PCBLK out of XL for translator-PC
       LCW  WA                   as LODSW uses same register as XL
       MOV  WB,XR            copy pointer back
       MOV  XR,PCSPC         save PCBLK
       MOV  PCSXS,XT         point to first argument value
       MOV  PCNAR(XR),PCSNA  and number of args expected
       ZER  WB               clear counter
       MOV  PCARG(XR),XR     point to arg VRBLK
BPC04  BGE  WB,WA,BPC05      jump if all unstacked
       BGE  WB,PCSNA,BPC06   jump if too many
       ICV  WB               count
       MOV  (XT)+,VRVAL(XR)  set a value
       JSR  NXTVR            point to next VRBLK
       BRN  BPC04
*
*      Here, all arguments are unstacked.
*      Check enough supplied, if not set trailing ones to OM
*
BPC05  BEQ  WB,PCSNA,BPC06   jump if all args set
       MOV  =OMEGA,VRVAL(XR) set to OM
       JSR  NXTVR            point to next
       ICV  WB               count this one
       BRN  BPC05
       EJC
*
*      Here we have initialised arguments.  XR points to the
*      first local VRBLK.  Re-initialise locals on a recursive
*      call.
*
BPC06  MOV  PCSPC,XL         reload PCBLK
       BEQ  PCSAV(XL),PCSXS,BPC08 jump on first call
       BGE  XR,PCSVL,BPC08   or if no locals
       MOV  PCSAV(XL),XT     point to save area
       MOV  PCSNA,WB         load number of args
       WTB  WB               convert to offset
       SUB  WB,XT            point to first local value
BPC07  MOV  -(XT),VRVAL(XR)
       JSR  NXTVR
       BLT  XR,PCSVL,BPC07   loop if more locals
*
*      Preserve vital link info on stack
*
BPC08  MOV  KVSTN,-(XS)      old statement number
       MOV  WA,-(XS)         number of args supplied
       MOV  PCSXS,-(XS)      old stack pointer
       SCP  WB               get code pointer value
       SUB  R$COD,WB         make relative
       MOV  WB,-(XS)         stack the offset
       MOV  R$COD,-(XS)      and CDBLK
       MOV  PCSPC,XR         point to PCBLK
       MOV  XR,-(XS)         save it
       MOV  PCCOD(XR),XR     point to CDBLK
       MOV  (XR),XL
       BRI  XL               enter procedure
       EJC
*
*      PFBLK
*
*      The routine for a PFBLK is never entered.
*
B$PFC  ENT  BL$PF
       EJC
*
*      PRBLK
*
*      The routine for a PRBLK is entered from the compiled code
*      to load a pair.
*
B$PRL  ENT  BL$PR
       BRN  EXIXR
       EJC
*
.IF    .CNRA
.ELSE
       EJC
*
*      RCBLK
*
*      The routine for an RCBLK is executed from the generated
*      code to load a real value onto the stack.
*
*      (XR)                  pointer to RCBLK
*
B$RCL  ENT  BL$RC            Entry point (RCBLK)
       BRN  EXIXR            Stack XR and obey next code word
.FI
       EJC
*
*      RUBLK
*
*      The routine for a RUBLK is never entered
*
B$RUL  ENT  BL$RU
*
*      SCBLK
*
*      The routine for an SCBLK is executed from the generated
*      code to load a string value onto the stack.
*
*      (XR)                  pointer to SCBLK
*
B$SCL  ENT  BL$SC            Entry point (SCBLK)
       BRN  EXIXR            Stack XR and obey next code word
       EJC
*
*      SNBLK
*
*      The routine for the SNBLK is never entered
*
B$SNM  ENT  BL$SN
*
*      STBLK
*
*      The routine for an STBLK is entered from the compiled
*      code to load a set.
*
B$STL  ENT  BL$ST
       BRN  EXIXR
       EJC
*
*      TPBLK
*
*      The routine for a TPBLK is entered from the compiled code
*      to load a tuple.
*
B$TPL  ENT  BL$TP
       BRN  EXIXR
       EJC
*
*
*      TVBLK
*
*      The routine for a TVBLK is executed from the code
*      to load either of the truth values TRUE and FALSE.
*
B$TVL  ENT  BL$TV
       BRN  EXIXR
       EJC
*
*      VCBLK
*
*      The routine for a VCBLK is never executed.
*
B$VCT  ENT  BL$VC            ENTRY POINT (VCBLK)
       EJC
*
*      VRBLK
*
*      Entry for VRGET. This routine is called
*      from the generated code to load the value of a variable.
*
*      (XR)                  points to VRGET field of VRBLK
*
B$VRL  ENT                   Entry point
       MOV  VRVAL(XR),-(XS)  load value onto stack (VRGET = 0)
       BRN  EXITS            Obey next code word
*
*      Entry for VRGET, read-only variable (constant)
*
B$VER  ENT
       ERB  333,attempt to store into a constant
*
*
*      Entry for VRSTO. This routine is called
*      from the generated code to store the value of a variable.
*
*      (XR)                  pointer to VRSTO field of VRBLK
*
B$VRS  ENT                   Entry point
       MOV  (XS),VRVLO(XR)   store value, leave on stack
       BRN  EXITS            Obey next code word
*
*      XNBLK
*
*      The routine for an XNBLK is never entered
*
B$XNT  ENT  BL$XN
*
*      XRBLK
*
*      The routine for an XRBLK is never entered
*
B$XRT  ENT  BL$XR
*
B$YYY  ENT  BL$$I            Last entry point
       EJC
       TTL  S E T L - S -- PREDEFINED SETL-S FUNCTIONS
*
*      The following section contains coding for functions
*      which are predefined and available at the SETL level.
*
*      These routines receive control directly from the code.
*      The conditions on entry are as follows where
*      the arguments are on the stack.
*
*      Control returns by placing the function result value
*      on the stack and continuing execution with the next
*      word from the generated code.
*
*      The names of the entry points of these functions are of
*      the form S$XXX where XXX is the three letter code for
*      the system variable name. The functions are in order
*      alphabetically by their entry names.
       EJC
*
*
*      ANY -- String primitive ANY(SS,PS)
*
S$ANY  ENT
       ICP                   discard arg count = 2
       MOV  (XS)+,XL         retrieve search string SS
       BNE  (XL),=B$SCL,XESPS must be string
       MOV  XL,R$PMS         save SS
       MOV  SCLEN(XL),PMSSL    and length
       MOV  (XS)+,XR         get pattern string PS
       BNE  (XR),=B$SCL,XESPP must be string
       MOV  SCLEN(XR),WA
       BZE  WA,FAILP         null string never matches
       BGT  WA,=NUM01,SANY3  jump if multi-char pattern
*
*      Here if single char pattern
*
       MOV  PMSSL,WC         get length of subject string
       ZER  WB               init cursor at left
       BZE  WC,FAILP         fail if SS empty
       PLC  XR
       LCH  WA,(XR)          get the character
       MOV  WA,PSCHR         and save it
       MOV  R$PMS,XL         retriev ss
       PLC  XL,WB            point to current char
       LCH  WA,(XL)          load CURRENT char
       BNE  WA,PSCHR,FAILP   fail if no match
       ICV  WB               else bump cursor
       BRN  SUCCP            and succeed
*
*      Here in multi-character pattern case
*
SANY3  JSR  PATCT            build CTBLK for PS
       MOV  PMSSL,WC         copy SS length
       ZER  WB               init cursor at left of SS
       BZE  WC,FAILP         fail if SS null
       MOV  R$PMS,XL         get SS again
       PLC  XL,WB            point to current char
       LCH  WA,(XL)          load current char
       WTB  WA               convert to byte offset
       MOV  R$CTP,XR         point to CTBLK
       ADD  WA,XR            point to CTBLK entry
       MOV  CTCHS(XR),WA     load CTBLK entry
       ANB  CTMSK,WA         AND with selected bit
       ZRB  WA,FAILP         fail if no match
       ICV  WB               else push cursor
       BRN  SUCCP
       EJC
*
*      ASSERT
*
*      Checks for Boolean arg.  Error if false.
*
S$AST  ENT
       ICP                   skip arg count (always 1)
       MOV  (XS)+,XR
       BNE  (XR),=B$TVL,SAST8 error if not boolean
       BEQ  XR,=TRUE$,EXITS  continue if true
       ERB  106,ASSERTION FAILED
SAST8  ERB  107,ASSERT arg not Boolean
*
*      BREAK -- String primitive BREAK(SS,PS)
*
S$BRK  ENT
       ICP                   discard arg count = 2
       MOV  (XS)+,XL         retrieve search string SS
       BNE  (XL),=B$SCL,XESPS must be string
       MOV  XL,R$PMS         save SS
       MOV  SCLEN(XL),PMSSL    and length
       MOV  (XS)+,XR         get pattern string PS
       BNE  (XR),=B$SCL,XESPP must be string
       MOV  SCLEN(XR),WA
       BZE  WA,FAILP         null string never matches
       BGT  WA,=NUM01,SBRK3  jump if multi-char pattern
*
*      Here if single char pattern
*
       MOV  PMSSL,WC         get length of subject string
       ZER  WB               init cursor at left
       BZE  WC,FAILP         fail if SS empty
       PLC  XR
       LCH  WA,(XR)          get the character
       MOV  WA,PSCHR         and save it
       MOV  R$PMS,XL         retriev ss
       PLC  XL,WB            point to current char
       LCT  WC,WC
*
*      Loop to scan matching chars
*
SBRK1  LCH  WA,(XL)+         load next char, bump ptr
       BEQ  WA,PSCHR,SUCCP   succeed if break char found
       ICV  WB               else push cursor
       BCT  WC,SBRK1         and loop unless end of string
       BRN  FAILP            fail at end, no break char
*
*      Here in multi-character pattern case
*
SBRK3  JSR  PATCT            build CTBLK for PS
       MOV  PMSSL,WC         copy SS length
       ZER  WB               init cursor at left of SS
       BZE  WC,FAILP         fail if SS null
       MOV  R$PMS,XL         get SS again
       PLC  XL,WB            point to current char
       LCT  WC,WC            set counter for nbr chars
*
*      Loop to scan matching chars
*
SBRK4  LCH  WA,(XL)+         load next char, bump ptr
       WTB  WA               convert to byte offset
       MOV  R$CTP,XR         point to CTBLK
       ADD  WA,XR            point to CTBLK entry
       MOV  CTCHS(XR),WA     load CTBLK entry
       ANB  CTMSK,WA         AND with selected bit
       NZB  WA,SUCCP         succeed if break char found
       ICV  WB               else push cursor
       BCT  WC,SBRK4
       BRN  FAILP            fail if end, no break char
       EJC
*
*      DATE
*
*      Returns a string, giving the date (see SYSDT description)
*
S$DAT  ENT
       JSR  SYSDT            get date pseudo-string
       MOV  SCLEN(XL),WA     load length
       MOV  XL,-(XS)
       JSR  ALOCS            allocate proper SCBLK
       MOV  (XS)+,XL
       MOV  WC,WA            copy back char count
       MOV  WA,SCLEN(XR)     set length of new block
       MOV  XR,WB            save pointer
       PLC  XL
       PSC  XR
       MVC
       CSC  XR
       MOV  WB,XR            point back at string
       BRN  EXIXR            exit with value
       EJC
*
*      EOF
*
*      Returns TRUE if last read gave endfile return
*
S$EOF  ENT
       LCW  XR              get nbr of args
       BNZ  XR,SEOF1        jump if file arg
*
*      No args means generic eof
*
       BNZ  EOFLG,EXTRU
       BRN  EXFAL
*
*      Here if file argument
*
SEOF1  MOV  (XS)+,XL        get arg
       MOV  XR,WA
       DCV  WA              got one arg
       WTB  WA
       ADD  WA,XS           ignore other args
       BNE  (XL),=B$SCL,SEOF8 file arg is string
       JSR  IOSRC           look up IOBLK
       PPM  SEOF9           error if not found
       BNZ  IOEOF(XR),EXTRU
       BRN  EXFAL
*
SEOF8  ERB  203,EOF file arg error
SEOF9  ERB  204,EOF file arg not found
       EJC
*
*      GET -- read strings from file
*
*      File argument string should be on stack.
*      Number of arguments is in (CP), followed by stores
*      into arguments.
*      S$GET gets the specified number of strings from input
*      and stacks them.
*
S$GET  ENT
       MOV  (XS)+,XL         retrieve file arg
       BNE  (XL),=B$SCL,SGET9 file arg is string
       JSR  IOSRC            get ioblk
       PPM  SGET9            fail branch
       MOV  XR,R$FIN         assign to input
       BNZ  IOUSE(XR),SGET9  error if open for output
       ZER  EOFLG
*
       LCW  XR               get arg count
       MOV  XR,XL
       MOV  XL,RDCNT         save count
SGET1  BZE  RDCNT,SGET3      done
       JSR  SCANG            fetch fresh input line
       MOV  XR,-(XS)         will be value
       DCV  RDCNT
       BRN  SGET1
*
SGET3  MOV  R$FIN,XR         retrieve ioblk
       MOV  R$RDI,IOINL(XR)  update nil input line
       MOV  SCXCP,IOOFS(XR)  and zero offset
       ZER  R$FIN            clear file ptr
       BRN  EXITS
*
SGET9  ERB  269,GET file arg error
       EJC
*
*      HOST
*
*      Set up for SYSHS host call.  Take arguments, if any,
*      from the stack.
*
S$HST  ENT
       LCW  XR               load argument count
       MOV  XR,WB              and save it
       MOV  =NULLS,WA        init all null args
       MOV  WA,XL
       MOV  WA,XR
       BZE  WB,SHST2         skip if no args
       MOV  (XS)+,WA         get first arg
       DCV  WB                 and count it
       BZE  WB,SHST2         check if 2nd arg
       MOV  (XS)+,XL
       DCV  WB
       BZE  WB,SHST2         check if 3rd arg
       MOV  (XS)+,XR
       DCV  WB
SHST1  BZE  WB,SHST2         if needed, discard other args
       ICA  XS
       DCV  WB
       BRN  SHST1
*
*      Currently only support null args, or arg1 = 1..4
*      due to error in SCOPS
*
SHST2  MOV  XL,WC            save arg
       MOV  WA,XL
       BNE  (XL),=B$ICL,SHST8  check first argument type
       BLE  ICVAL(XL),=NUM04,SHST8 accept only integers in 1..4
       ERB  257,This host function not yet supported
SHST8  MOV  WC,XL            restore XL
       JSR  SYSHS            ENTER SYSHS ROUTINE
       ERR  254,erroneous argument for HOST
       ERR  255,error during execution of HOST
       PPM  SHST3            STORE HOST STRING
       PPM  EXNUL            RETURN NULL RESULT
       PPM  EXIXR            RETURN XR
       ERR  256,fail return for HOST
*
*      RETURN HOST STRING
*
SHST3  BZE  XL,EXNUL         NULL STRING IF SYSHS UNCOOPERATIVE
       MOV  SCLEN(XL),WA     LENGTH
       ZER  WB               ZERO OFFSET
       JSR  SBSTR            BUILD COPY OF STRING
       BRN  EXIXR            RETURN RESULT ON STACK
       EJC
*
*      INPUT
*
*      Call IOPUT to select a file for subsequent input
*
S$INP  ENT
       LCW  XR               load arg count
       MOV  XR,WA            and copy it
       ZER  WB               i/o indicator is IN
       JSR  IOPUT            open file or whatever
       PPM  EXFAL            return FALSE if fails
       BRN  EXTRU            and return TRUE
*
*      LEN -- String primitive LEN(SS,N)
*
S$LEN  ENT
       ICP                   discard arg count = 2
       MOV  (XS)+,XL         retrieve string arg SS
       BNE  (XL),=B$SCL,XESPS
       MOV  XL,R$PMS         save subject string
       MOV  (XS)+,XR         get integer arg
       BNE  (XR),=B$ICL,XESPI
       LDI  ICVAL(XR)
       ILT  XESPN            error if 0 or neg
       STI  PMSSL            get N
       MOV  PMSSL,WB
       BLE  WB,SCLEN(XL),SUCCP success if N <= #SS
       BRN  FAILP            else return om, SS unchanged
*
*      LPAD -- String primitive LPAD(SS,N)
*
S$LPD  ENT
       LCW  XR               load arg count
       BNE  XR,=NUM02,XESPA  requires exactly 2 args
       MOV  (XS)+,XR         retrieve string arg SS
       BNE  (XR),=B$SCL,XESPS
       MOV  (XS)+,XL         get integer arg
       BNE  (XL),=B$ICL,XESPI
       LDI  ICVAL(XL)
       ILT  XESPN            error if neg
       MFI  WC,EXIOV         error if overflow
       BLE  WC,MXLEN,SLPD1   cannot pad past MXLEN
       ZER  WC               if attempted, reset
SLPD1  MOV  SCLEN(XR),WA
       BGE  WA,WC,EXIXR      return SS if too long to pad
       MOV  XR,XL
*
       MOV  =NULLS,XR        use null string for blank pad char
       PLC  XR               point to blank
       LCH  WB,(XR)
*
*      Now we are ready for the pad
*      (XL)                  pointer to the string to pad
*      (WB)                  pad char (blank)
*      (WC)                  length to pad string to
*
       MOV  WC,WA            copy length
       JSR  ALOCS            allocate scblk for new string
       MOV  XR,-(XS)         save as result
       MOV  SCLEN(XL),WA     load argument length
       SUB  WA,WC            calculate number of pad chars
       PSC  XR               point to start of chars in result string
       LCT  WC,WC
*
*      Loop to perform pad
*
SLPD2  SCH  WB,(XR)+         store pad char, bump ptr
       BCT  WC,SLPD2         loop till all pad chars stored
       CSC  XR               complete store
*
*      Now copy string
*
       BZE  WA,EXITS         exit if null string
       PLC  XL               else point to chars in arg
       MVC                   move all chars to result string
       BRN  EXITS
       EJC
*
*      MATCH -- String primitive MATCH(SS,PS)
*
S$MCH  ENT
       ICP                   discard arg count = 2
       MOV  (XS)+,XL         retrieve search string SS
       BNE  (XL),=B$SCL,XESPS must be string
       MOV  XL,R$PMS         save SS
       MOV  SCLEN(XL),PMSSL    and length
       MOV  (XS)+,XR         get pattern string PS
       BNE  (XR),=B$SCL,XESPP must be string
       MOV  XR,R$PPS         save PS
       MOV  SCLEN(XR),WA
       BGT  WA,PMSSL,FAILP   fail if #ps > #ss
       ZER  WB               init cursor at left
       JSR  SBSTR            get substring ss(1..#ps)
       MOV  XR,R$PSB         save result
       MOV  R$PPS,XL         get ps
       JSR  LCOMP            compare lexically
       PPM  FAILP
       PPM  SMCH1            succeed if equal
       PPM  FAILP
*
SMCH1  MOV  R$PSB,-(XS)      if equal, return substring
       MOV  R$PPS,XL         if equal, restore #ps
       MOV  SCLEN(XL),WB
       MOV  R$PMS,XL         retrieve ss
       MOV  PMSSL,WA
       SUB  WB,WA            compute length of remainder
       JSR  SBSTR            get ss(#ps+1 ..)
       ZER  R$PMS            in case gbcol
       ZER  R$PPS
       ZER  R$PSB
       BRN  EXIXR            return with new ss
       EJC
*
*      NEWAT
*
*      Allocate an ATBLK in static, and set its print
*      value from ATNUM
*
S$NAT  ENT
       MOV  *ATSI$,WA        load size of ATBLK
       JSR  ALOST            allocate static
       MOV  =B$ATL,(XR)      set type word
       LDI  ATNUM            load current print value
       STI  ATVAL(XR)
       ADI  INTV1            increment for nxt
       STI  ATNUM            store
       BRN  EXIXR
       EJC
*
*      NOTANY -- String primitive NOTANY(SS,PS)
*
S$NAY  ENT
       ICP                   discard arg count = 2
       MOV  (XS)+,XL         retrieve search string SS
       BNE  (XL),=B$SCL,XESPS must be string
       MOV  XL,R$PMS         save SS
       MOV  SCLEN(XL),PMSSL    and length
       MOV  (XS)+,XR         get pattern string PS
       BNE  (XR),=B$SCL,XESPP must be string
       MOV  SCLEN(XR),WA
       BZE  WA,FAILP         null string never matches
       BGT  WA,=NUM01,SNAY3  jump if multi-char pattern
*
*      Here if single char pattern
*
       MOV  PMSSL,WC         get length of subject string
       ZER  WB               init cursor at left
       BZE  WC,FAILP         fail if SS empty
       PLC  XR
       LCH  WA,(XR)          get the character
       MOV  WA,PSCHR         and save it
       MOV  R$PMS,XL         retriev ss
       PLC  XL,WB            point to current char
       LCH  WA,(XL)          load current char
       BEQ  WA,PSCHR,FAILP   fail if match
       ICV  WB               else bump cursor
       BRN  SUCCP            and succeed
*
*      Here in multi-character pattern case
*
SNAY3  JSR  PATCT            build CTBLK for PS
       MOV  PMSSL,WC         copy SS length
       ZER  WB               init cursor at left of SS
       BZE  WC,FAILP         fail if SS null
       MOV  R$PMS,XL         get SS again
       PLC  XL,WB            point to current char
       LCH  WA,(XL)          load current char
       WTB  WA               convert to byte offset
       MOV  R$CTP,XR         point to CTBLK
       ADD  WA,XR            point to CTBLK entry
       MOV  CTCHS(XR),WA     load CTBLK entry
       ANB  CTMSK,WA         AND with selected bit
       NZB  WA,FAILP         fail if char matched
       ICV  WB               else push cursor
       BRN  SUCCP            and succeed
       EJC
*
*      OUTPUT
*
*      Call IOPUT to open file for subsequent output
*      Return TRUE/FALSE for success/failure
*
S$OUT  ENT
       LCW  XR               load arg count
       MOV  XR,WA            and copy it
       MOV  =NUM03,WB        set i/o indicator to out
       JSR  IOPUT            establish association
       PPM  EXFAL            FALSE for failure
       BRN  EXTRU            and show success
*
*      PRINT
*
*      Arguments are on stack, and next codeword (CP)
*      cantains an argument count.
*
S$PRT  ENT
       LCW  XR               JVK get arg count PC mod
       MOV  XR,XL
       ZER  R$FOU
SPRT1  BZE  XL,SPRT2
       MOV  (XS)+,XR         get a argument
       JSR  STRGV
       JSR  PRTST
       DCV  XL
       BRN  SPRT1
*
SPRT2  JSR  PRTNL            print to outfile
       BRN  EXITS
*
*      PRINTA -- print to file
*
*      Arguments are on stack, and next codeword (CP)
*      cantains an argument count.
*
S$PTA  ENT
       LCW  XR               JVK get arg count PC mod
       MOV  XR,XL
       BZE  XL,SPTA4         jump if no file arg
       MOV  (XS)+,XL         get arg
       BNE  (XL),=B$SCL,SPTA3 file arg is string
       MOV  XR,-(XS)         save count
       JSR  IOSRC            get its IOBLK
       PPM  SPTA3            fail branch
       MOV  (XS)+,XL         retrieve count
       MOV  XR,R$FOU         assign to output
       BZE  IOUSE(XR),SPTA3  error if open for input
       DCV  XL
*
SPTA1  BZE  XL,SPTA2
       MOV  (XS)+,XR         get an argument
       JSR  STRGV
       JSR  PRTST
       DCV  XL
       BRN  SPTA1
*
SPTA2  JSR  PRTNL            print to outfile
       ZER  R$FOU            reset file ptr
       BRN  EXITS
*
SPTA3  DCV  XL               bad file arg
       WTB  XL
       ADD  XL,XS            discard others
       ZER  R$FOU            reset term output for error
SPTA4  ERB  271,PRINTA file arg error
*
*      PUT -- print strings to file
*
*      Arguments are on stack, and next codeword (CP)
*      cantains an argument count.
*
S$PUT  ENT
       LCW  XR               JVK get arg count PC mod
       MOV  XR,XL
       BZE  XL,SPUT4         jump if no file arg
       MOV  (XS)+,XL         get arg
       BNE  (XL),=B$SCL,SPUT3 file arg is string
       MOV  XR,-(XS)         save count
       JSR  IOSRC            get its IOBLK
       PPM  SPUT3            fail branch
       MOV  (XS)+,XL         retrieve count
       MOV  XR,R$FOU         assign to output
       BZE  IOUSE(XR),SPUT3  error if open for input
       DCV  XL
*
SPUT1  BZE  XL,SPUT2
       MOV  (XS)+,XR         get an argument
       BNE  (XR),=B$SCL,SPUT5 requires string args
       JSR  PRTST            fill buffer
       JSR  PRTNL            and print line
       DCV  XL
       BRN  SPUT1
*
SPUT2  ZER  R$FOU            reset file ptr
       BRN  EXITS
*
SPUT3  DCV  XL               bad file arg
       WTB  XL
       ADD  XL,XS            discard others
       ZER  R$FOU            reset term output for error
SPUT4  ERB  282,PUT file arg error
SPUT5  ERB  283,PUT argument not string type
*
*      RANY -- String primitive RANY(SS,PS)
*
S$RAN  ENT
       ICP                   discard arg count = 2
       MOV  (XS)+,XL         retrieve search string SS
       BNE  (XL),=B$SCL,XESPS must be string
       MOV  XL,R$PMS         save SS
       MOV  SCLEN(XL),PMSSL    and length
       MOV  (XS)+,XR         get pattern string PS
       BNE  (XR),=B$SCL,XESPP must be string
       MOV  SCLEN(XR),WA
       BZE  WA,FAILP         null string never matches
       BGT  WA,=NUM01,SRAN3  jump if multi-char pattern
*
*      Here if single char pattern
*
       MOV  PMSSL,WC         get length of subject string
       ZER  WB               count # matches
       BZE  WC,FAILP         fail if SS empty
       PLC  XR
       LCH  WA,(XR)          get the character
       MOV  WA,PSCHR         and save it
       MOV  R$PMS,XL         retriev ss
       DCV  WC               convert char # to offset
       PLC  XL,WC            point to current char
       LCH  WA,(XL)          load CURRENT char
       BNE  WA,PSCHR,FAILP   fail if no match
       ICV  WB               else bump cursor
       BRN  SUCRP            and succeed
*
*      Here in multi-character pattern case
*
SRAN3  JSR  PATCT            build CTBLK for PS
       MOV  PMSSL,WC         copy SS length
       ZER  WB               init cursor at left of SS
       BZE  WC,FAILP         fail if SS null
       MOV  R$PMS,XL         get SS again
       DCV  WC               convert char # to offset
       PLC  XL,WC            point to current char
       LCH  WA,(XL)          load current char
       WTB  WA               convert to byte offset
       MOV  R$CTP,XR         point to CTBLK
       ADD  WA,XR            point to CTBLK entry
       MOV  CTCHS(XR),WA     load CTBLK entry
       ANB  CTMSK,WA         AND with selected bit
       ZRB  WA,FAILP         fail if no match
       ICV  WB               else push cursor
       BRN  SUCRP
       EJC
*
*      RBREAK -- String primitive RBREAK(SS,PS)
*
S$RBR  ENT
       ICP                   discard arg count = 2
       MOV  (XS)+,XL         retrieve search string SS
       BNE  (XL),=B$SCL,XESPS must be string
       MOV  XL,R$PMS         save SS
       MOV  SCLEN(XL),PMSSL    and length
       MOV  (XS)+,XR         get pattern string PS
       BNE  (XR),=B$SCL,XESPP must be string
       MOV  SCLEN(XR),WA
       BZE  WA,FAILP         null string never matches
       BGT  WA,=NUM01,SRBR3  jump if multi-char pattern
*
*      Here if single char pattern
*
       MOV  PMSSL,WC         get length of subject string
       ZER  WB               init cursor at left
       BZE  WC,FAILP         fail if SS empty
       PLC  XR
       LCH  WA,(XR)          get the character
       MOV  WA,PSCHR         and save it
       MOV  R$PMS,XL         retriev ss
       PLC  XL,WC            point past right char
       LCT  WC,WC
*
*      Loop to scan matching chars
*
SRBR1  LCH  WA,-(XL)         load next char, bump ptr
       BEQ  WA,PSCHR,SUCRP   succeed if break char found
       ICV  WB               else push cursor
       BCT  WC,SRBR1         and loop unless end of string
       BRN  FAILP            fail at end, no break char
*
*      Here in multi-character pattern case
*
SRBR3  JSR  PATCT            build CTBLK for PS
       MOV  PMSSL,WC         copy SS length
       ZER  WB               init cursor at left of SS
       BZE  WC,FAILP         fail if SS null
       MOV  R$PMS,XL         get SS again
       PLC  XL,WC            point past right char
       LCT  WC,WC            set counter for nbr chars
*
*      Loop to scan matching chars
*
SRBR4  LCH  WA,-(XL)         load next char, bump ptr
       WTB  WA               convert to byte offset
       MOV  R$CTP,XR         point to CTBLK
       ADD  WA,XR            point to CTBLK entry
       MOV  CTCHS(XR),WA     load CTBLK entry
       ANB  CTMSK,WA         AND with selected bit
       NZB  WA,SUCRP         succeed if break char found
       ICV  WB               else push cursor
       BCT  WC,SRBR4
       BRN  FAILP            fail if end, no break char
       EJC
*
*      READ -- read from terminal
*
*      Number of arguments is in (CP), followed by stores
*      into arguments.
*      S$REA gets the specified number of items from input
*      and stacks them.
*      SCANX is used to get items, hence only works properly
*      for numbers and strings (quoted).  Updated for sets,
*      tuples, etc.
*
S$REA  ENT
       MOV  R$TRI,R$RDI      recover term input line
       MOV  TRXCP,SCXCP      current offset
       MOV  TRXIL,SCXIL      and line length
       ZER  EOFLG            fresh terminal read
       ZER  R$FIN            mark terminal input
       LCW  XR
       MOV  XR,XL
       MOV  XL,RDCNT         save count
S$RD0  BZE  RDCNT,S$RD1      done
       JSR  SCANX            fetch item
       MOV  XR,-(XS)         will be value
       DCV  RDCNT
       BRN  S$RD0
*
S$RD1  MOV  R$RDI,R$TRI      save input line and status
       MOV  SCXCP,TRXCP
       MOV  SCXIL,TRXIL
       BRN  EXITS
       EJC
*
*      READA -- read from file
*
*      File argument string should be on stack.
*      Number of arguments is in (CP), followed by stores
*      into arguments.
*      S$REA gets the specified number of items from input
*      and stacks them.
*      SCANX is used to get items, hence only works properly
*      for numbers and strings (quoted) or SETL objects
*
S$RDA  ENT
       MOV  (XS)+,XL         retrieve file arg
       BNE  (XL),=B$SCL,SRDA3 file arg is string
       JSR  IOSRC            get ioblk
       PPM  SRDA3            fail branch
       MOV  XR,R$FIN         assign to input
       BNZ  IOUSE(XR),SRDA3  error if open for output
       MOV  IOINL(XR),R$RDI  point to line
       MOV  IOOFS(XR),SCXCP  set up scanx offset
       MOV  R$RDI,XL
       MOV  SCLEN(XL),SCXIL  and line length
       ZER  EOFLG
*
       LCW  XR               get arg count
       MOV  XR,XL
       MOV  XL,RDCNT         save count
SRDA0  BZE  RDCNT,SRDA1      done
       JSR  SCANX            fetch item
       MOV  XR,-(XS)         will be value
       DCV  RDCNT
       BRN  SRDA0
*
SRDA1  MOV  R$FIN,XR         retrieve ioblk
       MOV  R$RDI,IOINL(XR)  save input line
       MOV  SCXCP,IOOFS(XR)  and offset
       ZER  R$FIN            clear file ptr
       BRN  EXITS
*
SRDA3  ERB  272,READA file arg error
       EJC
*
*      READL -- read line (get strings) from terminal
*
*      Number of arguments is in (CP), followed by stores
*      into arguments.
*      S$RDL gets the specified number of strings from input
*      and stacks them.
*
S$RDL  ENT
       ZER  EOFLG            not eof for terminal
       ZER  R$FIN
       LCW  XR               get arg count
       MOV  XR,XL
       MOV  XL,RDCNT         save count
SRDL1  BZE  RDCNT,SRDL3      done
       JSR  SCANG            fetch fresh input line
       MOV  XR,-(XS)         will be value
       DCV  RDCNT
       BRN  SRDL1
*
SRDL3  MOV  R$RDI,R$TRI
       MOV  SCXCP,TRXCP
       MOV  SCXIL,TRXIL
       BRN  EXITS
*
*      RLEN -- String primitive RLEN(SS,N)
*
S$RLN  ENT
       ICP                   discard arg count = 2
       MOV  (XS)+,XL         retrieve string arg SS
       BNE  (XL),=B$SCL,XESPS
       MOV  XL,R$PMS         save subject string
       MOV  (XS)+,XR         get integer arg
       BNE  (XR),=B$ICL,XESPI
       LDI  ICVAL(XR)
       ILT  XESPN            error if 0 or neg
       STI  PMSSL            get N
       MOV  PMSSL,WB
       BLE  WB,SCLEN(XL),SUCRP success if N <= #SS
       BRN  FAILP            else return om, SS unchanged
*
*      RMATCH -- String primitive RMATCH(SS,PS)
*
S$RMC  ENT
       ICP                   discard arg count = 2
       MOV  (XS)+,XL         retrieve search string SS
       BNE  (XL),=B$SCL,XESPS must be string
       MOV  XL,R$PMS         save SS
       MOV  SCLEN(XL),PMSSL    and length
       MOV  (XS)+,XR         get pattern string PS
       BNE  (XR),=B$SCL,XESPP must be string
       MOV  XR,R$PPS         save PS
       MOV  SCLEN(XR),WA
       BGT  WA,PMSSL,FAILP   fail if #ps > #ss
       MOV  PMSSL,WB         compute start char for match
       SUB  WA,WB
       JSR  SBSTR            get substring ss(#ss-#ps+1 ..)
       MOV  XR,R$PSB         save result
       MOV  R$PPS,XL         get ps
       JSR  LCOMP            compare lexically
       PPM  FAILP
       PPM  SRMC1            succeed if equal
       PPM  FAILP
*
SRMC1  MOV  R$PSB,-(XS)      if equal, return substring
       MOV  R$PPS,XL         if equal, restore #ps
       MOV  SCLEN(XL),WB
       MOV  R$PMS,XL         retrieve ss
       MOV  PMSSL,WA
       SUB  WB,WA            compute length of remainder
       ZER  WB               start at left of ps
       JSR  SBSTR            get ss(1 .. #ss-#ps)
       ZER  R$PMS            in case gbcol
       ZER  R$PPS
       ZER  R$PSB
       BRN  EXIXR            return with new ss
       EJC
*
*      RNOTANY -- String primitive RNOTANY(SS,PS)
*
S$RNA  ENT
       ICP                   discard arg count = 2
       MOV  (XS)+,XL         retrieve search string SS
       BNE  (XL),=B$SCL,XESPS must be string
       MOV  XL,R$PMS         save SS
       MOV  SCLEN(XL),PMSSL    and length
       MOV  (XS)+,XR         get pattern string PS
       BNE  (XR),=B$SCL,XESPP must be string
       MOV  SCLEN(XR),WA
       BZE  WA,FAILP         null string never matches
       BGT  WA,=NUM01,SRNA3  jump if multi-char pattern
*
*      Here if single char pattern
*
       MOV  PMSSL,WC         get length of subject string
       ZER  WB               init match counter
       BZE  WC,FAILP         fail if SS empty
       PLC  XR
       LCH  WA,(XR)          get the character
       MOV  WA,PSCHR         and save it
       MOV  R$PMS,XL         retrieve ss
       DCV  WC               convert char # to offset
       PLC  XL,WC            point to right char
       LCH  WA,(XL)          load current char
       BEQ  WA,PSCHR,FAILP   fail if match
       ICV  WB               else bump cursor
       BRN  SUCRP            and succeed
*
*      Here in multi-character pattern case
*
SRNA3  JSR  PATCT            build CTBLK for PS
       MOV  PMSSL,WC         copy SS length
       ZER  WB               init cursor at left of SS
       BZE  WC,FAILP         fail if SS null
       MOV  R$PMS,XL         get SS again
       DCV  WC               convert char # to offset
       PLC  XL,WC            point to current char
       LCH  WA,(XL)          load current char
       WTB  WA               convert to byte offset
       MOV  R$CTP,XR         point to CTBLK
       ADD  WA,XR            point to CTBLK entry
       MOV  CTCHS(XR),WA     load CTBLK entry
       ANB  CTMSK,WA         AND with selected bit
       NZB  WA,FAILP         fail if char matched
       ICV  WB               else push cursor
       BRN  SUCRP            and succeed
       EJC
*
*      RPAD -- String primitive RPAD(SS,N)
*
S$RPD  ENT
       LCW  XR               load arg count
       BNE  XR,=NUM02,XESPA  requires exactly 2 args
       MOV  (XS)+,XR         retrieve string arg SS
       BNE  (XR),=B$SCL,XESPS
       MOV  (XS)+,XL         get integer arg
       BNE  (XL),=B$ICL,XESPI
       LDI  ICVAL(XL)
       ILT  XESPN            error if neg
       MFI  WC,EXIOV         error if overflow
       BLE  WC,MXLEN,SRPD1   cannot pad past MXLEN
       ZER  WC               if attempted, reset
SRPD1  MOV  SCLEN(XR),WA
       BGE  WA,WC,EXIXR      return SS if too long to pad
       MOV  XR,XL
*
       MOV  =NULLS,XR        use null string for blank pad char
       PLC  XR               point to blank
       LCH  WB,(XR)
*
*      Now we are ready for the pad
*      (XL)                  pointer to the string to pad
*      (WB)                  pad char (blank)
*      (WC)                  length to pad string to
*
       MOV  WC,WA            copy length
       JSR  ALOCS            allocate scblk for new string
       MOV  XR,-(XS)         save as result
       MOV  SCLEN(XL),WA     load argument length
       SUB  WA,WC            calculate number of pad chars
       PSC  XR               point to start of chars in result string
       LCT  WC,WC
*
*      Copy argument string
*
       BZE  WA,SRPD2         jump if argument is null
       PLC  XL               else point to argument chars
       MVC                   move them to result string
*
*      Loop to perform pad
*
SRPD2  SCH  WB,(XR)+         store pad char, bump ptr
       BCT  WC,SRPD2         loop till all pad chars stored
       CSC  XR               complete store
       BRN  EXITS
       EJC
*
*      RSPAN -- String primitive RSPAN(SS,PS)
*
S$RSP  ENT
       ICP                   discard arg count = 2
       MOV  (XS)+,XL         retrieve search string SS
       BNE  (XL),=B$SCL,XESPS must be string
       MOV  XL,R$PMS         save SS
       MOV  SCLEN(XL),PMSSL    and length
       MOV  (XS)+,XR         get pattern string PS
       BNE  (XR),=B$SCL,XESPP must be string
       MOV  SCLEN(XR),WA
       BZE  WA,FAILP         null string never matches
       BGT  WA,=NUM01,SRSP3  jump if multi-char pattern
*
*      Here if single char pattern
*
       MOV  PMSSL,WC         get length of subject string
       ZER  WB               init cursor at left
       BZE  WC,FAILP         fail if SS empty
       PLC  XR
       LCH  WA,(XR)          get the character
       MOV  WA,PSCHR         and save it
       MOV  R$PMS,XL         retriev ss
       PLC  XL,WC            point past right char
       LCT  WC,WC
*
*      Loop to scan matching chars
*
SRSP1  LCH  WA,-(XL)         load next char, bump ptr
       BNE  WA,PSCHR,SRSP2   jump if no match
       ICV  WB               else push cursor
       BCT  WC,SRSP1         and loop unless end of string
*
*      Here after scanning matching chars
*
SRSP2  MOV  WB,WA            save nbr chars in result
       BNZ  WA,SUCRP         succeed if any chars matched
       BRN  FAILP
*
*      Here in multi-character pattern case
*
SRSP3  JSR  PATCT            build CTBLK for PS
       MOV  PMSSL,WC         copy SS length
       ZER  WB               init cursor at left of SS
       BZE  WC,FAILP         fail if SS null
       MOV  R$PMS,XL         get SS again
       PLC  XL,WC            point past right char
       LCT  WC,WC            set counter for nbr chars
*
*      Loop to scan matching chars
*
SRSP4  LCH  WA,-(XL)         load next char, bump ptr
       WTB  WA               convert to byte offset
       MOV  R$CTP,XR         point to CTBLK
       ADD  WA,XR            point to CTBLK entry
       MOV  CTCHS(XR),WA     load CTBLK entry
       ANB  CTMSK,WA         AND with selected bit
       ZRB  WA,SRSP5         jump if no match, stop scanning
       ICV  WB               else push cursor
       BCT  WC,SRSP4
*
*      Here after scanning matching chars
*
SRSP5  MOV  WB,WA            save nbr chars matching
       BNZ  WA,SUCRP         succeed if any chars matched
       BRN  FAILP
       EJC
*
*      SPAN -- String primitive SPAN(SS,PS)
*
S$SPN  ENT
       ICP                   discard arg count = 2
       MOV  (XS)+,XL         retrieve search string SS
       BNE  (XL),=B$SCL,XESPS must be string
       MOV  XL,R$PMS         save SS
       MOV  SCLEN(XL),PMSSL    and length
       MOV  (XS)+,XR         get pattern string PS
       BNE  (XR),=B$SCL,XESPP must be string
       MOV  SCLEN(XR),WA
       BZE  WA,FAILP         null string never matches
       BGT  WA,=NUM01,SSPN3  jump if multi-char pattern
*
*      Here if single char pattern
*
       MOV  PMSSL,WC         get length of subject string
       ZER  WB               init cursor at left
       BZE  WC,FAILP         fail if SS empty
       PLC  XR
       LCH  WA,(XR)          get the character
       MOV  WA,PSCHR         and save it
       MOV  R$PMS,XL         retriev ss
       PLC  XL,WB            point to current char
       LCT  WC,WC
*
*      Loop to scan matching chars
*
SSPN1  LCH  WA,(XL)+         load next char, bump ptr
       BNE  WA,PSCHR,SSPN2   jump if no match
       ICV  WB               else push cursor
       BCT  WC,SSPN1         and loop unless end of string
*
*      Here after scanning matching chars
*
SSPN2  BNZ  WB,SUCCP         succeed if any chars matched
       BRN  FAILP
*
*      Here in multi-character pattern case
*
SSPN3  JSR  PATCT            build CTBLK for PS
       MOV  PMSSL,WC         copy SS length
       ZER  WB               init cursor at left of SS
       BZE  WC,FAILP         fail if SS null
       MOV  R$PMS,XL         get SS again
       PLC  XL,WB            point to current char
       LCT  WC,WC            set counter for nbr chars
*
*      Loop to scan matching chars
*
SSPN4  LCH  WA,(XL)+         load next char, bump ptr
       WTB  WA               convert to byte offset
       MOV  R$CTP,XR         point to CTBLK
       ADD  WA,XR            point to CTBLK entry
       MOV  CTCHS(XR),WA     load CTBLK entry
       ANB  CTMSK,WA         AND with selected bit
       ZRB  WA,SSPN5         jump if no match, stop scanning
       ICV  WB               else push cursor
       BCT  WC,SSPN4
*
*      Here after scanning matching chars
*
SSPN5  BNZ  WB,SUCCP         succeed if any chars matched
       BRN  FAILP
       EJC
*
*      TIME
*
*      Returns an integer containing runtime in timer units
*      (This is, therefore, not the SETL TIME function)
*
S$TIM  ENT
       JSR  SYSTM
       BRN  EXINT
       EJC
       TTL  S E T L - S -- UTILITY PROCEDURES
*
*      The following section contains procedures which are
*      used for various purposes throughout the system.
*
*      Each procedure is preceded by a description of the
*      calling sequence. Usually the arguments are in registers
*      but arguments can also occur on the stack and as
*      parameters assembled after the JSR instruction.
*
*      The following considerations apply to these descriptions.
*
*      1)   The stack pointer (XS) is not changed unless the
*           change is explicitly documented in the call.
*
*      2)   Registers whose entry values are not mentioned
*           may contain any value except that XL,XR may only
*           contain proper (collectable) pointer values.
*           This condition on XR means that the called routine
*           may if it chooses preserve XR by stacking.
*
*      3)   Registers not mentioned on exit contain the same
*           values as they did on entry except that values in
*           XR,XL may have been relocated by the collector.
*
*      4)   Registers which are destroyed on exit may contain
*           any value except that values in XL,XR are proper
*           (collectable) pointers.
*
*      5)   The code pointer register points to the current
*           code location on entry and is unchanged on exit.
*
*      In the above description, a collectable pointer is one
*      which either points outside the dynamic region or
*      points to the start of a block in the dynamic region.
*
*      In those cases where the calling sequence contains
*      parameters which are used as alternate return points,
*      these parameters may be replaced by error codes
*      assembled with the ERR instruction. This will result
*      in the posting of the error if the return is taken.
*
*      The procedures all have names consisting of five letters
*      and are in alphabetical order by their names.
       EJC
*
*      ADSEL -- add element to a set
*
*      ADSEL is used by all set operations which require it
*      as the sole means of inserting an object into a set
*      or map.
*
*      (XR)                  element to be added
*      (XL)                  pointer to set-like object
*      JSR ADSEL
*      (XL)                  pointer to updated object
*      (WA,WB,WC)            destroyed
*
*      Duplicate entries are not created.
*      ADSEL also knows how to deal with pairs.
*
*      If a set has to be expanded, ADSEL will call
*      itself in copying the elements to a new block,
*      hence, it has to be an R-type procedure.
*
       EJC
ADSEL  PRC  R,0
       CHK
       BNE  XR,=OMEGA,ADS01
       ERB  234,attempt to add undefined element to set
*
*      If the set gets 80 percent full, we re-hash into a
*      larger one, to keep search lengths down
*
ADS01  MOV  STLEN(XL),WA     load length
       SUB  *STSI$,WA        convert to # slots
       BTW  WA
       MTI  WA               store length
       STI  ADSLN            save it
       MTI  STNEL(XL)        load number of elements
       MLI  INTVH            * 100
       DVI  ADSLN            calculate percentage (roughly)
       SBI  XPNPC            subtract optimum
       IGE  ADS06
*
*      OK to add to existing block, unless it turns
*      out that its full of dead entries, which didnt
*      get counted in preceding calculation.
*
ADS02  MOV  XL,-(XS)         stack the set
       BEQ  (XR),=B$PRL,ADS10 jump with pair
       BNE  (XR),=B$TPL,ADS99
       BNE  TPNEL(XR),=NUM02,ADS99
       JSR  TUPPR            if possible, convert tuple to pair
       BRN  ADS10
*
*      Here if element is not pair
*
ADS99  JSR  FINDS            look for element already present
       PPM  ADS17            jump if found
       PPM  ADS03            jump to update
       PPM  ADS05            jump to expand set
       EJC
*
*      Here to update - (XL) points to empty slot
*
ADS03  MOV  XR,(XL)          update
ADS04  MOV  (XS)+,XL         recover set
       MOV  =B$STL,(XL)      if map before, now set
       ICV  TPNEL(XL)        count new member
       EXI
*
*      Here we want to expand the set
*
ADS05  MOV  (XS)+,XL         recover if stacked
ADS06  MOV  XR,-(XS)         stack argument
       MOV  XL,-(XS)         and the set
       MOV  STLEN(XL),WA     get block size
       SUB  *STSI$,WA
       BTW  WA               JVK-how many slots now
       ICV  WA               make sure we get a bigger one
       JSR  ALOTS            allocate fresh block
       MOV  (XS),XL
       MOV  (XL),(XR)        set type word
       ZER  TPNEL(XR)        empty
*
*      Now put the elements of the old set into the new one
*
       MOV  XR,-(XS)         stack new block
       MOV  XL,XR            copy old one
       MOV  *STSI$,XL        initialise set offset
       BZE  STNEL(XR),ADS09  jump if old empty
*
ADS07  JSR  NEXTS            go for an element
       BNZ  WB,ADS09         jump if done
       BEQ  XR,=OMEGA,ADS08  dont copy OMs
       MOV  XL,-(XS)         save iterator variable
       MOV  OFFS1(XS),XL         recover new STBLK
       JSR  ADSEL            add this element
       MOV  XL,OFFS1(XS)         and update set if needed
       MOV  (XS)+,XL         get iterator variable
ADS08  MOV  OFFS1(XS),XR         and old set
       BRN  ADS07
*
*      Here when all done
*
ADS09  MOV  (XS)+,XL         unstack new set
       ICA  XS               throw away old
       MOV  (XS)+,XR         reload argument
       BRN  ADS02            try again
       EJC
*
*      Here to add a pair
*
ADS10  MOV  XR,-(XS)         stack the pair
       MOV  PRDOM(XR),XR     load domain value
       JSR  FINDD            look for domain
       PPM  ADS13            found chain for it
       PPM  ADS12            not there at all
       PPM  ADS11            full
*
*      If full, forget we have a pair, for now, and
*      merge with ordinary case to expand the set
*
ADS11  MOV  (XS)+,XR         fetch OK version of pair
       BRN  ADS05            merge
*
*      If we couldnt find it, perform update, being
*      careful to get the end condition right for
*      easy iterating.
*
ADS12  MOV  (XS)+,XR         get new member
       MOV  XR,(XL)          update set
       ICA  XL               point to next slot (off end ok)-JVK word
       MOV  XL,PRNXT(XR)     use as link field
       MOV  (XS)+,XL         recover set
       SUB  XL,PRNXT(XR)     make link relative
       ICV  MPNEL(XL)        count new member
       EXI
       EJC
*
*      Here we found a chain - look for our pair
*
ADS13  MOV  (XS)+,XR         reload argument
       MOV  (XL),XL          point to first on chain
*
ADS14  JSR  COMPV            look for match
       PPM  ADS17            yes
       PPM  ADS15            no
ADS15  BLE  PRNXT(XL),MXLEN,ADS16 exit if last on chain
       MOV  PRNXT(XL),XL     else point to next
       BRN  ADS14            and try again
*
*      Here we reached end of chain with no luck
*
ADS16  MOV  PRNXT(XL),PRNXT(XR) migrate end
       MOV  XR,PRNXT(XL)     add new member
       BRN  ADS04            merge to exit
*
*      Exit here if element was already present
*
ADS17  MOV  (XS)+,XL         recover set
       EXI
       ENP
       EJC
*
*      ADTEL -- add tuple element
*
*      ADTEL adds an element to a tuple at a required position
*      expanding the tuple if necessary.  It also checks for
*      assignment of OM to last element and adjusts the
*      cardinality if necessary
*
*      (XL)                  Pointer to TPBLK
*      (XR)                  Element to be added
*      (WA)                  Index
*      JSR  TPELT
*      (XL)                  Pointer to modified TPBLK
*      (WA, WB, WC)              Destroyed
*
ADTEL  PRC  E,0
       BGT  WA,TPNEL(XL),ADTL1 jump if exceeds cardinality
       BNE  WA,TPNEL(XL),ADTL2 jump if ok
       BEQ  XR,=OMEGA,ADTL3  jump if fiddly
*
*      Here with straightforward modification
*
ADTL2  WTB  WA               get BAU offset
       ADD  *TPNEL,WA
       MOV  XL,-(XS)         save XL
       ADD  WA,XL            add the offset
       MOV  XR,(XL)          update
       MOV  (XS)+,XL         restore
ADTL0  EXI
       EJC
*
*      Here if past current highest
*
ADTL1  BEQ  XR,=OMEGA,ADTL0  if omega past end, no change
       MOV  WA,WB            copy index
       WTB  WB               compute offset
       ADD  *TPNEL,WB
       BGE  WB,TPLEN(XL),ADTL4 jump if not enough room
       MOV  WA,TPNEL(XL)     else update NEL field
       BRN  ADTL2            merge to do update
*
*      Here we need a new TPBLK
*
ADTL4  MOV  XR,-(XS)         save XR
       MOV  XL,-(XS)         and XL
       JSR  ALOTS            get block
       MOV  TPLEN(XR),WC
       MOV  WA,WB            save index
       MOV  (XS),XL          retrieve XL
       MOV  TPLEN(XL),WA     load length
       MVW                   copy entire old tuple
       MOV  XR,XL            get pointer to new version
       MOV  (XS)+,XR          retrieve old TPBLK
       SUB  TPLEN(XR),XL     point back to start of new
       MOV  WC,TPLEN(XL)
       MOV  WB,TPNEL(XL)     update cardinality
       MOV  WB,WA
       MOV  (XS)+,XR         retrieve item to add
       BRN  ADTL2            merge to do update
       EJC
*
*      Here if OM assignment affects cardinality
*
ADTL3  MOV  XL,XR            copy TPBLK pointer
       WTB  WA               get offset
       ADD  *TPNEL,WA
       ADD  WA,XR            point to entry
       MOV  =OMEGA,(XR)
*
*      Now loop backwards, looking for non OM element
*
       ADD  *TPNEL,XL        point to first entry
ADTL5  DCA  XR               point to preceding element
       BEQ  (XR),=OMEGA,ADTL5 loop with another OM
*
*      Here we have it
*
       SUB  XL,XR            Get offset
       BTW  XR               Convert to words
       SUB  *TPNEL,XL        Point back to start
       MOV  XR,TPNEL(XL)     set cardinality
       MOV  =OMEGA,XR        restore for sentimental value
       EXI
       ENP
       EJC
*
*      ALLOC                 allocate block of dynamic storage
*
*      (WA)                  length required in BAUS
*      JSR  ALLOC            call to allocate block
*      (XR)                  pointer to allocated block
*
*      A possible alternative to AOV .. and following stmt is -
*      MOV  DNAME,XR .  SUB  WA,XR .  BLO XR,DNAMP,aloc2 .
*      MOV  DNAMP,XR .  ADD  WA,XR
*
ALLOC  PRC  E,0              Entry point
.IF    .CDBG
       BLT  STAGE,=DBSTG,ALOC1 jump if not reached stage
       ICV  ALDBC            count entry
       BLT  ALDBC,DBFRQ,ALOC1 jump if not time yet
       ZER  ALDBC            clear count
       BRN  ALOC2            go do collection
.FI
*
*      Common exit point
*
ALOC1  MOV  DNAMP,XR         Point to next available loc
       AOV  WA,XR,ALOC2      Point past allocated block
       BGT  XR,DNAME,ALOC2   Jump if not enough room
       MOV  XR,DNAMP         Store new pointer
       SUB  WA,XR            Point back to start of allocated bk
       EXI                   Return to caller
*
*      Here if insufficient room, try a garbage collection
*
ALOC2  MOV  WB,ALLSV         Save WB
ALC2A  ZER  WB               Set no upward move for GBCOL
       JSR  GBCOL            Garbage collect
.IF    .CSED
       MOV  XR,WB            Remember new sediment size
.FI
*
*      See if room after GBCOL or SYSMM call
*
ALOC3  MOV  DNAMP,XR         Point to first available loc
       AOV  WA,XR,ALC3A      Point past new block
       BLO  XR,DNAME,ALOC4   Jump if there is room now
*
*      Failed again, see if we can get more core
*
ALC3A  JSR  SYSMM            Try to get more memory
       WTB  XR               Convert to BAUS (SGD05) JVK
       ADD  XR,DNAME         Bump ptr by amount obtained
       BNZ  XR,ALOC3         Jump if got more core
.IF    .CSED
       BZE  DNAMS,ALC3B      Jump if there was no sediment
       ZER  DNAMS            Try collecting the sediment
       BRN  ALC2A
*
*      SYSMM failed and there was no sediment to collect
*
ALC3B  ADD  RSMEM,DNAME      Get the reserve memory
.ELSE
       ADD  RSMEM,DNAME      Get the reserve memory
.FI
       ZER  RSMEM            Only permissible once
       ICV  ERRFT            Fatal error
       ERB  160,memory overflow
       EJC
*
*      Here after successful garbage collection
*
ALOC4  STI  ALLIA            Save IA
.IF    .CSED
       MOV  WB,DNAMS         Record new sediment size
.FI
       MOV  DNAME,WB         Get dynamic end adrs
       SUB  DNAMP,WB         Compute free store
       BTW  WB               Convert BAUS to words
       MTI  WB               Put free store in IA
       MLI  ALFSF            Multiply by free store factor
       IOV  ALOC5            Jump if overflowed
       MOV  DNAME,WB         Dynamic end adrs
       SUB  DNAMB,WB         Compute total amount of dynamic
       BTW  WB               Convert to words
       MOV  WB,ALDYN         Store it
       SBI  ALDYN            Subtract from scaled up free store
       IGT  ALOC5            Jump if sufficient free store
       JSR  SYSMM            Try to get more store
       ADD  XR,DNAME         Adjust dynamic end adrs
*
*      Merge to restore IA and WB
*
ALOC5  LDI  ALLIA            Recover IA
       MOV  ALLSV,WB         Restore WB
       BRN  ALOC1            Jump back to exit
       ENP                   End procedure ALLOC
       EJC
*
*      ALOCS -- allocate string block
*
*      ALOCS is used to build a frame for a string block into
*      which the actual characters are placed by the caller.
*      All strings are created with a call to ALOCS (the
*      exception occurs in TRIMR).
*
*      (WA)                  length of string to be allocated
*      JSR  ALOCS            call to allocate SCBLK
*      (XR)                  pointer to resulting SCBLK
*      (WA)                  destroyed
*      (WC)                  character count (entry value of WA)
*      (XL)                  JVK-destroyed for gbcol
*
*      The resulting SCBLK has the type word and the length
*      filled in and the last word is cleared to zero characters
*      to ensure correct right padding of the final word.
*
ALOCS  PRC  E,0              Entry point
       BGT  WA,MXLEN,ALCS2   Jump if length exceeeds maxlength
       MOV  WA,WC            Else copy length
       CTB  WA,SCSI$         Compute length of SCBLK in BAUS
       MOV  DNAMP,XR         Point to next available location
       AOV  WA,XR,ALCS0      Point past block
       BLO  XR,DNAME,ALCS1   Jump if there is room
*
*      Insufficient memory
*
ALCS0  ZER  XR               Else clear garbage XR value
       ZER  XL               JVK-clear for gbcol
       JSR  ALLOC            And use standard allocator
       ADD  WA,XR            Point past end of block to merge
*
*      Merge here with XR pointing beyond new block
*
ALCS1  MOV  XR,DNAMP         Set updated storage pointer
       ZER  -(XR)            Store zero chars in last word
       DCA  WA               Decrement length
       SUB  WA,XR            Point back to start of block
       MOV  =B$SCL,(XR)      Set type word
       MOV  WC,SCLEN(XR)     Store length in chars
       EXI                   Return to ALOCS caller
*
*      Come here if string is too long
*
ALCS2  ERB  159,string length exceeds MAXLN
       ENP                   End procedure ALOCS
       EJC
*
*      ALOST -- allocate space in static region
*
*      (WA)                  length required in BAUS
*      JSR  ALOST            call to allocate space
*      (XR)                  pointer to allocated block
*      (WB)                  destroyed
*
*      Note that the coding ensures that the resulting value
*      of STATE is always less than DNAMB. This fact is used
*      in testing a variable name for being in the static region
*
ALOST  PRC  E,0              Entry point
*
*      Merge back here after allocating new chunk
*
ALST1  MOV  STATE,XR         Point to current end of area
       AOV  WA,XR,ALST2      Point beyond proposed block
       BGE  XR,DNAMB,ALST2   Jump if overlap with dynamic area
       MOV  XR,STATE         Else store new pointer
       SUB  WA,XR            Point back to start of block
       EXI                   Return to ALOST caller
*
*      Here if no room, prepare to move dynamic storage up
*
ALST2  MOV  WA,ALSTA         Save WA
       BGE  WA,*E$STS,ALST3  Skip if requested chunk is large
       MOV  *E$STS,WA        Else set to get large enough chunk
*
*      Here with amount to move up in WA
*
ALST3  ZER  XL
       JSR  ALLOC            Allocate block to ensure room
       MOV  XR,DNAMP         And delete it
       MOV  WA,WB            Copy move up amount
       JSR  GBCOL            Call GBCOL to move dynamic area up
.IF    .CSED
       MOV  XR,DNAMS         Remember new sediment size
.FI
       MOV  ALSTA,WA         Restore WA
       BRN  ALST1            Loop back to try again
       ENP                   End procedure ALOST
       EJC
*
*      ALOTS -- allocate block for a tuple or set
*
*      ALOTS is used to set up a block to hold a tuple, set
*      or map.  It determines the appropriate size and
*      initialises the length and cardinality words, and fills
*      the rest of the block with OMs.  The caller has to set
*      the type word and insert the values
*
*      (WA)                  Number of elements
*      JSR  ALOTS
*      (XR)                  Pointer to block allocated
*      (WB, XL)              Destroyed
*
ALOTS  PRC  E,0
       MOV  WA,WB            JVK-check block size needed
       WTB  WB
       ADD  *TSSI$,WB
       BGT  WB,MXLEN,ALTS1   jump if too many elements
       MOV  WA,WB            copy number of elements
       MOV  =TSNEN,WA        load minimum size
*
*      We determine the required size by doubling the
*      value in WA and adding one, until it exceeds the
*      number of elements.  This means the sizes go up -
*      11, 23, 47, 95, 191, 383 ... most of which are
*      primes - a good thing for hashing into.
*
ALTS2  BLE  WB,WA,ALTS3      jump if big enough
       ADD  WA,WA            compute ...
       ICV  WA               ..next size
       BRN  ALTS2
*
*      Here with required number of elements in WA
*
ALTS3  WTB  WA               compute block length
       ADD  *TSSI$,WA
       BGT  WA,MXLEN,ALTS1   jump if too big
       ZER  XL               JVK-prep gbcol
       JSR  ALLOC            use standard allocator to get block
       MOV  XR,XL            copy pointer
       ADD  WA,XL
*
*      Loop to set OM values in block - lazy way is to set
*      all of them - there being no harm in it
*
ALTS4  MOV  =OMEGA,-(XL)     set a value
       BLT  XR,XL,ALTS4      jump to set more
*
       MOV  WB,OFFS2(XR)     set number of elements
       MOV  WA,OFFS1(XR)     and length
       ZER  XL               clear possible crud value
       MOV  WB,WA            restore for caller
       EXI
*
ALTS1  ERB  199,length of tuple or set exceeds MAXLEN
       ENP
       EJC
*
*      BLKLN determines the length of a block in dynamic store.
*
*      (WA)                  first word of block
*      (XR)                  pointer to block
*      JSR  BLKLN            call to get block length
*      (WA)                  length of block in BAUS
*      (XL)                  destroyed
*
*      BLKLN is used by the garbage collector and is not
*      permitted to call GBCOL directly or indirectly.
*
*      The first word stored in the block (i.e. at XR) may
*      be anything, but the contents of WA must be correct.
*
BLKLN  PRC  E,0              Entry point
       MOV  WA,XL            Copy first word
       LEI  XL               Get entry id (bl$xx)
       BSW  XL,BL$$$,BLN00   Switch on block type
       IFF  BL$CD,BLN01      CDBLK
       IFF  BL$AT,BLN06      ATBLK
       IFF  BL$IC,BLN07      ICBLK
.IF    .CNRA
.ELSE
       IFF  BL$RC,BLN09      RCBLK
.FI
       IFF  BL$SC,BLN10      SCBLK
       IFF  BL$AC,BLN11      ACBLK
       IFF  BL$CK,BLN12      CKBLK
       IFF  BL$CT,BLN19      CTBLK
       IFF  BL$EF,BLN01      EFBLK
       IFF  BL$RU,BLN13      RUBLK
       IFF  BL$SN,BLN14      SNBLK
       IFF  BL$LT,BLN15      LTBLK
       IFF  BL$LR,BLN16
       IFF  BL$PR,BLN16
       IFF  BL$IO,BLN18      IOBLK
       IFF  BL$PC,BLN17      PCBLK
       IFF  BL$PF,BLN20      PFBLK
       IFF  BL$VC,BLN01      VCBLK
       ESW                   End of jump table on block type
       EJC
*
*      BLKLN (continued)
*
*      Here for blocks with length in second word
*
BLN00  MOV  OFFS1(XR),WA         Load length
       EXI                   Return to BLKLN caller
*
*      Here for length in third word
*
BLN01  MOV  OFFS2(XR),WA         Load length from third word
       EXI                   Return to BLKLN caller
*
*      Here for five word blocks
*
BLN05  MOV  *NUM05,WA        Load length
       EXI                   Return to BLKLN caller
*
*      Here for ATBLK
*
BLN06  MOV  *ATSI$,WA        set size of ATBLK
       EXI
*
*      Here for ICBLK
*
BLN07  MOV  *ICSI$,WA        Set size of ICBLK
       EXI                   Return to BLKLN caller
*
.IF    .CNRA
.ELSE
*
*      Here for RCBLK
*
BLN09  MOV  *RCSI$,WA        Set size of RCBLK
       EXI                   Return to BLKLN caller
.FI
       EJC
*
*      Here for SCBLK
*
BLN10  MOV  SCLEN(XR),WA     Load length in characters
       CTB  WA,SCSI$         Calculate length in BAUS
       EXI                   Return to BLKLN caller
*
*      Here for an ACBLK
*
BLN11  MOV  *ACSI$,WA
       EXI
*
*      Here for an CKBLK
*
BLN12  MOV  *CKSI$,WA
       EXI
*
*      Here for an RUBLK
*
BLN13  MOV  *RUSI$,WA
       EXI
*
*      Here with the SNBLK
*
BLN14  MOV  *SNSI$,WA
       EXI
*
*      Here for a LTBLK
*
BLN15  MOV  *LTSI$,WA
       EXI
*
*      And here for 4 word blocks
*
BLN16  MOV  *NUM04,WA
       EXI
*
*
*      PCBLK
*
BLN17  MOV  *PCSI$,WA
       EXI
*
*      IOBLK
*
BLN18  MOV  *IOSI$,WA
       EXI
*
*      CTBLK char table
*
BLN19  MOV  *CTSI$,WA
       EXI
*
*      PFBLK profiler block
*
BLN20  MOV  *PFSI$,WA
       EXI
*
       ENP                   End procedure BLKLN
       EJC
*
*      CDGEN -- generate code for a tree node
*
*      (XR) ptr to tree node
*      JSR  CDGEN
*
CDGEN  PRC  R,0
       CHK
*
       BZE  XR,CDGXX
       BEQ  XR,=WTQUI,CDG03  jump with Quit
       BEQ  XR,=WTCNT,CDG04  jump with Continue
       BEQ  (XR),=B$CMT,CDG01 jump with CMBLK
*
*      Otherwise, we have a leaf, and want to generate a
*      word of code for it
*
       MOV  XR,WA            load word
       JSR  CDWRD            generate code
CDGXX  EXI
*
*      Here with CMBLKs
*
CDG01  MOV  XR,-(XS)         stack block pointer
       MOV  CMTYP(XR),XL     load the type
*
*      Switch on CMBLK type
*
       BSW  XL,C$$$$,CDG02
       IFF  C$EXP,CDG08
       IFF  C$STM,CDG07
       IFF  C$IFS,CDG15
.IF    .CNPF
.ELSE
       IFF  C$TVO,CDA15
.FI
       IFF  C$LUP,CDG18
       IFF  C$BOP,CDG09
       IFF  C$UOP,CDG10
       IFF  C$ASS,CDG11
       IFF  C$CMP,CDB50
.IF    .CNPF
       IFF  C$SET,CDG80
       IFF  C$TUP,CDG80
.ELSE
       IFF  C$SET,CDA80
       IFF  C$TUP,CDA81
.FI
       IFF  C$EXR,CDG60
       IFF  C$SUB,CDA07    subscr
       IFF  C$SBM,CDA07    curly sub map ref
       IFF  C$SLC,CDA07    slice
       IFF  C$YLD,CDG61
       IFF  C$IOS,CDG65
       IFF  C$EQN,CDG40
       IFF  C$AQN,CDG41
.IF    .CNPF
       IFF  C$NQN,CDG41
.ELSE
       IFF  C$NQN,CDG42
.FI
       IFF  C$CAS,CDG50
       IFF  C$CAL,CDG91    proc call
       IFF  C$RTN,CDG95    return
       ESW
*
CDG02  ERB  297,internal error in CDGEN
       EJC
*
*      Here to generate the jumps for QUIT and CONTINUE
*      (Only one level supported)
*
.IF    .CNPF
CDG03  MOV  QUITL,XL         Get QUIT label
.ELSE
CDG03  MOV  =SCQUI,-(XS)
       MOV  QUITL,XL         Get QUITlabel
.FI
       JSR  GPOPL
       BRN  CDG05            merge to check
*
.IF    .CNPF
CDG04  MOV  CONTL,XL         Get CONTINUE label
.ELSE
CDG04  MOV  =SCCNU,-(XS)
       MOV  CONTL,XL         Get CONTINUE label
.FI
CDG05  BNZ  XL,CDG06         make sure its set
       ERB  077,QUIT or CONTINUE not inside loop
*
CDG06  ZER  XR               unconditional jump
.IF    .CNPF
       JSR  LABRF            compile it
.ELSE
       JSR  GENPF
       JSR  LABRF
       MOV  (XS)+,XL
       JSR  PRTWD
.FI
       EXI
       EJC
*
*      Here to generate code for a
*      statement list
*
CDG07  MOV  CMLHD(XR),XR     get the head
       JSR  CDGEN
       MOV  (XS),XR          recover CMBLK
       MOV  CMLHD(XR),XL     look at statement
       JSR  CHKST            adjust stack if necessary
       ZER  CMLHD(XR)        prune the tree
*
*      Generate an instruction between statements
*
       MOV  =O$STM,WA
       JSR  CDWRD
       ICV  CDGSN
       MOV  CMLTL(XR),XR     get tail
       JSR  CDGEN
       MOV  (XS)+,XR         pop tree ptr
       MOV  CMLTL(XR),XL     look at final statement
       JSR  CHKST
       ZER  CMLTL(XR)        prune it
       EXI
       EJC
*
*      Here to generate code for an expression list.
*      The expressions are generated in reverse order
*      which means that after stacking and unstacking
*      they are the right way round again - if you see
*      what I mean.  Copies expression as needed (for VRBLKs, etc)
*      when loading, for proc parameters and set and tuple formers.
*
CDG08  MOV  CMLTL(XR),XR     tail first
       MOV  XR,-(XS)         save it
       JSR  CDGEN
       MOV  (XS)+,XL         recover tail
       JSR  CHKCP            see if copy needed
       PPM  CDJ08
       MOV  =O$COP,WA
       JSR  CDWRD
CDJ08  MOV  (XS),XR          recover list
*       ZER  CMLTL(XR)        chop off tail  NO-JVK
       MOV  CMLHD(XR),XR     now the head
       MOV  XR,-(XS)
       JSR  CDGEN
       MOV  (XS)+,XL         recover head
       JSR  CHKCP            see if copy needed
       PPM  CDJ09
       MOV  =O$COP,WA
       JSR  CDWRD
CDJ09  MOV  (XS)+,XR
*       ZER  CMLHD(XR)        decapitate it  NO-JVK
       EXI
*
*      Subscripted expression - just a binary op really
*
CDA07  MOV  CMSXP(XR),XR
       JSR  CDGEN
       MOV  (XS),XR
       MOV  CMSBS(XR),XR
       JSR  CDGEN
       MOV  (XS)+,XR
       BEQ  CMTYP(XR),=C$SBM,CDA08    subscr map
       BEQ  CMTYP(XR),=C$SLC,CDB09    slice
       MOV  =O$SUB,WA
       JSR  CDWRD
       EXI
*
CDA08  MOV  =O$SBM,WA        subscripted map - curly
       JSR  CDWRD
       EXI
*
*      For slice ref, need 3rd operand
*
CDB09  MOV  CMSLE(XR),XR     get end subscript
       BZE  XR,CDB10         jump if t(a..)
       JSR  CDGEN
       BRN  CDB11
*
*      For t(a..) form t(a..#t)
*
CDB10  MOV  =TMPL1,WA        copy of t
       JSR  CDWRD
       MOV  =O$NUM,WA        form #t
       JSR  CDWRD
*
CDB11  MOV  =O$SLC,WA        merge for slice ref
       JSR  CDWRD
       EXI
*
*      Here with a binary operator and its operands
*      Assigning ops, except straight assignment, merge
*
CDG09  MOV  CMLOP(XR),XR     get the left operand
       JSR  CDGEN
       MOV  (XS),XR          recover CMBLK
       BNE  CMOPR(XR),=O$QMK,CDX11 jump unless ? oper
*
*      Here for ? operator
*
       JSR  NXTLB            get a label
       MOV  WA,-(XS)           and save it
       MOV  =JNOMG,XR        jump if not omega
       MOV  WA,XL
       JSR  LABRF
       MOV  OFFS1(XS),XR     recover oper cmblk
       MOV  CMROP(XR),XR     get right operand
       JSR  CDGEN            generate code for it
       MOV  (XS),XL          retrieve label
       ZER  XR               uncond jmp
       JSR  LABRF
       MOV  (XS)+,XL         get label again
       JSR  LABST            resolve to new block
       MOV  (XS)+,XR         recover cmblk again
       BEQ  CMTYP(XR),=C$ASS,CDG14 jump if ?:= to store
       EXI
       EJC
*
CDX11  BEQ  CMTYP(XR),=C$ASS,CDG10 jump with assop
*
*      If operator is best done in place, insert copy
*      if necessary
*
       BEQ  CMOPR(XR),=O$WIT,CDA09
       BEQ  CMOPR(XR),=O$LES,CDA09
       BNE  CMOPR(XR),=O$LSF,CDA11
CDA09  MOV  CMLOP(XR),XL
       JSR  CHKCP
       PPM  CDA11
CDA10  MOV  =O$COP,WA
       JSR  CDWRD
CDA11  ANB  WA,WA            JVK dummy op
*      ZER  CMLOP(XR)        else can prune JVK??
       EJC
*
*      Fall through to merge with unary case
*
CDG10  MOV  CMROP(XR),XR     get the operand
       JSR  CDGEN
       MOV  (XS)+,XR         recover CMBLK
*
*      Check for WITH operator
*
       BNE  CMOPR(XR),=O$WIT,CDA12
       MOV  CMROP(XR),XL     if so reload right arg
       BEQ  CMTYP(XL),=C$ASS,CDA13
       JSR  CHKCP
       PPM  CDA12
*
CDA13  MOV  =O$COP,WA
       JSR  CDWRD
*
CDA12  MOV  CMOPR(XR),WA     now get the operator
       JSR  CDWRD
       BEQ  CMTYP(XR),=C$ASS,CDG14 jump if assop
       EXI                   else return
       EJC
*
*      Here with assigning operators
*
CDG11  BEQ  CMOPR(XR),=O$FRM,CDG10
       BEQ  CMOPR(XR),=O$FRB,CDG10
       BEQ  CMOPR(XR),=O$FRE,CDG10
       BNE  CMOPR(XR),=O$ASS,CDG09 jump if not simple
       MOV  CMROP(XR),XR     load right hand side
       JSR  CDGEN
       MOV  (XS),XR          and recover CMBLK
       MOV  CMROP(XR),XL
       JSR  CHKCP
       PPM  CDG13
CDG12  MOV  =O$COP,WA        else copy for semantics
       JSR  CDWRD
*
CDG13  MOV  (XS)+,XR         get CMBLK again
*
*      Merge with general assop to generate store
*
CDG14  MOV  CMLOP(XR),XL     get destination
       ZER  GENIS            non-iter store
       JSR  GENLH            go generate store instruction
*      ZER  CMLOP(XR)        prune it JVK??
       BEQ  CMOPR(XR),=O$FRE,CDA14 jump with FROME
       BEQ  CMOPR(XR),=O$FRB,CDA14 or FROMB
       EXI                   else exit
*
*      FROMB and FROME require a store into right operand
*
CDA14  MOV  =O$POP,WA
       JSR  CDWRD
       MOV  CMROP(XR),XL
       ZER  GENIS            not iterator
       JSR  GENST
       EXI
       EJC
*
*      Here to generate code for an IF statement
*
.IF    .CNPF
CDG15  JSR  NXTLB            get a label number
.ELSE
CDG15  MOV  =SC$IF,XL
       JSR  PRTWD
CDA15  JSR  NXTLB            Get a label
.FI
       MOV  WA,-(XS)         save it = LAB1
       JSR  NXTLB            get another
       MOV  WA,-(XS)         LAB2
*
CDG16  MOV  CMTST(XR),XR     get test
       JSR  CDGEN            generate code for that
       MOV  CDICM(XS),XR     Get CMBLK back
       BNZ  CMELS(XR),CDA16  Jump if ELSE block is there
       MOV  CDIL2(XS),XL     No - jump will be to LAB2
       BRN  CDA17
CDA16  MOV  CDIL1(XS),XL     With ELSE, LAB1 is destn.
CDA17  MOV  =JFALS,XR        We jump on false
.IF    .CNPF
       JSR  LABRF
       MOV  CDICM(XS),XR     Retrieve CMBLK
.ELSE
       JSR  GENPF
       JSR  LABRF
       MOV  CDICM(XS),XR     Retrieve CMBLK
       BEQ  CMTYP(XR),=C$IFS,CDJ16 Jump if real IF
       MOV  CMTVO(XR),XL     else load ptr to truth op name
       BRN  CDJ17
CDJ16  MOV  =SCTHN,XL        Real IF - pt to /THEN/
CDJ17  JSR  PRTWD
.FI
       ZER  CMTST(XR)        prune test
       MOV  CMTHN(XR),XR     get THEN block
       JSR  CDGEN            do that
       MOV  CDICM(XS),XR     Haul CMBLK back once more
       ZER  CMTHN(XR)        Prune THEN
       BZE  CMELS(XR),CDG17  Jump if no ELSE
.IF    .CNPF
.ELSE
       BNE  CMTYP(XR),=C$IFS,CDJ18
       JSR  GENPF
.FI
       EJC
CDJ18  MOV  (XS),XL          get LAB2
       ZER  XR
       JSR  LABRF            and generate the jump
       MOV  CDIL1(XS),XL     now get LAB1
       JSR  LABST            which is set here
       MOV  CDICM(XS),XL     get the CMBLK again
*
       MOV  CMELS(XL),XR     get ELSE block
       BNE  (XR),=B$CMT,CDB15 check for ELSEIF CMBLK
.IF    .CNPF
.ELSE
       BEQ  CMTYP(XR),=C$TVO,CDJ19 j if expr arg of AND/OR/IMP
.FI
       BNE  CMTYP(XR),=C$IFS,CDB15 jump if not ELSEIF
*
*      For ELSEIFs optimise a bit - LAB1 is finished
*      with, so re-use it
*
.IF    .CNPF
.ELSE
       MOV  =SCELF,XL
       JSR  PRTWD
.FI
CDJ19  MOV  CDIL1(XS),XL
       BNE  LSLAB,XL,CDX16
       ZER  LSLAB
CDX16  ADD  R$LBV,XL
       ZER  (XL)             clear label table entry
       MOV  XR,CDICM(XS)     new current node
       ZER  XL
       BRN  CDG16            loop
.IF    .CNPF
CDB15  JSR  CDGEN
CDG17  MOV  CDICM(XS),XR     Recall CMBLK
       ZER  CMELS(XR)        Prune ELSE off
       MOV  (XS),XL          Get LAB2 ...
.ELSE
CDB15  BEQ  CMTYP(XL),=C$IFS,CDB16 Jump if genuine IF
       JSR  CDGEN            Else generate psudo-else
       MOV  CDICM(XS),XR     Recall CMBLK (C$TVO)
       ZER  CMELS(XR)        Chop off what we just generated
       BRN  CDB17            Merge with main code
*
CDB16  MOV  =SCELS,XL
       JSR  PRTWD
       JSR  CDGEN
       MOV  CDICM(XS),XR     Recall CMBLK (C$IFS)
       ZER  CMELS(XR)        Prune ELSE
*
*      ELSE-less IF merges here to generate profile stuff
*
CDG17  JSR  GENPF
       MOV  =SCEND,XL
       JSR  PRTWD
CDB17  MOV  (XS),XL          Get LAB2 ...
.FI
       ZER  XR
       JSR  LABRF            to chain into ..
       MOV  (XS),XL
       JSR  LABST            next block
*
*      Merge here to clear up and exit
*
       ADD  *NUM03,XS        pop our stack locations
       MOV  =NUM02,WA        used 2 labels
       JSR  DSCLB            discard them
       EXI
       EJC
*
*      Generate code for a loop or quantifier
.IF    .CNPF
CDG18  MOV  CMLPI(XR),XR     get iterator part
.ELSE
CDG18  MOV  =SCLOO,XL
       JSR  PRTWD
CDX18  MOV  CMLPI(XR),XR     Get iterator part
.FI
CDA18  MOV  QUITL,-(XS)      save QUIT ..
       MOV  CONTL,-(XS)      ..and CONT labels
       MOV  LPTMP,-(XS)      loop temp count
       ZER  LPTMP            clear it
       BNE  CMTYP(XR),=C$FIT,CDG26 jump if not full iterator
*
*      Generate code for a full iterator
*
       JSR  NXTLB            LAB1
       MOV  WA,-(XS)
       JSR  NXTLB            LAB2
       BNZ  CMSTP(XR),CDA19  If there is either a STEP
       BNZ  CMUNT(XR),CDA19  or an UNTIL, use LAB2 just got
       MOV  (XS),WA          Else LAB1 is also LAB2
CDA19  MOV  WA,-(XS)
       MOV  WA,CONTL         also CONT label
       JSR  NXTLB            LAB3
       MOV  WA,-(XS)
       MOV  WA,QUITL         also QUIT label
       MOV  XR,-(XS)         also save iterator node
*
*      Now generate code for each component in turn -
*      INIT block is first.
*
       BZE  CMINI(XR),CDG19  jump if no INIT
.IF    .CNPF
.ELSE
       MOV  =SCINI,XL
       JSR  PRTWD
.FI
       MOV  CMINI(XR),XR     else load INIT tree
       JSR  CDGEN            simply generate code inline
*
*      Set the label at the head of the loop.
*
CDG19  MOV  CDFL1(XS),XL     Its LAB1
       ZER  XR
.IF    .CNPF
.ELSE
       JSR  GENPF
.FI
       JSR  LABRF            Chain blocks together
       MOV  CDFL1(XS),XL     Get it again
       JSR  LABST            Set it
*
*      The DOING block is the first thing in the loop actual.
*
       MOV  (XS),XR          retrieve CMBLK for iterator
       ZER  CMINI(XR)        prune INIT
       BZE  CMDNG(XR),CDG20  Jump if no DOING
.IF    .CNPF
.ELSE
       MOV  =SCDNG,XL
       JSR  PRTWD
.FI
       MOV  CMDNG(XR),XR     Else get block
       JSR  CDGEN            and generate it
       MOV  (XS),XR          Retrieve iterator again
       ZER  CMDNG(XR)        Show DOING done
       EJC
*
*      Now the WHILE test.
*
CDG20  BZE  CMWHI(XR),CDG21  Jump if not there
.IF    .CNPF
.ELSE
       MOV  =SCWHI,XL
       JSR  PRTWD
.FI
       MOV  CMWHI(XR),XR
       JSR  CDGEN            Else generate it
       MOV  =JFALS,XR        Want to /jump on false/
       MOV  CDFL3(XS),XL     to TERM block
.IF    .CNPF
.ELSE
       JSR  GENPF
.FI
       JSR  LABRF
       MOV  (XS),XR
       ZER  CMWHI(XR)
*
*      The body of the loop is the next bit.
*
.IF    .CNPF
CDG21  MOV  CDFCM(XS),XR     get (parent) loop node
.ELSE
CDG21  MOV  =SC$DO,XL
       JSR  PRTWD
       MOV  CDFCM(XS),XR     Get (parent) loop node
.FI
       MOV  CMLPB(XR),XR     get body
       JSR  CDGEN            and generate code for that
       MOV  CDFCM(XS),XR     get it again
       ZER  CMLPB(XR)        prune tree
*
*      If neither STEP nor UNTIL is to be generated, we can omit
*      both sections immediately, and need not set a CONT label
*      as LAB1 will have been used in any references.
*
       MOV  (XS),XR          Get iterator
       BNZ  CMSTP(XR),CDA21  Continue in line if STEP
       BZE  CMUNT(XR),CDG23  no - jump if also no UNTIL
*
*      At least one of the two is to be generated - set CONT lbl
*
CDA21  MOV  CDFL2(XS),XL     this is LAB2
       ZER  XR
.IF    .CNPF
.ELSE
       JSR  GENPF
.FI
       JSR  LABRF            chain blocks together
       MOV  CDFL2(XS),XL     get it again
       JSR  LABST            set it at end of body
*
*      Now try for a STEP
*
       MOV  (XS),XR          this is the iterator
       BZE  CMSTP(XR),CDG22  Jump if no STEP
.IF    .CNPF
.ELSE
       MOV  =SCSTP,XL
       JSR  PRTWD
.FI
       MOV  CMSTP(XR),XR     else...
       JSR  CDGEN            generate STEP actions here
       MOV  (XS),XR
       ZER  CMSTP(XR)
       EJC
*
*      UNTIL test comes next
*
CDG22  BZE  CMUNT(XR),CDG23  Jump if none
.IF    .CNPF
.ELSE
       MOV  =SCUNT,XL
       JSR  PRTWD
.FI
       MOV  CMUNT(XR),XR
       JSR  CDGEN            generate for test expression
       MOV  =JFALS,XR        want to loop if false
       BRN  CDA23            Merge to jump to head
*
*      Here if no UNTIL to unconditionally jump back to head
*      of loop. Until merges with conditional set to make
*      the reference.
*
CDG23  ZER  XR               Unconditional with no UNTIL
CDA23  MOV  CDFL1(XS),XL     UNTIL merges to load head label
.IF    .CNPF
.ELSE
       JSR  GENPF
.FI
       JSR  LABRF            and generate reference
       MOV  CDFL3(XS),XL     get TERM/QUIT label
       JSR  LABCR            Check referenced
       PPM  CDG24            No - omit to set
       MOV  CDFL3(XS),XL     Yes - get it back
       MOV  (XS),XR          Also iterator node
       BZE  CMUNT(XR),CDA24  Skip reference if no UNTIL
       ZER  XR
.IF    .CNPF
.ELSE
*      GENPF not needed here, as this label reference is only
*      generated directly after the /Jump if False/ at the end
*      of an UNTIL block.
.FI
       JSR  LABRF            Else chain into TERM
       MOV  CDFL3(XS),XL
CDA24  JSR  LABST            Set it
*
*      Merge here if no references to TERM/QUIT label.
*
CDG24  MOV  (XS),XR
       ZER  CMUNT(XR)        Prune any UNTIL branch
*
*      Finally, do the TERM block, if any
*
       BZE  CMTRM(XR),CDG25
.IF    .CNPF
.ELSE
       MOV  =SCTRM,XL
       JSR  PRTWD
.FI
       MOV  CMTRM(XR),XR
       JSR  CDGEN
*
*      Clean up stack etc. and exit
*
CDG25  ADD  *NUM04,XS        Throw away temp stack locs
       MOV  (XS)+,LPTMP      restore temp count
       MOV  (XS)+,CONTL      reset CONTINUE label
       MOV  (XS)+,QUITL      and QUIT
       ICA  XS               throw away loop node
       MOV  =NUM03,WA
       JSR  DSCLB            and discard labels
.IF    .CNPF
.ELSE
       MOV  =SCEND,XL
       JSR  PRTWD
.FI
       EXI
       EJC
*
*      Here for a loop controlled by FOR iterator
*      Quantifiers, set formers merge
*
CDG26  MOV  XR,-(XS)         stack iterator CMBLK
.IF    .CNPF
.ELSE
       MOV  CDLCM(XS),XL     get loop node
       BNE  CMTYP(XL),=C$LUP,CDB24  skip if not real loop
       JSR  GENPF
       MOV  =SCFOR,XL
       JSR  PRTWD
.FI
CDB24  JSR  NXTLB            get label for exit
       MOV  WA,QUITL         used for QUIT
CDB25  JSR  NXTLB            get another label
       MOV  WA,CONTL         provisionally CONT
       MOV  (XS),XR          reload CMBLK
       BEQ  CMTYP(XR),=C$MIT,CDG31 jump for map iterators
       BEQ  CMTYP(XR),=C$MCI,CDG31
*
*      See whether we want to optimise for a loop of the
*      form     FOR i IN (/ e1 ... e2 /)
*
       MOV  CMIXP(XR),XL     get the expression bit
       BEQ  CMTYP(XL),=C$SET,CDG27
       BNE  CMTYP(XL),=C$TUP,CDG28
*
*      If we got here, it might be
*
CDG27  MOV  CMVLS(XL),XL     look closer
       BNE  CMTYP(XL),=C$ARF,CDG28 jump if not arithmetic former
*
*      Here we have an arithmetic loop to optimise
*
CDJ25  MOV  XL,-(XS)         save arithmetic former
       MOV  CMALM(XL),XR     get limit
       JSR  CDGEN            generate code to stack it
       MOV  (XS),XR
       MOV  CMAST(XR),XR     second value
       BEQ  XR,=C$DFL,CDJ26
       JSR  CDGEN
       MOV  (XS),XR
       MOV  CMAIN(XR),XR     get initial value
       JSR  CDGEN
       MOV  =O$MNS,WA        minus operator
       JSR  CDWRD            this computes step
       BRN  CDJ27
*
CDJ26  MOV  =INTON,WA        load default step
       JSR  CDWRD
CDJ27  MOV  (XS)+,XR
       MOV  CMAIN(XR),XR     get initial again
       JSR  CDGEN            easiest to generate code again
       EJC
*
*      Prepare to generate test and increment
*
       MOV  CONTL,XL         load label
       ZER  XR
       JSR  LABRF            chain into new block
       MOV  CONTL,XL         will start here
       JSR  LABST
       MOV  =TMPL0,WA        load loop counter instruction
       JSR  CDWRD
       MOV  =TMPL3,WA        load limit
       JSR  CDWRD
       JSR  CDWRD            this loads step
       MOV  =ORNEG,WA        swap limit and current if - step
       JSR  CDWRD
       MOV  =O$OLE,WA        test less than
       JSR  CDWRD
       MOV  =JCFLS,XR        we jump and clear on FALSE
       MOV  CONTL,XL         load label
       DCA  XL               destination of jump is previous one
       JSR  LABRF
       ADD  =NUM03,LPTMP     count temporaries
       ADD  =NUM03,EXTMP
       ADD  =NUM03,RTTMP
       MOV  (XS),XR          reload iterator block etc
       BEQ  XR,=C$ARF,CDX36  jump if actual former
       MOV  CMILH(XR),XL     get left hand part
       MNZ  GENIS            iter store
       JSR  GENLH            assign to it
*
CDJ28  MOV  =TMPL1,WA        load step
       JSR  CDWRD
       MOV  =O$PLS,WA        add increments loop counter
       JSR  CDWRD            (for next time)
.IF    .CNPF
       BEQ  (XS),=C$ARF,CDB30      jump if in set former
.ELSE
       BEQ  (XS),=C$ARF,CDG39 Jump if in former
.FI
       BRN  CDX29            merge
*
*      Here for iterator we cannot optimise
*
CDG28  MOV  CMIXP(XR),XR     load expression part
       JSR  CDGEN
       MOV  =O$PPI,WA        prepare iterator from it
       JSR  CDWRD
       MOV  CONTL,XL
       ZER  XR
       JSR  LABRF
       MOV  CONTL,XL
       JSR  LABST
       MOV  =JNEXT,XR
       MOV  CONTL,XL         destination..
       DCA  XL               is previous label set
       JSR  LABRF
       MOV  (XS),XR
CDG30  MOV  CMILH(XR),XL
       MNZ  GENIS            iter store
       JSR  GENLH            update left hand
       MOV  =O$POP,WA
       JSR  CDWRD
       EJC
       ADD  =NUM02,LPTMP     count new temporaries
       ADD  =NUM02,EXTMP
       ADD  =NUM02,RTTMP
*
*      Merge to look for more iterators
*
CDX29  MOV  (XS),XR          load iterator block
       MOV  CMINX(XR),XR     gert next
       BZE  XR,CDB28         jump if end, no ST
       BEQ  CMTYP(XR),=C$ITR,CDB31 jump for multi-iterator
       BEQ  CMTYP(XR),=C$MIT,CDB31
       BEQ  CMTYP(XR),=C$MCI,CDB31
       BRN  CDB26            continue for ST
*
.IF    .CNPF
CDB31  MOV  XR,(XS)
.ELSE
CDB31  JSR  GENPF
       MOV  =COMMA,XL
       JSR  PRTWD
       MOV  XR,(XS)
.FI
       BRN  CDB25
*
*      Branch for map or tuple iterators a=m(b) or a=m{b}
*
CDG31  MOV  CMMID(XR),WA     load identifier m
       JSR  CDWRD            gen code
       MOV  =O$PMI,WA        prep map iter
       JSR  CDWRD
       MOV  CONTL,XL
       ZER  XR
       JSR  LABRF            jump to cont cdblk
       MOV  CONTL,XL
       JSR  LABST            start new cdblk
       MOV  =JNXTM,XR        set up m and next dom elt
       MOV  CONTL,XL         fail dest is..
       DCA  XL                 ..prior label set
       JSR  LABRF
       MOV  (XS),XR          retrieve map iter
       MOV  CMMSB(XR),XL     get subscript
       MNZ  GENIS            iter store
       JSR  GENLH            store b
       BEQ  CMTYP(XR),=C$MCI,CDG32
       MOV  =O$SUB,WA        compute m(b)
       BRN  CDG33
CDG32  MOV  =O$SBM,WA        or m{b}
CDG33  JSR  CDWRD
       BRN  CDG30            merge with C$ITR case
*
*      Here to generate such that test
*
.IF    .CNPF
CDB26  JSR  CDGEN            Generate code for test expression
.ELSE
CDB26  JSR  GENPF            End a block
       MOV  =SC$ST,XL        at the /ST/
       JSR  PRTWD
       JSR  CDGEN
       MOV  CDLCM(XS),XR     Get loop node
       BNE  CMTYP(XR),=C$LUP,CDB27 Jump if not real loop
       JSR  GENPF
.FI
CDB27  MOV  =JFALS,XR
       MOV  CONTL,XL         loop if false
       JSR  LABRF
*
*      Now do loop body etc
*
CDB28  MOV  CDLCM(XS),XR     load loop node
       BEQ  CMTYP(XR),=C$LUP,CDX35 jump with actual loop
       BEQ  CMTYP(XR),=C$FMR,CDX36 former
*
*      Fall through with quantifiers
*
.IF    .CNPF
.ELSE
       MOV  =SC$ST,XL
       JSR  PRTWD
.FI
       MOV  CMLPB(XR),XR     get test (body)
       JSR  CDGEN
       MOV  CDLCM(XS),XR
       BEQ  CMTYP(XR),=C$AQN,CDX30 jump if universal
       MOV  =JFALS,XR        for these we loop on FALSE
       BRN  CDX32
*
*      Universal Quantifier exits on opposite condition
*
CDX30  MOV  =JTRUE,XR
CDX32  MOV  CONTL,XL
.IF    .CNPF
.ELSE
       JSR  GENPF
.FI
       JSR  LABRF
.IF    .CNPF
.ELSE
       MOV  =NULLS,XL        temp - poss /end quantifier/ later
       JSR  PRTWD
.FI
       JSR  GPOPL            otherwise pop loop temps
       MOV  =O$NOT,WA        invert tentaive result
       JSR  CDWRD
       MOV  QUITL,XL         and leave loop
       ZER  XR
       JSR  LABRF
       BRN  CDX31
       EJC
*
*      Generate loop body
*
CDX35  MOV  CMLPB(XR),XR     get body
.IF    .CNPF
       JSR  CDGEN
.ELSE
       MOV  =SC$DO,XL
       JSR  PRTWD
       JSR  CDGEN
       JSR  GENPF
       MOV  =SCEND,XL
       JSR  PRTWD
.FI
*
*      Chain out of loop
*
CDB30  MOV  CONTL,XL
       ZER  XR
       JSR  LABRF
CDX31  MOV  QUITL,XL
       JSR  LABST
*
       MOV  CONTL,WA         compute number..
       SUB  QUITL,WA         ..of labels..
       BTW  WA               ..used
       ICV  WA               JVK-in words
       JSR  DSCLB            and discard
       ICA  XS
       SUB  LPTMP,EXTMP
       SUB  LPTMP,RTTMP
       MOV  (XS)+,LPTMP
       MOV  (XS)+,CONTL
       MOV  (XS)+,QUITL
.IF    .CNPF
       ICA  XS
       EXI
.ELSE
       MOV  (XS)+,XL         get loop CMBLK
       BNE  CMTYP(XL),=C$FMR,CDX33 Done if not former
       ICA  XS               Else throw away type code
CDX33  EXI
.FI
       EJC
*
*      Load element to add to arith set
*
CDA38  MOV  =TMPL1,WA
       JSR  CDWRD
       BRN  CDX38
*
*      Here to do set/tuple former after looping has
*      been dealt with
*
CDX36  MOV  =TMPLN,WA        load partial result set
       JSR  CDWRD
       MOV  LPTMP,WA         this will be offset
       JSR  CDWRD
       BEQ  XR,=C$ARF,CDA38  jump with arith set
       BZE  CMFXP(XR),CDX37  jump if abbreviated
*
       MOV  CMFXP(XR),XR
       JSR  CDGEN
       BRN  CDX38
*
CDX37  MOV  CMFIT(XR),XR
       MOV  CMILH(XR),XR     this is what we add
       JSR  CDGEN
*
*      Merge to add an element to set/tuple
*
CDX38  MOV  =O$WIT,WA
       JSR  CDWRD
       MOV  =TMPSN,WA
       JSR  CDWRD
       MOV  LPTMP,WA
       JSR  CDWRD
       BEQ  XR,=C$ARF,CDJ28
.IF    .CNPF
.ELSE
CDG39  JSR  GENPF
       MOV  CDLCM(XS),XL     Get former CMBLK
       BNE  CMTYP(XL),=C$FMR,CDA37 Jump if not former node
       MOV  CDLFT(XS),XL     Else get former type
CDA37  BNE  CMTYP(XL),=C$SET,CDX39
       MOV  =RSETB,XL
       BRN  CDA39
CDX39  MOV  =RTUPB,XL
CDA39  JSR  PRTWD
.FI
       BRN  CDB30            merge to clear up and exit
       EJC
*
*      Existential quantifier - stack FALSE as result
*
.IF    .CNPF
CDG40  MOV  =FALSE,WA
       JSR  CDWRD
       BRN  CDG18            merge with loops
.ELSE
CDG40  JSR  GENPF
       MOV  =SCEXS,XL
       JSR  PRTWD
       MOV  =FALSE,WA
       JSR  CDWRD
       BRN  CDX18
.FI
.IF    .CNPF
*
*      Other quantifiers - provisionally yield TRUE
*
CDG41  MOV  =TRUE$,WA
       JSR  CDWRD
       BRN  CDG18
.ELSE
*
*      Universal Quantifier.
*
CDG41  JSR  GENPF
       MOV  =SCFRL,XL
       BRN  CDG43
*
*      Non-Existential Quantifier (NOTEXISTS).
*
CDG42  JSR  GENPF
       MOV  =SCNXS,XL
*
*      FORALL, NOTEXISTS merge here to provisionally yield TRUE.
*
CDG43  JSR  PRTWD
       MOV  =TRUE$,WA
       JSR  CDWRD
       BRN  CDX18
.FI
       EJC
*
*      Compound operator
*
CDB50  MOV  QUITL,-(XS)      save QUIT ..
       MOV  CONTL,-(XS)        and CONT labels
       MOV  LPTMP,-(XS)        and loop temp count
       ZER  LPTMP            clear it
       MOV  XR,-(XS)         save cmpd oper CMBLK
       JSR  NXTLB            get exit label
       MOV  WA,QUITL           used for QUIT
       JSR  NXTLB            and another label
       MOV  WA,CONTL           for CONT
       MOV  (XS),XR          reload CMBLK
       MOV  CMROP(XR),XR     gen code for right operand
       JSR  CDGEN
       MOV  (XS),XR
       MOV  CMLOP(XR),XR     get left operand
       BZE  XR,CDB51         jump if unary form
*
       MOV  =O$PPI,WA        prepare binary compound oper
       JSR  CDWRD
       MOV  (XS),XR
       MOV  CMLOP(XR),XR     gen code for left oper
       JSR  CDGEN
       BRN  CDB52
*
CDB51  MOV  =O$PCM,WA        prepare unary compound oper
       JSR  CDWRD
CDB52  MOV  CONTL,XL         jump to next block
       ZER  XR
       JSR  LABRF
       MOV  CONTL,XL         start new code block
       JSR  LABST
       MOV  =JNXTC,XR        test for next entry
       MOV  CONTL,XL         the destination
       DCA  XL                 is the previous label
       JSR  LABRF
*
       MOV  (XS),XR
       MOV  CMOPR(XR),WA     get operator
       BNE  WA,=O$QMK,CDB53  trap ? oper, which uses branch
       MOV  =O$QMC,WA        if ?, use naive form
       JSR  CDWRD
       MOV  CONTL,XL         if not om, get destination
       DCA  XL                 as previous label
       ZER  XR
       JSR  LABRF            allow branch if not om result
       BRN  CDB54
*
CDB53  JSR  CDWRD
CDB54  ADD  =NUM02,LPTMP
       ADD  =NUM02,EXTMP
       ADD  =NUM02,RTTMP
       BRN  CDB30            merge to complete loop
*
*      CASE statement or expression
*
CDG50  MOV  CMCEX(XR),XR     load expression
.IF    .CNPF
.ELSE
       MOV  =SCCAS,XL
       JSR  PRTWD
.FI
       JSR  CDGEN            evaluate and load
.IF    .CNPF
.ELSE
       JSR  GENPF
       MOV  =SC$OF,XL
       JSR  PRTWD
.FI
       MOV  (XS),XR          reload case block
       MOV  CMCBD(XR),XR
       MOV  XR,(XS)
       JSR  NXTLB            get label for end - LAB0
       MOV  WA,-(XS)
       JSR  NXTLB            one for head of block
       MOV  WA,-(XS)
       JSR  NXTLB            one for fail jumps - LAB2
       MOV  WA,-(XS)
*
*      This allows for more than one test on a branch.
*      The simple-minded implementation of CASEs is just
*      a series of tests.
*
CDX51  MOV  CMTGV(XR),XR     get list of tag values
CDJ51  MOV  XR,R$CSV         save it - no need to stack
       BNE  CMTYP(XR),=C$EXP,CDX52 jump if last on list
       MOV  CMLTL(XR),XR
CDX52  JSR  CDGEN            evaluate
       MOV  =TMPL1,WA        load expression (temp)
       JSR  CDWRD
       MOV  =O$EQL,WA
       JSR  CDWRD
       MOV  =JTRUE,XR
       MOV  CDCL1(XS),XL
       JSR  LABRF
       MOV  R$CSV,XR
       BNE  CMTYP(XR),=C$EXP,CDX53
       MOV  CMLHD(XR),XR
       BRN  CDJ51
*
*      If all tests fail, jump to next lot
*
.IF    .CNPF
CDX53  MOV  CDCL2(XS),XL
.ELSE
CDX53  JSR  GENPF
       MOV  =COLON,XL
       JSR  PRTWD
       MOV  CDCL2(XS),XL
.FI
       ZER  XR
       JSR  LABRF
       EJC
*
*      Set label at head and generate code for this case
*
       MOV  CDCL1(XS),XL
       JSR  LABST
.IF    .CNPF
.ELSE
*      This is also the end of the set of tests for this case.
*      We fudge up a profile op to increment the same counter as
*      the last call to GENPF.
       MOV  =O$PFL,WA
       JSR  CDWRD
       MOV  PFNBB,WA
       JSR  CDWRD
.FI
*
*      Immediately pop off controlling expression, so CASE
*      expression can leave result on stack ok. (Hence
*      extmp, lptmp dont need to count it)
*
       MOV  =O$POP,WA
       JSR  CDWRD
*
       MOV  CDCCM(XS),XR
       MOV  CMTGB(XR),XR
       JSR  CDGEN
*
*      Now the exit jump for this CASE
*
.IF    .CNPF
.ELSE
       JSR  GENPF
       MOV  =NULLS,XL        for now...
       JSR  PRTWD
.FI
       MOV  CDCL0(XS),XL
       ZER  XR
       JSR  LABRF
*
*      Set label for next lot of tests / else
*
       MOV  CDCL2(XS),XL
       JSR  LABST
       MOV  CDCCM(XS),XR
       MOV  CMTRS(XR),XR     load rest
       BZE  XR,CDX55         jump if end of chain
       BNE  CMTYP(XR),=C$TAG,CDX55 jump if ELSE
       EJC
*
*      Otherwise, prepare for more cases, using the labels
*      we have.
*
       MOV  CDCL1(XS),XL
       ADD  R$LBV,XL
       ZER  (XL)+
       ZER  (XL)
       ZER  LSLAB
       ZER  XL
       MOV  XR,CDCCM(XS)
       BRN  CDX51
*
*      Generate ELSE (default case)
*
CDX55  MOV  =O$POP,WA        controlling expression
       JSR  CDWRD
       BZE  XR,CDX56         jump if no default
.IF    .CNPF
.ELSE
       JSR  GENPF
       MOV  =SCELS,XL
       JSR  PRTWD
.FI
       JSR  CDGEN            otherwise generate block
*
CDX56  MOV  CDCL0(XS),XL     chain out of block
       ZER  XR
       JSR  LABRF
       MOV  CDCL0(XS),XL     set label for exits
       JSR  LABST
.IF    .CNPF
.ELSE
       JSR  GENPF
       MOV  =SCEND,XL
       JSR  PRTWD
.FI
*
       ADD  *NUM04,XS        clear locals
       MOV  =NUM03,WA
       JSR  DSCLB
       EXI
       EJC
*
*
*      EXPR block
*
CDG60  MOV  EXPRL,-(XS)
.IF    .CNPF
.ELSE
       MOV  =SCEXP,XL
       JSR  PRTWD
.FI
       JSR  NXTLB
       MOV  WA,EXPRL         save end label
       MOV  EXTMP,-(XS)      save temp count
       ZER  EXTMP            clear it
       MOV  CMVLS(XR),XR
       JSR  CDGEN
*
*      Add a final YIELD OM in case
*      Will be no temps to pop
*
.IF    .CNPF
.ELSE
       JSR  GENPF
       MOV  =SCEND,XL
       JSR  PRTWD
.FI
       MOV  =OMEGA,WA
       JSR  CDWRD
       MOV  EXPRL,XL
       ZER  XR
       JSR  LABRF
       MOV  EXPRL,XL
       JSR  LABST
       MOV  =NUM01,WA
       JSR  DSCLB
       MOV  (XS)+,EXTMP
       MOV  (XS)+,EXPRL
       ICA  XS
       EXI
       EJC
*
*      YIELD statement
*      First pop any temporaries
*
CDG61  JSR  GPOPX
       MOV  CMVLS(XR),XR
       JSR  CDGEN            leaves result on top of stack
.IF    .CNPF
.ELSE
       JSR  GENPF
       MOV  =SCYLD,XL
       JSR  PRTWD
.FI
       MOV  EXPRL,XL
       BZE  XL,CDG62
       ZER  XR
       JSR  LABRF
       ICA  XS
       EXI
*
CDG62  ERB  078,YIELD not inside EXPR block
       EJC
*
*      Here for io statement - PRINT, READ and TRACE
*
CDG65  MOV  CMIOA(XR),XR     load arguments
       MOV  XR,XL
       ZER  WA
       BZE  XL,CDG68         jump if no args
CDG67  ICV  WA               count an argument
       BNE  (XL),=B$CMT,CDG68
       BNE  CMTYP(XL),=C$EXP,CDG68
       MOV  CMLHD(XL),XL
       BRN  CDG67
*
CDG68  MOV  WA,-(XS)         save arg count
       MOV  OFFS1(XS),XR         should define offset
       BEQ  CMIOS(XR),=F$RDA,CDJ66   jump if reada
       BEQ  CMIOS(XR),=F$GET,CDJ66     or get
       BEQ  CMIOS(XR),=F$REA,CDG66   jump if read
       BEQ  CMIOS(XR),=F$RDL,CDG66     or readl
       MOV  CMIOA(XR),XR     reload arglist
       JSR  CDGEN            lazy way to generate arg values
       MOV  OFFS1(XS),XR         reload CMBLK
       MOV  CMIOS(XR),WA     entry point
       JSR  CDWRD            print
       MOV  (XS)+,WA
       JSR  CDWRD            # args
       ICA  XS
       EXI
*
*      READA or GET branch
*
CDJ66  MOV  CMIOF(XR),XR     get function arg expr
       JSR  CDGEN            generate load arg
       MOV  OFFS1(XS),XR     reload c$ios block and merge
*
*      READ branch
*
CDG66  MOV  CMIOS(XR),WA
       JSR  CDWRD            read
*
*      Generate assignments to arguments
*
       MOV  (XS)+,WA
       JSR  CDWRD            number of args
       MOV  CMIOA(XR),XR
       ZER  GENIS            non-iterator stores
CDG70  BNE  (XR),=B$CMT,CDG71 jump at end of list
       BNE  CMTYP(XR),=C$EXP,CDG71
       MOV  CMLTL(XR),XL     this will be single
       JSR  GENST
       MOV  =O$POP,WA
       JSR  CDWRD
       MOV  CMLHD(XR),XR     follow list
       BRN  CDG70
CDG71  MOV  XR,XL
       JSR  GENST
       ICA  XS
       MOV  =O$POP,WA
       JSR  CDWRD
       EXI
       EJC
.IF    .CNPF
.ELSE
*
*      Here for a set
*
CDA80  MOV  =LSETB,XL
       BRN  CDA82
*
*      Here for a tuple
*
CDA81  MOV  =LTUPB,XL
CDA82  JSR  GENPF
       JSR  PRTWD
.FI
*
*      Here for a set or tuple
*
CDG80  MOV  CMVLS(XR),XR     get body
       BNE  (XR),=B$CMT,CDJ81      JVK-leaf is exp
       BEQ  CMTYP(XR),=C$ARF,CDG85 jump if not explist
       BEQ  CMTYP(XR),=C$FMR,CDG85
*
*      Either exp or explist
*      Chain through expression list to count elements
*
CDJ81  MOV  =NUM01,WC        initialize counter
       MOV  XR,XL            copy pointer
CDG81  BNE  (XL),=B$CMT,CDG82       JVK-done if leaf
       BNE  CMTYP(XL),=C$EXP,CDG82  or end of list
       MOV  CMLHD(XL),XL     follow chain
       ICV  WC               count one
       BLT  WC,MXLEN,CDG81   more if no overflow
*
       ERB  303,too many elements in set or tuple
*
CDG82  MOV  WC,-(XS)         stack the count
       MOV  XR,-(XS)         save the list
       JSR  CDGEN            now generate code for the list
       MOV  (XS)+,XL         recover list
       JSR  CHKCP            for single elt, copy may be needed
       PPM  CDJ82
       MOV  =O$COP,WA
       JSR  CDWRD
CDJ82  MOV  (XS)+,WB         get cardinality
       MOV  (XS)+,XR         was it a set or tuple
       BNE  CMTYP(XR),=C$SET,CDG83     jump with tuple
*
       MOV  =O$STF,WA        get setform operator
.IF    .CNPF
.ELSE
       MOV  =RSETB,XL
.FI
       BRN  CDG84
*
CDG83  MOV  =O$TPF,WA        get tupleform
.IF    .CNPF
.ELSE
       MOV  =RTUPB,XL
.FI
CDG84  JSR  CDWRD
       MOV  WB,WA            load element count
       JSR  CDWRD            generate as a codeword
.IF    .CNPF
.ELSE
       JSR  GENPF
       JSR  PRTWD
.FI
       EXI
       EJC
*
*      Here for a set or tuple former
*      3 possibilities -
*         full former with expression and iterator
*         arithmetic iterator
*         truncated former - iterator with such that clause
*
*      In any case, we want to start with an empty set or
*      tuple, and add elements in a loop.
*
CDG85  MOV  (XS),XL          Remember set/tuple CMBLK
       BNE  CMTYP(XL),=C$TUP,CDG86 Jump with set
       MOV  =NLTUP,WA        get empty tuple
       BRN  CDG87
*
CDG86  MOV  =NLSET,WA        get empty set
CDG87  JSR  CDWRD
*
       BEQ  CMTYP(XR),=C$ARF,CDA87 prepare to do loop
.IF    .CNPF
       MOV  XR,(XS)
.ELSE
       MOV  XR,-(XS)         Need this later if profiling
.FI
       MOV  CMFIT(XR),XR
       BRN  CDA18
*      Here we have arithmetic tuple or set
*
CDA87  MOV  QUITL,-(XS)
       MOV  CONTL,-(XS)
       MOV  LPTMP,-(XS)
       ZER  LPTMP
       JSR  NXTLB
       MOV  WA,QUITL
       JSR  NXTLB
       MOV  WA,CONTL
       MOV  XR,XL            swap former as expected later
       MOV  =C$ARF,-(XS)     marker on stack
       BRN  CDJ25
       EJC
*
*      Procedure call
*
CDG91  MOV  CMARG(XR),XR     argument list
       MOV  XR,XL
       ZER  WA               clear for counting
       BZE  XL,CDG93
CDG92  ICV  WA
       BNE  (XL),=B$CMT,CDG93
       BNE  CMTYP(XL),=C$EXP,CDG93
       MOV  CMLHD(XL),XL
       BRN  CDG92
*
CDG93  MOV  WA,-(XS)         save arg count
.IF    .CNPF
.ELSE
       JSR  GENPF
       MOV  =PFM05,XL        msg /Procedure Call/
       JSR  PRTWD
.FI
       MOV  XR,-(XS)         save arg list
       JSR  CDGEN            generate arguments
       MOV  (XS)+,XL         recover args
       JSR  CHKCP            may have to copy single arg
       PPM  CDJ93
       MOV  =O$COP,WA
       JSR  CDWRD
CDJ93  MOV  (XS)+,WB
       MOV  (XS)+,XR         reload CMBLK
       MOV  CMPRC(XR),WA     get PCBLK (or system fcn)
       JSR  CDWRD            generate call
       MOV  WB,WA
       JSR  CDWRD            arg count follows
       MOV  CMPRC(XR),XL
       BEQ  XL,=F$ANY,CDX91
       BEQ  XL,=F$BRK,CDX91
       BEQ  XL,=F$LEN,CDX91
       BEQ  XL,=F$MCH,CDX91
       BEQ  XL,=F$NAY,CDX91
       BEQ  XL,=F$RAN,CDX91
       BEQ  XL,=F$RBR,CDX91
       BEQ  XL,=F$RLN,CDX91
       BEQ  XL,=F$RMC,CDX91
       BEQ  XL,=F$RNA,CDX91
       BEQ  XL,=F$RSP,CDX91
       BEQ  XL,=F$SPN,CDX91
       EXI
*
*      Continue if call to string primitive, store in 1st arg
*
CDX91  MOV  CMARG(XR),XL     get arg list
CDX92  BNE  (XL),=B$CMT,CDX93 loop until first arg
       BNE  CMTYP(XL),=C$EXP,CDX93
       MOV  CMLHD(XL),XL
       BRN  CDX92
CDX93  MOV  XL,-(XS)         save first arg
       JSR  CHKCP            make sure legal lhs
       PPM  XESPT            arg error if not
       MOV  (XS)+,XL         restore lhs
       ZER  GENIS            non-iter store
       JSR  GENST            store new search string
       MOV  =O$POP,WA
       JSR  CDWRD
       EXI
*
*      Return
*
CDG95  JSR  GPOPR            pop off any temporaries
       MOV  CMVLS(XR),XR     load returned expression
       JSR  CDGEN
       ZER  STKSW
.IF    .CNPF
.ELSE
       JSR  GENPF
       MOV  =SCRTN,XL
       JSR  PRTWD
.FI
       MOV  =O$RTN,WA        get returninstruction
       JSR  CDWRD
       ICA  XS
       EXI
       EJC
       ENP
       EJC
*
*      CODEG -- generate code for a main program / procedure
*
*      (XR)                  pointer to root node of tree
*      JSR  CODEG
*
CODEG  PRC  E,0
       BNZ  ERFLG,CODG2      jump if inhibited
       MOV  XR,-(XS)            copy tree pointer
       MOV  *LTSI$,WA        get size of label table
       ZER  XL               JVK in case gbcol
       JSR  ALLOC            allocate in dynamic
       MOV  =B$LTB,(XR)      set type word
       MOV  XR,R$LBV         and store pointer
*
*
*      Loop to clear the table
*
       ADD  XR,WA            Point to end of table
CODG0  ICA  XR               point to next entry
       ZER  (XR)             clear it
       BLT  XR,WA,CODG0      loop for more
CODG1  ZER  R$LBC            no current label
       ZER  R$LBR            no current references
*
*      Allocate initial CCBLK
*
       MOV  *E$CBS,WA        initial size
       JSR  ALLOC            get block in dynamic
       MOV  =B$CCT,(XR)      type word
       MOV  *CCCOD,CWCOF     initial offset
       MOV  *CCCOD,CCUSE(XR) number of words used
       MOV  WA,CCLEN(XR)     total length
       MOV  XR,R$CCB         store pointer
.IF    .CNPF
.ELSE
       JSR  PRTNL            Space out with a blank line
       ZER  PFNBB            No blocks seen yet
.FI
       JSR  NXTLB            get label for head
       MOV  WA,XL
       JSR  LABST            and set it
       MOV  (XS)+,XR            retrieve tree pointer
       JSR  CDGEN            generate code for tree
*      Add an END instruction
*
.IF    .CNPF
.ELSE
       JSR  GENPF
       MOV  =SCEND,XL
       JSR  PRTWD
       JSR  PRTNL            Finish with blank line too
.FI
       ICV  CDGSN
       MOV  =O$END,WA
       JSR  CDWRD
       EJC
*
*      Set a dummy label at the end, to clear up references
*      and carve off final CDBLK.
*
       JSR  NXTLB            get the next label
       MOV  WA,XL
       JSR  LABST            set it
       MOV  =NUM01,WA
       JSR  DSCLB            immediately discard it
       MOV  *NUM01,XR        get label 1 (head)
       ADD  R$LBV,XR         point to its table entry
       MOV  (XR),R$COD       get program pointer
       ZER  XR
*
*      Set up to compile subsequent procedures
*
       ZER  RTTMP
       MOV  STATE,PRCSP      point to eventual VRBLKs
       ADD  =PRCNC,PRCNO      increment procedure number
CODG2  EXI
       ENP
       EJC
*
*      COMPV -- compare values
*
*      COMPV compares two values for equality.
*
*      (XL)                  left comaprand
*      (XR)                  right comparand
*      (WA,WC)                must be collectable
*      JSR  COMPV
*      ppm loc                operands were equal
*      PPM loc                operands were not equal
*
COMPV  PRC  R,2
       CHK
       BEQ  (XL),=B$STL,CMV01
       BEQ  (XL),=B$MPL,CMV02
       BRN  CMV03
CMV01  BEQ  (XR),=B$MPL,CMV00
CMV02  BEQ  (XR),=B$STL,CMV00
CMV03  BNE  (XL),(XR),CMPV7  jump if types differ
*
*      Now preserve sensitive registers
*
CMV00  MOV  WA,-(XS)
       MOV  WC,-(XS)
       MOV  XR,-(XS)
       MOV  XL,-(XS)
*
       MOV  (XL),XL          load a type word
       LEI  XL               get the EPI
       BSW  XL,BL$$D,CMPV0   switch on type
*
       IFF  BL$IC,CMPV1
.IF    .CNRA
.ELSE
       IFF  BL$RC,CMPV2
.FI
       IFF  BL$SC,CMPV3
       IFF  BL$PR,CMPV4
       IFF  BL$ST,CMPV5
       IFF  BL$TP,CMPV5
       IFF  BL$MP,CMPV5
       ESW
       EJC
*
*      Default - TVBLKS, OM simple equality test on addresses
*
CMPV0  MOV  (XS),XL          reload left
       BEQ  XR,XL,CXXTR      succeed if equal
       BRN  CXXFL            else fail
*
*      Compare integers
*
CMPV1  MOV  (XS),XL          reload left
       JSR  ICCMP            call comparison routine
       PPM  CXXFL            less than
       PPM  CXXTR            equal
       PPM  CXXFL            greater than
.IF    .CNRA
.ELSE
*
*      Compare reals
*
CMPV2  MOV  (XS),XL
       JSR  RCCMP
       PPM  CXXFL
       PPM  CXXTR
       PPM  CXXFL
.FI
*
*      Compare strings
*
CMPV3  MOV  (XS),XL          reload left
       JSR  LCOMP            use existing, unsatisfactory prc
       PPM  CXXFL
       PPM  CXXTR
       PPM  CXXFL
       EJC
*
*      Compare pairs
*
CMPV4  MOV  (XS),XL          reload left
       JSR  PRCMP            compare dom and rng
       PPM  CXXTR
       PPM  CXXFL
*
*      Here for other aggregates - fail immediately if
*      different numbers of elements
*
CMPV5  MOV  (XS),XL          reload left (surprise)
       BNE  STNEL(XL),STNEL(XR),CXXFL compare cardinalities
       BEQ  (XL),=B$TPL,CMPV6 jump with tuple
       JSR  STCMP            compare sets or maps
       PPM  CXXTR
       PPM  CXXFL
*
*      Here to compare tuples
*
CMPV6  JSR  TPCMP            call the procedure
       PPM  CXXTR
       PPM  CXXFL
*
*
*      Here if types differed - only chance is TPBLK
*      with 2 elements might be equal to a pair
*
CMPV7  BEQ  (XL),=B$PRL,CMV71 jump if XL pair
       BNE  (XR),=B$PRL,CEXFL no chance
       MOV  XL,WA
       MOV  XR,XL
       MOV  WA,XR
*
*      Here with a pair in (XL)
*
CMV71  BNE  (XR),=B$TPL,CEXFL not a chance
       BNE  TPNEL(XR),=NUM02,CEXFL still no good
       JSR  TUPPR            convert (XR) to a pair
       BRN  CMV00            merge to try with these
*      Exit if operands equal
*
CXXTR  MOV  (XS)+,XL
       MOV  (XS)+,XR
       MOV  (XS)+,WC
       MOV  (XS)+,WA
CEXTR  EXI  1
*
*      Exit if operands not equal
*
CXXFL  MOV  (XS)+,XL
       MOV  (XS)+,XR
       MOV  (XS)+,WC
       MOV  (XS)+,WA
CEXFL  EXI  2
       ENP
       EJC
*
*      COPYV -- copy a value
*
*      Since SETL assignments are not allowed to lead to
*      shared pointers, aggregate values (sets, tuples and maps)
*      sometimes have to be copied.  Note that unstructured
*      values and strings do not need copying since modification
*      always produces a copy anyway.
*
*      (XR)                  Value to be copied
*      JSR  COPYV
*      (XL)                  Copy of value
*      (WA)                  Destroyed
*
COPYV  PRC  R,0
       BEQ  (XR),=B$PRL,CPV40 jump with pair
       BEQ  (XR),=B$STL,CPV50 jump with set
       BEQ  (XR),=B$MPL,CPV50 or map
       BEQ  (XR),=B$TPL,CPV10 jump with tuple
*
       MOV  XR,XL
       EXI
*
*      Here to copy a tuple
*
CPV10  MOV  TPNEL(XR),WA     Get number of elements
       MOV  XR,-(XS)         stack original
       JSR  ALOTS            get a block for copy
       MOV  =B$TPL,(XR)      set its type word
       MOV  XR,-(XS)         and save it
       MOV  =NUM01,WA        initialise index
       MOV  WA,-(XS)         and save that, too
*
CPV20  MOV  OFFS2(XS),XR         get original
       JSR  TPELT            fetch an element
       PPM  CPV30            exit from loop if through
       JSR  COPYV            copy element if necessary
       MOV  (XS),WA          retrieve index
       MOV  XL,XR            copy copy
       MOV  OFFS1(XS),XL         load new block pointer
       JSR  ADTEL            and add new element
       ICV  (XS)             increment index
       MOV  (XS),WA          and reload it
       BRN  CPV20
*
*      Here after copying is complete
*
CPV30  ICA  XS               throw away offset
       MOV  (XS)+,XL         fetch result
       MOV  (XS)+,XR         and restore for caller
       EXI
       EJC
*
*      Here to copy a pair
*
CPV40  MOV  XR,-(XS)         stack original
       MOV  *PRSI$,WA        load size for a pair
       ZER  XL                 for gbcol
       JSR  ALLOC            allocate a fresh block
*
*      Clear some words for protection from GBCOL
*
       ZER  PRDOM(XR)
       ZER  PRRNG(XR)
       ZER  PRNXT(XR)
       MOV  =B$PRL,(XR)      set type word
       MOV  XR,-(XS)         now stack block
       MOV  OFFS1(XS),XL         and recover original
       MOV  PRDOM(XL),XR     get domain
       JSR  COPYV            copy it if necessary
       MOV  (XS),XR          get new block
       MOV  XL,PRDOM(XR)     set field
       MOV  OFFS1(XS),XL         get original
       MOV  PRRNG(XL),XR     get second value
       JSR  COPYV            copy that
       MOV  (XS)+,XR         unstack result
       MOV  XL,PRRNG(XR)     set range value
       MOV  XR,XL            set for reurn
       MOV  (XS)+,XR         original for caller
       EXI
       EJC
*
*      Here to copy a set/map
*
CPV50  MOV  STNEL(XR),WA     get number of elements
       MOV  XR,-(XS)         and stack the original
       JSR  ALOTS            allocate a fresh block
       MOV  (XS),XL          load original
       MOV  XR,-(XS)         save this
       MOV  (XL),(XR)        set type word
       ZER  TPNEL(XR)        and clear number of elements
       MOV  XL,XR            now copy old block ptr
       MOV  *STSI$,XL        initialise as iterator offset
*
CPV51  JSR  NEXTS            fetch an element
       BNZ  WB,CPV53         jump if back to start
       BEQ  XR,=OMEGA,CPV52  ignore OMs
       MOV  XL,-(XS)         save
       JSR  COPYV            copy element
       MOV  XL,XR            get copy
       MOV  OFFS1(XS),XL         and new block
       JSR  ADSEL            shove it in
       MOV  XL,OFFS1(XS)         and save updated set
       MOV  (XS)+,XL         now get iterator thing off stack
CPV52  MOV  OFFS1(XS),XR         reload old block
       BRN  CPV51
*
*      Here after the undignified register juggling has
*      effected the copy.
*
CPV53  MOV  (XS)+,XL         load copy
       MOV  (XS)+,XR         and original
       EXI
       ENP
       EJC
*
*      CDWRD -- generate one word of code
*
*      CDWRD writes one word into the current code block under
*      construction. A new, larger, block is allocated if there
*      is insufficient room in the current block. CDWRD ensures
*      that there are at least three words left in the block
*      after entering the new word. This guarantees that any
*      extra space at the end can be split off as a CCBLK.
*
*      (WA)                  word to be generated
*      JSR  CDWRD            call to generate word
*
CDWRD  PRC  E,0              Entry point
       MOV  XR,-(XS)         Save entry XR
       MOV  WA,-(XS)         Save code word to be generated
*
*      Merge back here after allocating larger block
*
CDWD1  MOV  R$CCB,XR         Load ptr to CCBLK being built
       BNZ  XR,CDWD2         Jump if block allocated
*
*      Here we allocate an entirely fresh block
*
       MOV  *E$CBS,WA        Load initial length
       JSR  ALLOC            Allocate CCBLK
       MOV  =B$CCT,(XR)      Store type word
       MOV  *CCCOD,CWCOF     Set initial offset
       MOV  WA,CCLEN(XR)     Store block length
       MOV  XR,R$CCB         Store ptr to new block
*
*      Here we have a block we can use
*
CDWD2  MOV  CWCOF,WA         Load current offset
       ADD  *NUM04,WA        Adjust for test (four words)
       BLO  WA,CCLEN(XR),CDWD4 Jump if room in this block
*
*      Here if no room in current block
*
       BGE  WA,MXLEN,CDWD5   Jump if already at max size
       ADD  *E$CBS,WA        Else get new size
       MOV  XL,-(XS)         Save entry XL
       MOV  XR,XL            Copy pointer
       BLT  WA,MXLEN,CDWD3   Jump if not too large
       MOV  MXLEN,WA         Else reset to max allowed size
       EJC
*
*      CDWRD (continued)
*
*      Here with new block size in WA
*
CDWD3  JSR  ALLOC            Allocate new block
       MOV  XR,R$CCB         Store pointer to new block
       MOV  =B$CCT,(XR)+     Store type word in new block
       MOV  WA,(XR)+         Store block length
       ADD  *CCUSE,XL        Point to CCUSE,CCCOD fields in old
       MOV  (XL),WA          Load CCUSE value
       MVW                   Copy useful words from old block
       MOV  (XS)+,XL         Restore XL
       BRN  CDWD1            Merge back to try again
*
*      Here with room in current block
*
CDWD4  MOV  CWCOF,WA         Load current offset
       ICA  WA               Get new offset
       MOV  WA,CWCOF         Store new offset
       MOV  WA,CCUSE(XR)     Store in CCBLK for GBCOL
       DCA  WA               Restore ptr to this word
       ADD  WA,XR            Point to current entry
       MOV  (XS)+,WA         Reload word to generate
       MOV  WA,(XR)          Store word in block
       MOV  (XS)+,XR         Restore entry XR
       EXI                   Return to caller
*
*      Here if compiled code is too long for CDBLK
*
CDWD5  ERB  099,statement is too complicated
       ENP                   End procedure CDWRD
       EJC
*
*      CHKCP -- check for copy
*
*      Called from CDGEN to ascertain whether an operand needs
*      copying before assigning, adding to a set or (eventually)
*      passing to a procedure.
*
*      (XL)                  pointer to tree node to be checked
*      JSR  CHKCP
*      PPM  loc              return if no copy needed
*      (normal return)       copy is required
*      (XL)                  destroyed
*
CHKCP  PRC  R,1
       BEQ  (XL),=B$VRL,CHKP1 variable needs copying
       BNE  (XL),=B$CMT,CHKP2 other leaves do not
       BEQ  CMTYP(XL),=C$ASS,CHKP1 assop expression does
       BEQ  CMTYP(XL),=C$SUB,CHKP3 subscripted might
       BNE  CMTYP(XL),=C$SBM,CHKP2 otherwise ok
CHKP3  MOV  CMSXP(XL),XL     see what is being subscripted
       JSR  CHKCP            investigate recursively
       PPM  CHKP2            pass result down
*
*      Normal exit merges here
*
CHKP1  EXI
*
*      Cases which are ok merge here
*
CHKP2  EXI  1
       EJC
*
*      CHKMP -- check whether set is a map
*
*      It is possible for a set to turn into a map, by
*      removal of non-pairs.  CHKMP is called whenever
*      this might matter, to see whether this has happened
*      and, if it has, to reset the type word.  CHKMP also
*      sees whether any tuples of length 2 are present, and
*      if so, converts them to pairs and puts them in their
*      proper places.
*
*      (XR)                  ptr to STBLK
*      JSR  CHKMP
*      PPM  loc              it was a map
*      normal return         a set
*      (WA, WB, XL)          must be collectable
*
CHKMP  PRC  E,1
       MOV  WB,-(XS)         save for caller
       MOV  XL,-(XS)
       MOV  WA,-(XS)
*
*      Look at elements one at a time
*
       MOV  *STSI$,XL        initial offset
       MOV  XR,-(XS)         stack arg
*
CHM10  JSR  NEXTS            call for next element
       BNZ  WB,CHM11         jump if done
       BEQ  XR,=OMEGA,CHM20  skip OMs
       BEQ  (XR),=B$PRL,CHM20 get another if pair
       BNE  (XR),=B$TPL,CHM11 not map if not tuple
       BNE  TPNEL(XR),=NUM02,CHM11 of length 2
*
*      Here we found a tuple of length 2
*      (cannot be on a chain)
*
       MOV  XL,WB            save
       ADD  (XS),XL          add base of set
       ZER  (XL)             remove tuple
       MOV  WB,XL            recover
       JSR  TUPPR            convert to PRBLK
       MOV  XL,-(XS)         save
       MOV  OFFS1(XS),XL         load set
       JSR  ADSEL            add PRBLK
       MOV  XL,OFFS1(XS)         and update set
       MOV  (XS)+,XL         recover
*
CHM20  MOV  (XS),XR          reload set
       BRN  CHM10            loop
       EJC
*
*      Here on exit from loop - (WB) non zero means
*      we only found pairs.
*      First restore some registers
*
CHM11  MOV  (XS)+,XR
       MOV  (XS)+,WA
       MOV  (XS)+,XL
       BZE  WB,CHM12
*
*      The set was a map
*
       MOV  =B$MPL,(XR)
       MOV  (XS)+,WB
       EXI  1
*
*      No it wasnt
*
CHM12  MOV  (XS)+,WB
       EXI
       ENP
       EJC
*
*      CHKST -- check state of stack
*
*      CHKST determines whether statement just compiled will
*      have left a result on stack, and, if so, compiles code
*      to get rid of it
*
*      (XL)                  ptr to CMBLK for last statement
*      JSR  CHKST
*      (WA)                  destroyed
*
CHKST  PRC  E,0
       BZE  XL,CHKS2         straight out if empty
       BEQ  CMTYP(XL),=C$STM,CHKS2 jump if block
       BEQ  CMTYP(XL),=C$ASS,CHKS1 assignment does
       BEQ  CMTYP(XL),=C$CAL,CHKS1 so does proc call
       BNE  CMTYP(XL),=C$BOP,CHKS2 only FROMx left
       BEQ  CMOPR(XL),=O$FRM,CHKS1
       BEQ  CMOPR(XL),=O$FRE,CHKS1
       BNE  CMOPR(XL),=O$FRB,CHKS2
*
*      Here with expressions used as staements - assignments,
*      FROM things and procedure calls
*
CHKS1  MOV  =O$POP,WA
       JSR  CDWRD
CHKS2  EXI
       ENP
       EJC
*
*      CMBLD -- build a compiler block (CMBLK)
*
*      (WA)                  length in BAUs
*      (WB)                  C$xxx type code
*      (XS), 1(XS)..         CMVLS
*      JSR  CMBLD
*      (XR)                  ptr to CMBLK
*
CMBLD  PRC  N,0
       ZER  XL               JVK-in case of GBCOL
       JSR  ALLOC            allocate a block
       MOV  =B$CMT,(XR)      it s a CMBLK
       MOV  WA,CMLEN(XR)     set its length field
       MOV  WB,CMTYP(XR)     and the type code
       MOV  XR,XL            get a copy of pointer
       ADD  WA,XL            point past end
       ADD  *CMVLS,XR        point to last field to be set
*
*      Now loop, unstacking values and setting them into the
*      block.  Net effect is to store values at CMVLS onwards
*      in the order in which they were stacked by the caller.
*
CMB10  BEQ  XL,XR,CMB20      check whether done
       MOV  (XS)+,-(XL)      set a word
       BRN  CMB10            loop
*
CMB20  SUB  *CMVLS,XR        point back to start of CMBLK
       ZER  XL               clear garbage
       EXI
       ENP
       EJC
*
*      CMPIL -- compile source code
*
*      CMPIL is used to convert Setl-s source code into internal
*      form (see CDBLK format).  It is used to parse the code,
*      generate an abstract syntax tree (see CMBLK format), and
*      then the code blocks.
*
*      This is the main parser loop, using the LPG LALR parse
*      tables to permit some optimizations.  It is called once
*      from the program initialization.  When reduce actions are
*      taken, the TNBLD call will build the abstract syntax tree
*      and then generate the code (indirect threaded code) for
*      each procedure and the main program.
*
*      JSR  CMPIL            call to parse and compile code
*
*      The following global locations are used:
*
*      ACTLR                 code for current action
*      CTOKN                 LALR code for current token
*      SCNXL                 XL value from SCANE - token nbr
*      SCNXR                 XR value from SCANE - token blk
*
CMPIL  PRC  E,0              entry point
       ZER  WA               clear for SCANE
       ZER  WB
       ZER  SCNRS            init get new token
       JSR  SCANE
       MOV  XL,SCNXL         save output
       MOV  XR,SCNXR
*
       ICV  XL               shift 0+ to 1+ as index into nosym map
       WTB  XL                 and get offset
       MOV  R$SNM,XR
       ADD  XL,XR            addr of symno entry
       MOV  (XR),CTOKN       save entry as LALR token number
*
       MOV  =P$SST,ACTLR     init start state
*
*      Main parser loop here
*
CMPL1  MOV  ACTLR,-(XS)      push current state
       JSR  TACTN            get next action - update ACTLR
*
*      Check what action to be taken
*
       BGT  ACTLR,=NMRUL,CMPL4 Check if reduce action
*
*      Here to reduce
*      Loop if multiple reductions possible
*
CMPL3  MOV  ACTLR,XL         get offset into RHS
       WTB  XL
       MOV  R$RHS,XR        select entry in RHS table
       ADD  XL,XR              to entry
       MOV  (XR),XL          entry is size of RHS
       ADD  XL,XL            number of symbol, state pairs
       ICV  XL               plus one for this counter
       MOV  XL,-(XS)         stack nbr of symbols to pop
       JSR  TNBLD            perform semantic actions
       MOV  (XS),XL          nbr items to pop
       WTB  XL
       ADD  XL,XS            reset stack ptr
*
       MOV  ACTLR,XL         get offset into LHS
       WTB  XL
       MOV  R$LHS,XR        select entry in LHS table
       ADD  XL,XR
       MOV  (XR),XL          get code of non-term on LHS
*
*      Compute new state
*
       ADD  (XS),XL          add prior state
       SUB  =NMRUL,XL        adjust to 1.. index
       WTB  XL               get offset at state+nonterm
       MOV  R$ACT,XR        get action table
       ADD  XL,XR            entry at action(state + nonterm)
       MOV  (XR),ACTLR
       MOV  R$SRP,-(XS)      push new node on semantic stack
       MOV  ACTLR,-(XS)        and new state
       BLE  ACTLR,=NMRUL,CMPL3 see if we can reduce again
*
       ICA  XS               pop ACTLR from stack
       BRN  CMPL1            if done, return to main parser loop
*
CMPL4  BLE  ACTLR,=P$ERA,CMPL5 Compare ACT to ErrorAction
*
*      Here to Shift-Reduce
*
       MOV  SCNXR,-(XS)      stack old token
       ZER  WA               Clear for SCANE
       ZER  WB
       JSR  SCANE
       MOV  XL,SCNXL         save output
       MOV  XR,SCNXR
*
       ICV  XL               shift 0+ to 1+ as index into nosym map
       WTB  XL                 and get offset
       MOV  R$SNM,XR
       ADD  XL,XR            addr of symno entry
       MOV  (XR),CTOKN       save entry as LALR token number
*
       SUB  =P$ERA,ACTLR     Compute ACTLR as rule nbr
       MOV  ACTLR,-(XS)        and stack new state
       BRN  CMPL3            Now merge to reduce
*
CMPL5  BGE  ACTLR,=P$ACC,CMPL6 Check if shift action
*
*      Here to shift
*
       MOV  SCNXR,-(XS)      stack the old token
       ZER  WA               Clear for SCANE
       ZER  WB
       JSR  SCANE
       MOV  XL,SCNXL         save output
       MOV  XR,SCNXR
*
       ICV  XL               shift 0+ to 1+ as index into nosym map
       WTB  XL                 and get offset
       MOV  R$SNM,XR
       ADD  XL,XR            addr of symno entry
       MOV  (XR),CTOKN       save entry as LALR token number
*
       BRN  CMPL1            then return to parser loop
*
CMPL6  BNE  ACTLR,=P$ACC,CMPL7 Check if accept action
*
*      Here to accept
*
       ADD  *NUM03,XS        Clean up state stack
       EXI                   Compilation done, return to execute
*
*      Here if parse error
*
CMPL7  ERB  008,syntax error
*
       ENP
       EJC
*
*      DFFNC -- define function (dummy routine)
*
*      JVK - included only for compatability with OSINT routines
*
DFFNC  PRC  E,0
       EXI
       ENP
       EJC
*
*      DFINT -- perform set difference or intersction
*
*      The logic of these two operations is so similar
*      that one procedure is used to handle both
*
*      (XL)                  arg1 STBLK or MPBLK
*      (XR)                  arg2
*      JSR  DFINT
*      (XR)                  ptr to result
*
*      The global location DFFLG is used to determine
*      which operation to perform - if non-zero the
*      difference (XL) - (XR) is computed, else the
*      intersection of the two.
*
       EJC
DFINT  PRC  E,0
       MOV  XR,-(XS)
       MOV  XL,-(XS)
       MOV  =NLSET,DIRES     initially result is null set
       MOV  *STSI$,XL        initialise as set iterator
*
DFI10  MOV  (XS),XR          load arg1 ptr
       JSR  NEXTS            fetch an element
       BNZ  WB,DFI20         quit if wraparound
       MOV  XL,-(XS)         save updated iterator
       BEQ  XR,=OMEGA,DFI30  skip OMs
       MOV  OFFS2(XS),XL         load arg2
       JSR  FINDS            look for element
       PPM  DFI11            found
       PPM  DFI12            not
       PPM  DFI12            not
*
*      Here a member of (XL) was found in (XR)
*
DFI11  BNZ  DFFLG,DFI30      dont want for difference
*
*      Merge to add amember to result
*
DFI13  JSR  COPYV            copy it first
       MOV  DIRES,XL         load result ptr
       JSR  ADSEL            add new element
       MOV  XL,DIRES         update
       BRN  DFI30
*
*      Here if we failed to find an element
*
DFI12  BNZ  DFFLG,DFI13      go add it if difference
*
DFI30  MOV  (XS)+,XL         unstack iterator
       BRN  DFI10            and loop
*
*      Here when done
*
DFI20  ICA  XS               popoff old (XR)
       MOV  (XS)+,XL         recover
       MOV  DIRES,XR         result for caller
       EXI
       ENP
       EJC
*
*      DFSST -- compute symmetric difference of sets
*
*      (XL)                  arg1 STBLK or MPBLK
*      (XR)                  arg2
*      JSR  DFINT
*      (XR)                  ptr to result
*
*      The global location REMCT is used to determine
*      whether pass 1 or 2.  Each pass places into the
*      result elements of one set which are not in the
*      other.
*
       EJC
DFSST  PRC  E,0
       MOV  XR,-(XS)         save args
       MOV  XL,-(XS)
       MOV  =NLSET,DIRES     initially result is null set
       MNZ  REMCT            set for pass 1
       MOV  *STSI$,XL        initialise as set iterator
*
DFSS1  MOV  (XS),XR          load arg1 ptr
       JSR  NEXTS            fetch an element
       BNZ  WB,DFSS6         quit if wraparound
       MOV  XL,-(XS)         save updated iterator
       BEQ  XR,=OMEGA,DFSS5  skip OMs
       MOV  OFFS2(XS),XL         load arg2
       JSR  FINDS            look for element
       PPM  DFSS5            found
       PPM  DFSS2            not
       PPM  DFSS2            not
*
*      If not in 2nd set, add member to result
*
DFSS2  JSR  COPYV            copy it first
       MOV  DIRES,XL         load result ptr
       JSR  ADSEL            add new element
       MOV  XL,DIRES         update
*
DFSS5  MOV  (XS)+,XL         unstack iterator
       BRN  DFSS1            and loop
*
*      Done with a pass, check if another pass needed
*
DFSS6  BZE  REMCT,DFSS7      jump if done with both passes
       ZER  REMCT            prep for pass 2
       MOV  (XS)+,XL         swap order of operands on stack
       MOV  (XS)+,XR
       MOV  XL,-(XS)
       MOV  XR,-(XS)
       MOV  *STSI$,XL        init offset again
       BRN  DFSS1            and proceed to pass 2
*
*      Here when done
*
DFSS7  ICA  XS               discard operands
       ICA  XS
       MOV  DIRES,XR         result for caller
       EXI
       ENP
       EJC
*
*      DSCLB -- discard labels
*
*      (WA)                  number of labels to be discarded
*      JSR  DSCLB
*      (WA,XR)                destroyed
*
DSCLB  PRC  E,0
       LCT  WA,WA            prepare a loop counter
       MOV  LBNUM,XR         fetch current value
       ADD  R$LBV,XR         add base address of table
*
*      Loop backwards, unsetting the label table entries for
*      discarded labels - note that initial value of LBNUM
*      is 1 greater than highest we want to unset
*
DSL01  DCA  XR               point back one
       ZER  (XR)             clear table entry
       BCT  WA,DSL01
*
*      Fall through after clearing required number of entries
*
       SUB  R$LBV,XR         get back label number
       MOV  XR,LBNUM         store new value
       BGT  XR,LSLAB,DSL02   check current label
       ZER  LSLAB
DSL02  EXI
       ENP
       EJC
*
*      DTYPE -- get datatype name
*
*      (XR)                  object whose datatype is required
*      JSR  DTYPE            call to get datatype
*      (XR)                  result datatype
*
DTYPE  PRC  E,0              Entry point
       MOV  (XR),XR          Load type word
       LEI  XR               Get entry point id (block code)
       WTB  XR               Convert to bau offset
       MOV  SCNMT(XR),XR     Load table entry
       EXI                   Exit to DTYPE caller
       ENP                   End procedure DTYPE
       EJC
*
*      ERMSG -- print error code and error message
*
*      ERCOD                 error code
*      JSR  ERMSG            call to print message
*      (XR,XL,WA,WB,WC,IA)   destroyed
*
ERMSG  PRC  E,0              Entry point
       JSR  PRTIS            Print error ptr or blank line
       MOV  ERCOD,WA         Load error code
       MOV  =ERMMS,XR        Point to error message /error/
       JSR  PRTST            Print it
       JSR  ERTEX            Get error message text
       ADD  =THSND,WA        Bump error code for print
       MTI  WA               Fail code in int acc
       JSR  PRTIN            Print code (now have error1XXX)
       MOV  PRBUF,XL         Point to print buffer
       PSC  XL,=NUM05        Point to the 1
       MOV  =CH$BL,WA        Load a blank
       SCH  WA,(XL)          Store blank over 1 (error XXX)
       CSC  XL               Complete store characters
       ZER  XL               Clear garbage pointer in XL
       MOV  XR,WA            Keep error text
       MOV  =ERDSH,XR        Point to / -- /
       JSR  PRTST            Print it
       MOV  WA,XR            Get error text again
       JSR  PRTST            Print error message text
       JSR  PRTIS            Print line
       JSR  PRTIS            Print blank line
       EXI                   Return to ERMSG caller
       ENP                   End procedure ERMSG
       EJC
*
*      ERTEX -- get error message text
*
*      (WA)                  error code
*      JSR  ERTEX            call to get error text
*      (XR)                  ptr to error text in dynamic
*      (R$ETX)               copy of ptr to error text
*      (XL,WC,IA)            destroyed
*
ERTEX  PRC  E,0              Entry point
       MOV  WA,ERTWA         Save WA
       MOV  WB,ERTWB         Save WB
       JSR  SYSEM            Get failure message text
       MOV  XR,XL            Copy pointer to it
       MOV  SCLEN(XR),WA     Get length of string
       BZE  WA,ERT02         Jump if null
       ZER  WB               Offset of zero
       JSR  SBSTR            Copy into dynamic store
       MOV  XR,R$ETX         Store for relocation
*
*      Return
*
ERT01  MOV  ERTWB,WB         Restore WB
       MOV  ERTWA,WA         Restore WA
       EXI                   Return to caller
*
*      Return errtext contents instead of null
*
ERT02  MOV  R$ETX,XR         Get errtext
       BRN  ERT01            Return
       ENP
       EJC
*
*      EXPIC -- integer exponentiation
*
*      Performs exponentiation for integer base, positive
*      integer exponent (tested prior to call) only.
*
*      (XR)                  ptr to positive exponent ICBLK
*      (XL)                  ptr to base ICBLK
*      JSR  EXPIC
*      (XR)                  ptr to result ICBLK
*      (WA,WB,IA,XL)         destroyed
*
*  Memory refs:
*      EXPBS                 base value
*      EXPAC                 accumulator
*
EXPIC  PRC  E,0
       MOV  ICVAL(XR),WB     exp value
       MOV  ICVAL(XL),EXPBS  base value
       LDI  EXPBS
       INE  EXP01            jump if non-zero base
*
       BNZ  WB,EXP09         check if exp is 0
       ERB  007,exponentiation error of zero ** zero
EXP09  LDI  INTV0            if 0 base, result 0
       BRN  EXP11
*
*      Here for non-zero base
*
EXP01  IGT  EXP02            jump if pos base
       MOV  =NUM01,WA        set mask
       ANB  WB,WA            check if even exponent
       BZE  WA,EXP02         if so, result positive
*
       MNZ  -(XS)            indicate neg sign
       NGI                     and use negative
       STI  EXPBS            save new base
       BRN  EXP03
*
*      Positive base or even exponent
*
EXP02  ZER  -(XS)            save sign info
EXP03  MOV  =NUM01,EXPAC     init accum at 1
*
*      Main loop
*
       BZE  WB,EXP10         done if 0 exp
EXP04  MOV  =NUM01,WA        set mask bit
       ANB  WB,WA            check rightmost bit of exp
       BZE  WA,EXP05         jump if 0 bit
*
       LDI  EXPAC            1 bit, load accum
       MLI  EXPBS            mult by base
       IOV  EXP20
       STI  EXPAC            save accum
*
EXP05  RSH  WB,1             exp = exp div 2
       BZE  WB,EXP10
*
       LDI  EXPBS            base = base ** 2
       MLI  EXPBS
       IOV  EXP20
       STI  EXPBS
       BRN  EXP04
*
EXP10  LDI  EXPAC            get result accum
       MOV  (XS)+,WA
       BZE  WA,EXP11         check orig sign
       NGI
EXP11  ZER  XL               in case of gbcol
       JSR  ICBLD            create ICBLK at XR
       EXI
*
EXP20  ERB  023,exponentiation caused integer overflow
       ENP
       EJC
.IF    .CSFN
*
*      FILNM -- obtain file name from statement number
*
*      Abbreviated version for SETLS.  Included here only for
*      compatibility with updated versions of OSINT.  SETLS
*      currently has no TEBLKs or file name table.  The syntax
*      does not permit the multiple input file setup.
*
*      FILNM takes a statement number and examines the file name
*      table pointed to by R$SFN to find the name of the file
*      containing the given statement.  Table entries are
*      arranged in order of ascending statement number (there
*      is only one hash bucket in this table).  Elements are
*      added to the table each time there is a change in
*      file name, recording the then current statement number.
*
*      To find the file name, the linked list of TEBLKs is
*      scanned for an element containing a subscript (statement
*      number) greater than the argument statement number , or
*      the end of the chain.  When this condition is met, the
*      previous TEBLK contains the desired file name as its
*      value entry.
*
*      (WC)                  Statement number
*      JSR  FILNM            Call to obtain file name
*      (XL)                  File name (SCBLK)
*      (IA)                  Destroyed
*
FILNM  PRC  E,0              Entry point
       MOV  WB,-(XS)         Preserve WB
       BZE  WC,FILN3         Return NULLS if StNo is zero
       MOV  R$SFN,XL         File name table (zero)
       BZE  XL,FILN3         Jump if no table
*
*      Section omitted here
*
FILN3  MOV  (XS)+,WB         Restore WB
       MOV  =NULLS,XL        Return null string
       EXI
       ENP
       EJC
.FI
*
*      FINDD -- find domain in a map
*
*      FINDD searches a map, for pairs with a given dom value
*      returning an R-value and an L-value (loosely speaking)
*
*      (XR)                  element sought
*      (XL)                  pointer to set/map
*      JSR  FINDD
*      PPM  loc              object found
*      PPM  loc              not found - empty slot encountered
*      PPM  loc              not found - set full
*      normal return is never taken
*
*      (XL)                  If found, ptr to entry in table,
*                            else, ptr to first empty slot
*      (XR)                  If found, ptr to actual object,
*                            else argument
*      (WA)                  Destroyed
*      If 3rd exit is taken, XR and XL are restored to their
*      entry values.
*
*
*      FINDD is virtually identical to FINDS, which should
*      be consulted for details of the tables used.
*      JVK revision - attempts to re-use dead entries.
*
       EJC
FINDD  PRC  R,3
       CHK                   sets of sets of sets of ....
       BEQ  XL,=NLSET,FDD05  bound to fail for null
       MOV  XR,-(XS)         hasty save
       JSR  HASHV            get a hash for element
       MOV  (XS)+,XR         and recover
       MFI  WA               hold onto it
*
*      Some silly juggling in and out of IA, to compute
*      initial probe offset.
*
       MOV  STLEN(XL),WC     load block length
       BTW  WC               convert to words
       SUB  =STSI$,WC        get number of slots
       MTI  WC               convert to integer
       STI  FINDL            save it
       MTI  WA               reload hash
       RMI  FINDL            get in range
       MOV  XR,-(XS)         save argument
       ZER  -(XS)            init no dead entries found
       MOV  XL,XR            and copy set pointer
       MFI  XL               get hash
       WTB  XL               convert to BAUs
       ADD  *STSI$,XL        add initial offset
       MOV  XL,-(XS)         save iterator thingy
*
*      (XL) is now set up as set iterator, so we loop,
*      looking for a match.
*      We have to count the loops, because wraparound could
*      occur anytime.
*
       MOV  STLEN(XR),WC     JVK-count for number of slots
       SUB  *STSI$,WC
       BTW  WC
*
       LCT  WC,WC
       MOV  XR,WA            save set
FDD01  MOV  XL,-(XS)         JVK-save offset
       ADD  XR,XL            get addrs of entry
       BZE  (XL),FDD21       jump if dead entry
       MOV  (XS)+,XL         recover offset
*
FDD11  JSR  NEXTS            get next member
       BEQ  XR,=OMEGA,FDD07  jump if not found-free slot
       BNE  (XR),=B$PRL,FDD31
       MOV  XL,-(XS)         stack offset/ptr
       MOV  OFFS3(XS),XL         reload argument
       MOV  WC,-(XS)         hold on to loop count
       MOV  WA,-(XS)         and set
       MOV  PRDOM(XR),XR     only want domain value
       JSR  COMPV            compare the values
       PPM  FDD06            not equal
       PPM  FDD02            equal
FDD02  MOV  (XS)+,WA         get back set
       MOV  (XS)+,WC         get back loop counter
       MOV  (XS)+,XL         and iterator
       MOV  WA,XR            load set (copied by nexts)
       BGT  XL,MXLEN,FDD11   jump with pointer
       BRN  FDD03
*
*      Here if dead entry
*
FDD21  MOV  (XS)+,XL         JVK-recover offset of dead entry
       BNZ  OFFS1(XS),FDD22  skip if had prior dead entry
       MOV  XL,OFFS1(XS)     save offset of 1st dead entry only
FDD22  ICA  XL               skip it
*
FDD03  BLT  XL,STLEN(XR),FDD32 jump if no wrap
       MOV  *STSI$,XL        wrap to first element
       BRN  FDD32
*
*      Here if entry not pair
*
FDD31  MOV  WA,XR            not pair-recover set
FDD32  MOV  XL,(XS)          else update slot offset
       BCT  WC,FDD01
*
*      Only fall through if set is full and object not found
*
       BNZ  OFFS1(XS),FDD09  jump if prior dead entry found
       MOV  WA,XL            recover
       ICA  XS               pop the offset
       ICA  XS                 and dead save
       MOV  (XS)+,XR         restore XR
FDD05  EXI  3
       EJC
*
*      Here if we succeeded
*
FDD06  MOV  (XS)+,WA         recover set
       ADD  *NUM02,XS        pop away local saves
       MOV  WA,XL            copy set pointer
       BGT  STLEN(XL),(XS),FDD61 jump if not offset past end
       MOV  *STSI$,(XS)      re-initialise
FDD61  MOV  (XS)+,XL         get latest offset (L-value)
       ADD  WA,XL            now pointer to slot
       MOV  (XL),XR          point to first on chain
       ICA  XS               discard dead save
       ICA  XS               discard argument
       EXI  1
*
*      Here if OM entry was found
*
FDD07  BNZ  OFFS1(XS),FDD09  jump if prior dead entry found
       MOV  (XS)+,XL         this will be latest offset
       MOV  WA,XR            copy set pointer
       BGT  STLEN(XR),XL,FDD08 check not over end
       MOV  *STSI$,XL
FDD08  ADD  WA,XL            point to OM slot
       ICA  XS               discard dead save
       MOV  (XS)+,XR         pop argument
       EXI  2
*
*      Here if not found, but dead entry available
*
FDD09  ICA  XS               discard current offset
       MOV  (XS)+,XL         recover offset to first dead entry
       ADD  WA,XL            point to dead slot
       MOV  (XS)+,XR         pop argument
       EXI  2
       ENP
       EJC
*
*      FINDS -- find element in a set
*
*      FINDS searches a set or map for a specified element,
*      returning an R-value and an L-value (loosely speaking)
*      This is fundamental to nearly all set/map operations.
*
*      (XR)                  element sought
*      (XL)                  pointer to set/map
*      JSR  FINDS
*      PPM  loc              object found
*      PPM  loc              not found - empty slot encountered
*      PPM  loc              not found - set full
*      normal return is never taken
*
*      (XL)                  If found, ptr to entry in table,
*                            else, ptr to first empty slot
*      (XR)                  If found, ptr to actual object,
*                            else argument
*      (WA)                  Destroyed
*      If 3rd exit is taken, XR and XL are restored to their
*      entry values.
*
*      Sets and maps are linear hash tables, except that
*      pairs with identical domain values are chained together
*      from the same entry.
*      OM is used to indicate an empty entry, 0 a deleted one.
*      The end of a PRBLK chain is indicated by the PRNXT field
*      having the index of the next slot in the hash table,
*      instead of a pointer to the next on the list - this can
*      be detected by a simple test for a non-pointer.
*
*      Even though sets are re-hashed when 80percent full, the
*      calculation does not take account of dead entries, so in
*      fact, a set can get full and the third exit be taken.
*      JVK repair - dead entries to be re-used.
*
*      FINDS can get called recursively via COMPV and STCMP.
*
       EJC
FINDS  PRC  R,3
       CHK                   sets of sets of sets of ....
       BEQ  XL,=NLSET,FND04  bound to fail for null
       MOV  XR,-(XS)         hasty save
       JSR  HASHV            get a hash for element
       MOV  (XS)+,XR         and recover
       MFI  WA               hold onto it
*
*      Some silly juggling in and out of IA, to compute
*      initial probe offset.
*
       MOV  STLEN(XL),WC     load block length
       BTW  WC               convert to words
       SUB  =STSI$,WC        get number of slots
       MTI  WC               convert to integer
       STI  FINDL            save it
       MTI  WA               reload hash
       RMI  FINDL            get in range
       MOV  XR,-(XS)         save argument
       ZER  -(XS)            init no dead entries found
       MOV  XL,XR            and copy set pointer
       MFI  XL               get hash
       WTB  XL               convert to BAUs
       ADD  *STSI$,XL        add initial offset
       MOV  XL,-(XS)         save iterator thingy
*
*      (XL) is now set up as set iterator, so we loop,
*      looking for a match.
*      We have to count the loops, because wraparound could
*      occur anytime.
*
       MOV  STLEN(XR),WC     count for number of elements
       BTW  WC               JVK-word count less header
       SUB  =STSI$,WC
*
       LCT  WC,WC
       MOV  XR,WA            save set
FND01  MOV  XL,-(XS)         JVK-save offset
       ADD  XR,XL            get ptr to entry
       BZE  (XL),FND21       jump if dead entry
       MOV  (XS)+,XL         recover offset
*
FND11  JSR  NEXTS            get next member
       BEQ  XR,=OMEGA,FND06  jump if not found-free slot
       MOV  XL,-(XS)         stack offset/ptr
       MOV  OFFS3(XS),XL         reload argument
       MOV  WC,-(XS)         hold on to loop count
       MOV  WA,-(XS)         save set
       JSR  COMPV            compare the values
       PPM  FND05            equal
       PPM  FND02            not equal
FND02  MOV  (XS)+,WA         get back set
       MOV  (XS)+,WC         get back loop counter
       MOV  (XS)+,XL         and iterator
       MOV  WA,XR            load set (copied by nexts)
       BGT  XL,MXLEN,FND11   jump with pair pointer
       BRN  FND03
*
*      Here if dead entry
*
FND21  MOV  (XS)+,XL         JVK-recover offset
       BNZ  OFFS1(XS),FND22  skip if had prior dead entry
       MOV  XL,OFFS1(XS)     save offset of 1st dead entry only
FND22  ICA  XL               skip dead entry
*
FND03  BLT  XL,STLEN(XR),FND31 jump if no wrap
       MOV  *STSI$,XL        wrap to first element
*
FND31  MOV  XL,(XS)          update slot offset
       BCT  WC,FND01
*
*      Only fall through if set is full and object not found
*
       BNZ  OFFS1(XS),FND08  jump if dead entry available
       MOV  WA,XL            recover set
       ICA  XS               pop offset
       ICA  XS                 and dead save
       MOV  (XS)+,XR         restore XR
FND04  EXI  3
       EJC
*
*      Here if we succeeded
*
FND05  MOV  (XS)+,WA         recover set
       ADD  *NUM02,XS        pop away local saves
       MOV  WA,XL            copy set pointer
       BGT  STLEN(XL),(XS),FND51 jump if not past end
       MOV  *STSI$,(XS)      reset
FND51  MOV  (XS)+,XL         get latest offset (L-value)
       ADD  WA,XL            now pointer to slot
       ICA  XS               discard dead save
       ICA  XS               discard argument
       EXI  1
*
*      Here if OM entry was found
*
FND06  BNZ  OFFS1(XS),FND08  jump if prior dead entry found
       MOV  (XS)+,XL         this will be latest offset
       MOV  WA,XR            copy set pointer
       BGT  STLEN(XR),XL,FND07 jump if ok
       MOV  *STSI$,XL        re-initialise iff over end
FND07  ADD  WA,XL            point to OM slot
       ICA  XS               discard dead save
       MOV  (XS)+,XR          pop argument
       EXI  2
*
*      Here if not found, but dead entry available
*
FND08  ICA  XS               discard current offset
       MOV  (XS)+,XL         recover offset of first dead entry
       ADD  WA,XL            point to dead slot
       MOV  (XS)+,XR         pop argument
       EXI  2
       ENP
       EJC
*
*      FMNPW -- form NPOW set
*
*      Given an ICBLK and STBLK(MPBLK), form and return NPOW
*
*      (XL)                  ptr to ICBLK
*      (XR)                  ptr to STBLK/MPBLK
*      JSR  FMNPW            call to form NPOW set
*      (XR)                  ptr to result STBLK
*      (XL,WA,WB,WC)         destroyed
*
FMNPW  PRC  E,0
       MOV  ICVAL(XL),WA     check subset size
       LDI  ICVAL(XL)
       ILT  XENPW            error if negative integer
       INE  FMNP1
*
*      Here for subsets of size 0
*
       MOV  =NUM01,WA
       JSR  ALOTS            alloc set for result
       MOV  =B$STL,(XR)
       ZER  STNEL(XR)
       MOV  XR,XL
       MOV  =NLSET,XR        only entry is null set
       JSR  ADSEL
       MOV  XL,XR
       EXI
*
*      Here if subset size n >= 1
*
FMNP1  MOV  STNEL(XR),WB
       BLE  WA,WB,FMNP2      compare subset size to set size
*
*      If subset size greater than set size, return null set
*
       MOV  =NLSET,XR
       EXI
*
FMNP2  MOV  WA,-(XS)         save subset size n
       JSR  SETTP            convert set to tuple of elts
       MOV  XR,-(XS)           save tuple
       MOV  XL,-(XS)           and selector
*
*      Initialize the n-selector
*
       MOV  OFFS2(XS),WC     retrieve subset size n
       ADD  *TPSI$,XL        point to first select entry
       LCT  WC,WC
FMNP3  MOV  =NUM01,(XL)+     insert n 1s in selector
       BCT  WC,FMNP3
*
       MOV  =NUM01,WA
       JSR  ALOTS            allocate npow result set
       MOV  =B$STL,(XR)
       ZER  STNEL(XR)
       MOV  XR,-(XS)         and save it
*
       MOV  OFFS1(XS),XL     retrieve selector
       MOV  OFFS2(XS),XR       and tuple
       JSR  SELST            form subset of selected elts
       MOV  (XS),XL          retrieve npow set
       JSR  ADSEL            add new elt
       MOV  XL,(XS)          save if update
*
*      Main loop - repeat until selector = last
*
FMNP4  MOV  OFFS1(XS),XR     retrieve selector
       MOV  TPNEL(XR),WB     and tuple size
       WTB  WB
       ADD  *TPSI$,XR
       ADD  WB,XR            point past last entry
       MOV  OFFS3(XS),WA     get subset size n
*
FMNP5  DCA  XR
       BZE  (XR),FMNP6       branch to exec main loop
       DCV  WA
       BNZ  WA,FMNP5
       BRN  FMNP8            done if all n last entries 1s
*
FMNP6  MOV  OFFS1(XS),XL     get selector
       JSR  NXTNP            update to next npow selector tuple
       MOV  OFFS2(XS),XR     retrieve tuple
       JSR  SELST            select a subset
       MOV  (XS),XL          retrieve npow target set
       JSR  ADSEL
       MOV  XL,(XS)
       BRN  FMNP4            return to main loop
*
FMNP8  MOV  (XS)+,XR         return npow
       ADD  *NUM03,XS        discard selector, tuple, and n
       EXI
       ENP
       EJC
*
*      FMSET -- form a set
*
*      Elements are passed on the stack.
*      (WA)                  number of elements on stack
*      JSR  FMSET
*      (XR)                  ptr to set/map
*      (XS)                  popped (WA) times
*      If all the elements are pairs then the result is
*      a map (MPBLK).
*      Note that (WA) is not necessarily the cardinality of
*      the set, because there may be duplicates on the stack.
*
FMSET  PRC  N,0
       BNZ  WA,FMS09         check if 0 elts
       MOV  =NLSET,XL        if so, return null set
       BRN  FMS12
FMS09  JSR  ALOTS            allocate block for set
       MOV  XR,XL            copy pointer
       ZER  TPNEL(XL)        nothing in it yet
       MOV  =B$MPL,(XL)      initially, assume its a map
       LCT  WA,WA            initialise a counter
*
FMS10  MOV  WA,FMSCT         save the count
       MOV  (XS)+,XR         load an element
       BEQ  (XR),=B$PRL,FMS11 jump with pair
       MOV  =B$STL,(XL)      not a map anymore
FMS11  JSR  ADSEL            add element to set
       MOV  FMSCT,WA         relad loop counter
       BCT  WA,FMS10
*
*      Here on finishing
*
FMS12  MOV  XL,XR            copy set pointer
       ZER  XL               clear register
       EXI
       ENP
       EJC
*
*      FMTPL -- form a tuple
*
*      Elements are passed on the stack
*
*      (WA)                  number of elements
*      JSR  FMTPL
*      (XR)                  ptr to tuple/pair
*      (XS)                  popped (WA) times
*      If there are only two elements the result is a pair
*
FMTPL  PRC  N,0
       BNZ  WA,TPF00         check if 0 elts
       MOV  =NLTUP,XR        if so, return null tuple
       BRN  TPF04
TPF00  BEQ  WA,=NUM02,TPF02  jump if possible pair
*
TPF05  JSR  ALOTS            allocate tuple frame
       MOV  XR,XL            save tuple block
       MOV  =B$TPL,(XR)      set type word
       LCT  WA,WB
       ADD  *TPSI$,XL        point to first entry
*
TPF01  MOV  (XS)+,(XL)+      set an entry
       BCT  WB,TPF01
*
TPF03  BNE  -(XL),=OMEGA,TPF04 check if trailing om entered
       DCV  TPNEL(XR)        if so, decr count
       BRN  TPF03
*
TPF04  ZER  XL               clear register
       EXI                   and return tuple block
*
*      If 2 entries, check if either is om
*
TPF02  BEQ  (XS),=OMEGA,TPF05 if so, merge with tuple case
       BEQ  OFFS1(XS),=OMEGA,TPF05
       MOV  *PRSI$,WA         otherwise form pair
       ZER  XL
       JSR  ALLOC
       MOV  XR,XL
       MOV  =B$PRL,(XL)+      set pair type
       MOV  (XS)+,(XL)+       set domain
       MOV  (XS)+,(XL)+         and range
       ZER  (XL)              no link
       ZER  XL                clear register
       EXI                    return pair
       ENP
       EJC
*
*      GBCOL -- perform garbage collection
*
*      GBCOL performs a garbage collection on the dynamic region
*      all blocks which are no longer in use are eliminated
*      by moving blocks which are in use down and resetting
*      DNAMP, the pointer to the next available location.
*
*      (WB)                  move offset (see below)
*      JSR  GBCOL            call to collect garbage
.IF    .CSED
*      (XR)                  sediment size after collection
.ELSE
*      (XR)                  destroyed
.FI
*
*      The following conditions must be met at the time when
*      GBCOL is called.
*
*      1)   All pointers to blocks in the dynamic area must be
*           accessible to the garbage collector. This means
*           that they must occur in one of the following.
*
*           A)               main stack, with current top
*                            element being indicated by XS
*
*           B)               in relocatable fields of vrblks.
*
*           C)               in register XL at the time of call
*
*           E)               in the special region of working
*                            storage where names begin with R$.
*
*      2)   All pointers must point to the start of blocks with
*           the sole exception of the contents of the code
*           pointer register which points into the R$COD block.
*
*      3)   No location which appears to contain a pointer
*           into the dynamic region may occur unless it is in
*           fact a pointer to the start of the block. However
*           pointers outside this area may occur and will
*           not be changed by the garbage collector.
*           It is especially important to make sure that XL
*           does not contain a garbage value from some process
*           carried out before the call to the collector.
*
*      GBCOL has the capability of moving the final compacted
*      result up in memory (with addresses adjusted accordingly)
*      this is used to ADD space to the static region. The
*      entry value of WB is the number of BAUS to move up.
*      The caller must guarantee that there is enough room.
*      Furthermore the value in WB if it is non-zero, must be at
*      least 256 so that the MWB instruction conditions are met.
       EJC
*
*      GBCOL (continued)
*
*      The algorithm, which is a modification of the LISP-2
*      garbage collector devised by R.Dewar and K.Belcher
*      takes three passes as follows.
*
*      1)   All pointers in memory are scanned and blocks in use
*           determined from this scan. Note that this procedure
*           is recursive and uses the main stack for linkage.
*           The marking process is thus similar to that used in
*           a standard LISP collector. However the method of
*           actually marking the blocks is different.
*
*           The first field of a block normally contains a
*           code entry point pointer. Such an entry pointer
*           can be distinguished from the address of any pointer
*           to be processed by the collector. During garbage
*           collection, this word is used to build a back chain
*           of pointers through fields which point to the block.
*           The end of the chain is marked by the occurence
*           of the word which used to be in the first word of
*           the block. This backchain serves both as a mark
*           indicating that the block is in use and as a list of
*           references for the relocation phase.
*
*      2)   Storage is scanned sequentially to discover which
*           blocks are currently in use as indicated by the
*           presence of a backchain. Two pointers are maintained
*           one scans through looking at each block. The other
*           is incremented only for blocks found to be in use.
*           In this way, the eventual location of each block can
*           be determined without actually moving any blocks.
*           As each block which is in use is processed, the back
*           chain is used to reset all pointers which point to
*           this block to contain its new address, i.e. the
*           address it will occupy after the blocks are moved.
*           The first word of the block, taken from the end of
*           the chain is restored at this point.
*
*           During pass 2, the collector builds blocks which
*           describe the regions of storage which are to be
*           moved in the third pass. There is one descriptor for
*           each contiguous set of good blocks. The descriptor
*           is built just behind the block to be moved and
*           contains a pointer to the next block and the number
*           of words to be moved.
*
*      3)   In the third and final pass, the move descriptor
*           blocks built in pass two are used to actually move
*           the blocks down to the bottom of the dynamic region.
*           The collection is then complete and the next
*           available location pointer is reset.
       EJC
*
.IF    .CSED
*      GBCOL (continued)
*
*      The garbage collector also recognizes the concept of
*      sediment.  Sediment is defined as long-lived objects
*      which precipitate to the bottom of dynamic storage.
*      Moving these objects during repeated collections is
*      inefficient.  It also contributes to thrashing on
*      systems with virtual memory.  In a typical worst-case
*      situation, there may be several megabytes of live objects
*      in the sediment, and only a few dead objects in need of
*      collection.  Without recognising sediment, the standard
*      collector would move those megabytes of objects downward
*      to squeeze out the dead objects.  This type of move
*      would result in excessive thrashing for very little memory
*      gain.
*
*      Scanning of blocks in the sediment cannot be avoided
*      entirely, because these blocks may contain pointers to
*      live objects above the sediment.  However, sediment
*      blocks need not be linked to a back chain as described
*      in pass one above.  Since these blocks will not be moved,
*      pointers to them do not need to be adjusted.  Eliminating
*      unnecessary back chain links increases locality of
*      reference, improving virtual memory performance.
*
*      Because back chains are used to mark blocks whose con-
*      tents have been processed, a different marking system
.IF    .CEPP
*      is needed for blocks in the sediment.  Since block type
*      words point to odd-parity entry addresses, merely incre-
*      menting the type word serves to mark the block as pro-
*      cessed.  During pass three, the type words are decre-
*      mented to restore them to their original value.
.ELSE
*      is needed for blocks in the sediment.  All block type
*      words normally lie in the range B$AAA to P$YYY.  Blocks
*      can be marked by adding an offset (created in GBCMK) to
*      move type words out of this range.  During pass three the
*      offset is subtracted to restore them to their original
*      value.
.FI
       EJC
*
*      GBCOL (continued)
*
*      The variable DNAMS contains the number of bytes of memory
*      currently in the sediment.  Setting DNAMS to zero will
*      eliminate the sediment and force it to be included in a
*      full garbage collection.  GBCOL returns a suggested new
*      value for DNAMS (usually DNAMP-DNAMB) in XR which the
*      caller can store in DNAMS if it wishes to maintain the
*      sediment.  That is, data remaining after a garbage
*      collection is considered to be sediment.  If one accepts
*      the common lore that most objects are either very short-
*      or very long-lived, then this naive setting of DNAMS
*      probably includes some short-lived objects toward the end
*      of the sediment.
*
*      Knowing when to reset DNAMS to zero to collect the sedi-
*      ment is not precisely known.  We force it to zero prior
*      to producing a dump, when GBCOL is invoked by COLLECT()
*      (so that the sediment is invisible to the user), when
*      SYSMM is unable to obtain additional memory, and when
*      GBCOL is called to relocate the dynamic area up in memory
*      (to make room for enlarging the static area).  If there
*      are no other reset situations, this leads to the inexo-
*      rable growth of the sediment, possibly forcing a modest
*      program to begin to use virtual memory that it otherwise
*      would not.
*
*      As we scan sediment blocks in pass three, we maintain
*      aggregate counts of the amount of dead and live storage,
*      which is used to decide when to reset DNAMS.  When the
*      ratio of free storage found in the sediment to total
*      sediment size exceeds a threshold, the sediment is marked
*      for collection on the next GBCOL call.
*
       EJC
.FI
*
*      GBCOL (continued)
*
GBCOL  PRC  E,0              Entry point
       MNZ  GBCFL            Note GBCOL entered
       MOV  STAGE,GBCST      Save entry stage
       MOV  =STGGB,STAGE     Note in GBCOL
       MOV  WA,GBSVA         Save entry WA
       MOV  WB,GBSVB         Save entry WB
       MOV  WC,GBSVC         Save entry WC
       MOV  XL,-(XS)         Save entry XL
       SCP  WA               Get code pointer value
       SUB  R$COD,WA         Make relative
       LCP  WA               And restore
*
.IF    .CSED
       BZE  WB,GBC0A         Check there is no move offset
       ZER  DNAMS            Collect sediment if must move it
GBC0A  MOV  DNAMB,WA         Start of dynamic area
       ADD  DNAMS,WA         Size of sediment
       MOV  WA,GBCSD         First location past sediment
.IF    .CEPP
.ELSE
       MOV  =P$YYY,WA        Last entry point
       ICV  WA               Address past last entry point
       SUB  =B$AAA,WA        Size of entry point area
       MOV  WA,GBCMK         Use to mark processed sed. blocks
.FI
.FI
.IF    .CGBC
*
*      Inform SYSGC that collection to commence
*
       MNZ  XR               Non-zero flags start of collection
       MOV  DNAMB,WA         Start of dynamic area
       MOV  DNAMP,WB         Next available location
       MOV  DNAME,WC         Last available location + 1
       JSR  SYSGC            Inform of collection
.FI
*
*      Process stack entries
*
       MOV  XS,XR            Point to stack front
       MOV  STBAS,XL         Point past end of stack
       BGE  XL,XR,GBC00      Ok if D-stack
       MOV  XL,XR            Reverse if ...
       MOV  XS,XL            ... U-stack
*
*      Process the stack
*
GBC00  JSR  GBCPF            Process pointers on stack
*
*      Process special work locations
*
       MOV  =R$AAA,XR        Point to start of relocatable locs
       MOV  =R$YYY,XL        Point past end of relocatable locs
       JSR  GBCPF            Process work fields
*
*      Prepare to process variable blocks
*
       MOV  HSHTB,WA         Point to first hash slot pointer
*
*      Loop through hash slots
*
GBC01  MOV  WA,XL            Point to next slot
       ICA  WA               Bump bucket pointer
       MOV  WA,GBCNM         Save bucket pointer
       EJC
*
*      GBCOL (continued)
*
*      Loop through variables on one hash chain
*
GBC02  MOV  (XL),XR          Load ptr to next VRBLK or WDBLK
       BZE  XR,GBC03         Jump if end of chain
       MOV  XR,XL            Else copy VRBLK pointer
       ADD  *VRVAL,XR        Point to first reloc fld
       ADD  *VRNXT,XL        Point past last (and to link ptr)
       JSR  GBCPF            Process reloc fields in VRBLK
       BRN  GBC02            Loop back for next block
*
*      Here at end of one hash chain
*
GBC03  MOV  GBCNM,WA         Restore bucket pointer
       BNE  WA,HSHTE,GBC01   Loop back if more buckets to go
       EJC
*
*      GBCOL (continued)
*
*      Now we are ready to start pass two. Registers are used
*      as follows in pass two.
*
*      (XR)                  scans through all blocks
*      (WC)                  pointer to eventual location
*
*      The move description blocks built in this pass have
*      the following format.
*
*      Word 1                pointer to next move block,
*                            zero if end of chain of blocks
*
*      Word 2                length of blocks to be moved in
*                            BAUS. Set to the address of the
*                            first bau while actually scanning
*                            the blocks.
*
*      The first entry on this chain is a special entry
*      consisting of the two words GBCNM and GBCNS. After
*      building the chain of move descriptors, GBCNM points to
*      the first real move block, and GBCNS is the length of
*      blocks in use at the start of storage which need not
*      be moved since they are in the correct position.
*
.IF    .CSED
       MOV  DNAMB,XR         Point to first block
       ZER  WB               Accumulate size of dead blocks
GBC04  BEQ  XR,GBCSD,GBC4C   Jump if end of sediment
       MOV  (XR),WA          Else get first word
.IF    .CEPP
       BOD  WA,GBC4B         Jump if entry pointer (unused)
       DCV  WA               Restore entry pointer
.ELSE
       BHI  WA,=B$YYY,GBC4A  Skip if not entry ptr (in use)
       BHI  WA,=B$AAA,GBC4B  Jump if entry pointer (unused)
GBC4A  SUB  GBCMK,WA         Restore entry pointer
.FI
       MOV  WA,(XR)          Restore first word
       JSR  BLKLN            Get length of this block
       ADD  WA,XR            Bump actual pointer
       BRN  GBC04            Continue scan through sediment
*
*      Here for unused sediment block
*
GBC4B  JSR  BLKLN            Get length of this block
       ADD  WA,XR            Bump actual pointer
       ADD  WA,WB            Count size of unused blocks
       BRN  GBC04            Continue scan through sediment
*
*      Here at end of sediment.  Remember size of free blocks
*      within the sediment.  This will be used later to decide
*      how to set the sediment size returned to caller.
*
*      Then scan rest of dynamic area above sediment
*
*      (WB) = Aggregate size of free blocks in sediment
*      (XR) = First location past sediment
*
GBC4C  MOV  WB,GBCSF         Size of sediment free space
.ELSE
       MOV  DNAMB,XR         Point to first block
.FI
       MOV  XR,WC            Set as first eventual location
       ADD  GBSVB,WC         ADD offset for eventual move up
       ZER  GBCNM            Clear initial forward pointer
       MOV  =GBCNM,GBCLM     Initialize ptr to last move block
       MOV  XR,GBCNS         Initialize first address
*
*      Loop through a series of blocks in use
*
GBC05  BEQ  XR,DNAMP,GBC07   Jump if end of used region
       MOV  (XR),WA          Else get first word
.IF    .CEPP
       BOD  WA,GBC07         Jump if entry pointer (unused)
.ELSE
       BHI  WA,=B$YYY,GBC06  Skip if not entry ptr (in use)
       BHI  WA,=B$AAA,GBC07  Jump if entry pointer (unused)
.FI
*
*      Here for block in use, loop to relocate references
*
GBC06  MOV  WA,XL            Copy pointer
       MOV  (XL),WA          Load forward pointer
       MOV  WC,(XL)          Relocate reference
.IF    .CEPP
       BEV  WA,GBC06         Loop back if not end of chain
.ELSE
       BHI  WA,=B$YYY,GBC06  Loop back if not end of chain
       BLO  WA,=B$AAA,GBC06  Loop back if not end of chain
.FI
       EJC
*
*      GBCOL (continued)
*
*      At end of chain, restore first word and bump past
*
       MOV  WA,(XR)          Restore first word
       JSR  BLKLN            Get length of this block
       BZE  WA,GBC15         zero size error trap
       ADD  WA,XR            Bump actual pointer
       ADD  WA,WC            Bump eventual pointer
       BRN  GBC05            Loop back for next block
*
*      Here at end of a series of blocks in use
*
GBC07  MOV  XR,WA            Copy pointer past last block
       MOV  GBCLM,XL         Point to previous move block
       SUB  OFFS1(XL),WA         Subtract starting address
       MOV  WA,OFFS1(XL)         Store length of block to be moved
*
*      Loop through a series of blocks not in use
*
GBC08  BEQ  XR,DNAMP,GBC10   Jump if end of used region
       MOV  (XR),WA          Else load first word of next block
.IF    .CEPP
       BEV  WA,GBC09         Jump if in use
.ELSE
       BHI  WA,=B$YYY,GBC09  Jump if in use
       BLO  WA,=B$AAA,GBC09  Jump if in use
.FI
       JSR  BLKLN            Else get length of next block
       BZE  WA,GBC15         zero size error trap
       ADD  WA,XR            Push pointer
       BRN  GBC08            And loop back
*
*      Here for a block in use after processing a series of
*      blocks which were not in use, build new move block.
*
GBC09  SUB  *NUM02,XR        Point 2 words behind for move block
       MOV  GBCLM,XL         Point to previous move block
       MOV  XR,(XL)          Set forward ptr in previous block
       ZER  (XR)             Zero forward ptr of new block
       MOV  XR,GBCLM         Remember address of this block
       MOV  XR,XL            Copy ptr to move block
       ADD  *NUM02,XR        Point back to block in use
       MOV  XR,OFFS1(XL)         Store starting address
       BRN  GBC06            Jump to process block in use
       EJC
*
*      GBCOL (continued)
*
*      Here for pass three -- actually move the blocks down
*
*      (XL)                  pointer to old location
*      (XR)                  pointer to new location
*
.IF    .CSED
GBC10  MOV  GBCSD,XR         Point to storage above sediment
.ELSE
GBC10  MOV  DNAMB,XR         Point to start of storage
.FI
       ADD  GBCNS,XR         Bump past unmoved blocks at start
*
*      Loop through move descriptors
*
GBC11  MOV  GBCNM,XL         Point to next move block
       BZE  XL,GBC12         Jump if end of chain
       MOV  (XL)+,GBCNM      Move pointer down chain
       MOV  (XL)+,WA         Get length to move
       BGT  XR,XL,GBC15      error if not downward
       MVW                   Perform move
       BRN  GBC11            Loop back
*
*      Now test for move up
*
GBC12  MOV  XR,DNAMP         Set next available loc ptr
       MOV  GBSVB,WB         Reload move offset
       BZE  WB,GBC13         Jump if no move required
       MOV  XR,XL            Else copy old top of core
       ADD  WB,XR            Point to new top of core
       MOV  XR,DNAMP         Save new top of core pointer
       MOV  XL,WA            Copy old top
       SUB  DNAMB,WA         Minus old bottom = length
       ADD  WB,DNAMB         Bump bottom to get new value
       MWB                   Perform move (backwards)
*
*      Merge here to exit
*
GBC13  ZER  XR               Clear garbage value in XR
       ZER  GBCFL            Note exit from GBCOL
*
.IF    .CGBC
       MOV  DNAMB,WA         Start of dynamic area
       MOV  DNAMP,WB         Next available location
       MOV  DNAME,WC         Last available location + 1
       JSR  SYSGC
.FI
.IF   .CSED
*
*      Decide whether to mark sediment for collection next time.
*      This is done by examining the ratio of previous sediment
*      free space to the new sediment size.
*
       STI  GBCIA            Save IA
       ZER  XR               Assume no sediment will remain
       MOV  GBCSF,WB         Free space in sediment
       BTW  WB               Convert bytes to words
       MTI  WB               Put sediment free store in IA
       MLI  GBSED            Multiply by sediment factor
       IOV  GB13A            Jump if overflowed
       MOV  DNAMP,WB         End of dynamic area in use
       SUB  DNAMB,WB         Minus start is sediment remaining
       BTW  WB               Convert to words
       MOV  WB,GBCSF         Store it
       SBI  GBCSF            Subtract from scaled up free store
       IGT  GB13A            Jump if large free store in sediment
       MOV  DNAMP,XR         Below threshold, return sediment
       SUB  DNAMB,XR           for use by caller
GB13A  LDI  GBCIA            Restore IA
.FI
*
       MOV  GBSVA,WA         Restore WA
       MOV  GBSVB,WB           and WB
       SCP  WC               Get code pointer
       ADD  R$COD,WC         Make absolute again
       LCP  WC               And replace absolute value
       MOV  GBSVC,WC         Restore WC
       MOV  (XS)+,XL         Restore entry XL
       ICV  GBCNT            Increment count of collections
       MOV  GBCST,STAGE      Restore entry stage
       EXI                   Exit to GBCOL caller
*
*      Garbage collection not allowed whilst dumping
*      Currently not enabled - JVK
*
GBC14  ICV  ERRFT            Fatal error
       ERB  200,insufficient memory to complete dump
*
*      Try to trap bugs in block layout
*
GBC15  ERB  207,fatal garbage collection error
       ENP                   End procedure GBCOL
       EJC
*
*      GBCPF -- process fields for garbage collector
*
*      This procedure is used by the garbage collector to
*      process fields in pass one. See GBCOL for full details.
*
*      (XR)                  ptr to first location to process
*      (XL)                  ptr past last location to process
*      JSR  GBCPF            call to process fields
*      (XR,WA,WB,WC,IA)      destroyed
*
*      Note that although this procedure uses a recursive
*      approach, it controls its own stack and is not recursive.
*
GBCPF  PRC  E,0              Entry point
       ZER  -(XS)            Set zero to mark bottom of stack
       MOV  XL,-(XS)         Save end pointer
*
*      Merge here to go down a level and start a new loop
*
*      1(XS)                 next lvl field ptr (0 at outer lvl)
*      0(XS)                 ptr past last field to process
*      (XR)                  ptr to first field to process
*
*      Loop to process successive fields
*
GPF01  MOV  (XR),XL          Load field contents
       MOV  XR,WC            Save field pointer
.IF    .CRPP
       BOD  XL,GPF2A         Jump if not ptr into dynamic area
.ELSE
.FI
       BLT  XL,DNAMB,GPF2A   Jump if not ptr into dynamic area
       BGE  XL,DNAMP,GPF2A   Jump if not ptr into dynamic area
*
*      Here we have a ptr to a block in the dynamic area.
*      Link this field onto the reference backchain.
*
       MOV  (XL),WA          Load ptr to chain (or entry ptr)
.IF    .CSED
       BLT  XL,GBCSD,GPF1A   Do not chain if within sediment
.FI
       MOV  XR,(XL)          Set this field as new head of chain
       MOV  WA,(XR)          Set forward pointer
*
*      Now see if this block has been processed before
*
.IF    .CEPP
GPF1A  BOD  WA,GPF03         Jump if not already processed
.ELSE
GPF1A  BHI  WA,=B$YYY,GPF2A  Jump if already processed
       BHI  WA,=B$AAA,GPF03  Jump if not already processed
.FI
*
*      Here to restore pointer in XR to field just processed
*
GPF02  MOV  WC,XR            Restore field pointer
*
*      Here to move to next field
*
GPF2A  ICA  XR               Bump to next field
       BNE  XR,(XS),GPF01    Loop back if more to go
       EJC
*
*      GBCPF (continued)
*
*      Here we pop up a level after finishing a block
*
       MOV  (XS)+,XL         Restore pointer past end
       MOV  (XS)+,XR         Restore block pointer
       BNZ  XR,GPF2A         Continue loop unless outer levl
       EXI                   Return to caller if outer level
*
*      Here to process an active block which has not been done
*
.IF    .CSED
*      Since sediment blocks are not marked by putting them on
*      the back chain, they must be explicitly marked in another
*      manner.  If odd parity entry points are present, mark by
*      temporarily converting to even parity.  If odd parity not
*      available, the entry point is adjusted by the value in
*      GBCMK.
*
GPF03  BGE  XL,GBCSD,GPF3A   If not within sediment
.IF    .CEPP
       ICV  (XL)             Mark by making entry point even
.ELSE
       ADD  GBCMK,(XL)       Mark by raising entry point
.FI
GPF3A  MOV  XL,XR            Copy block pointer
.ELSE
GPF03  MOV  XL,XR            Copy block pointer
.FI
       MOV  WA,XL            Copy first word of block
       LEI  XL               Load entry point id (bl$xx)
*
*      Block type switch. Note that blocks with no relocatable
*      fields just return to gpf02 here to contine to next fld.
*
       BSW  XL,BL$$$,GPF17   Switch on block type
       IFF  BL$AC,GPF02      ACBLK
       IFF  BL$AT,GPF02      ATBLK
       IFF  BL$CC,GPF07      CCBLK
       IFF  BL$CD,GPF08      CDBLK
       IFF  BL$CK,GPF02      CKBLK
       IFF  BL$CM,GPF04      CMBLK
       IFF  BL$CT,GPF02      CTBLK
       IFF  BL$EF,GPF02      EFBLK
       IFF  BL$IC,GPF02      ICBLK
.IF    .CNRA
.ELSE
       IFF  BL$RC,GPF02      RCBLK
.FI
       IFF  BL$SC,GPF02      SCBLK
       IFF  BL$LT,GPF11      LTBLK
       IFF  BL$LR,GPF12      LRBLK
       IFF  BL$PR,GPF12      PRBLK
       IFF  BL$ST,GPF13      STBLK
       IFF  BL$MP,GPF13      MPBLK
       IFF  BL$TP,GPF13      TPBLK
       IFF  BL$PC,GPF14      PCBLK
       IFF  BL$PF,GPF02      PFBLK
       IFF  BL$RU,GPF02      RUBLK
       IFF  BL$SN,GPF02      SNBLK
       IFF  BL$IO,GPF15      IOBLK
       IFF  BL$VC,GPF08      VCBLK
       IFF  BL$XN,GPF02      XNBLK
       IFF  BL$XR,GPF13      XRBLK
       ESW                   End of jump table
       EJC
*
*      GBCPF (continued)
*
*      CMBLK
*
GPF04  MOV  CMLEN(XR),WA     Load length
       MOV  *CMTYP,WB        Set offset
*
*      Here to push down to new level
*
*      (WC)                  field ptr at previous level
*      (XR)                  ptr to new block
*      (WA)                  length (reloc flds + flds at start)
*      (WB)                  offset to first reloc field
*
GPF05  ADD  XR,WA            Point past last reloc field
       ADD  WB,XR            Point to first reloc field
       MOV  WC,-(XS)         Stack old field pointer
       MOV  WA,-(XS)         Stack new limit pointer
       CHK                   Check for stack overflow
       BRN  GPF01            If ok, back to process
*
*      CCBLK
*
GPF07  MOV  CCUSE(XR),WA     Set length in use
       MOV  *CCUSE,WB        First word (make sure at least one)
       BRN  GPF05            All set
       EJC
*
*      GBCPF (continued)
*
*      CDBLK, VCBLK
*
GPF08  MOV  OFFS2(XR),WA     Load length
       MOV  *OFFS3,WB        Set offset
       BRN  GPF05            Jump back
*
*      LTBLK
*
GPF11  MOV  *LTSI$,WA
       MOV  *OFFS1,WB
       BRN  GPF05
*
*      LRBLK, PRBLK
*
GPF12  MOV  *NUM04,WA
       MOV  *NUM01,WB
       BRN  GPF05
*
*      TPBLK, XRBLK
*
GPF13  MOV  OFFS1(XR),WA     Load length from second word
       MOV  *OFFS3,WB        Load offset
       BRN  GPF05
*
*      PCBLK
*
GPF14  MOV  *PCSI$,WA
       MOV  *PCSAV,WB
       BRN  GPF05
*
*      IOBLK
*
GPF15  MOV  *IOSI$,WA
       MOV  *IOSCB,WB
       BRN  GPF05
*
GPF17  ERB  208,Fatal GBCOL error-illegal block
       ENP                   End procedure GBCPF
       EJC
*
*      GENLH -- generate code for assign to (maybe parallel) lhs
*      If parallel, generates code for a sequence of stores.
*      If not, just calls GENST.
*
*      (XR)                  tree node for assign oper
*      (XL)                  tree node for lh of assign
*      JSR  GENLH
*      (XR,XL,WC)            restored
*      (WA)                  destroyed
*
GENLH  PRC  E,0
       BEQ  (XL),=B$VRL,GLH01 jump if name
       BEQ  CMTYP(XL),=C$EXP,GLH02 exp for parallel lhs
GLH01  JSR  GENST            for name or subscripted id
       EXI
*
*      for parallel lhs, need sequence of stores
*
GLH02  MOV  XR,-(XS)         save regs
       MOV  XL,-(XS)
       MOV  WC,-(XS)
       MOV  =O$PLH,WA        extract entries from rhs
       JSR  CDWRD
       ZER  WA               count nbr of stores
GLH03  ICV  WA               count this one
       MOV  CMLHD(XL),XL     to next one
       BNZ  XL,GLH03
       JSR  CDWRD            gen code for count
*
*      Now store from stack in reverse order
*
       MOV  OFFS1(XS),XR     recover last of list
GLH04  MOV  CMLTL(XR),XL     get destination
       BZE  XL,GLH05         skip store if dash
       JSR  GENST            generate store instruction
GLH05  MOV  =O$POP,WA        then pop entry
       JSR  CDWRD
       MOV  CMLHD(XR),XR     get next on list
       BNZ  XR,GLH04
*
       MOV  (XS)+,WC         restore regs
       MOV  (XS)+,XL
       MOV  (XS)+,XR
       EXI
       ENP
       EJC
*
*      GENPC -- generate code for a procedure
*
*      (XL)                  ptr to PCBLK for procedure
*      (XR)                  ptr to tree for procedure body
*      JSR  GENPC
*      (XR,XL,WA,WB,WC)      destroyed
*
GENPC  PRC  E,0
       MOV  XR,-(XS)         save tree node
       MOV  XL,R$PCB         save current PCBLK
       ZER  R$LBC
       ZER  R$LBR
       JSR  NXTLB            get label for procedure
       MOV  WA,PCLAB         save it
       MOV  WA,XL
       JSR  LABST            set the value
.IF    .CNPF
.ELSE
       JSR  GENPF
       MOV  =SCPRO,XL
       JSR  PRTWD
.FI
       MOV  (XS)+,XR         recover tree
       JSR  CDGEN            generate the code
*
*      Add RETURN OM
*
.IF    .CNPF
.ELSE
       JSR  GENPF
       MOV  =SCEND,XL
       JSR  PRTWD
.FI
       MOV  =OMEGA,WA
       JSR  CDWRD
       MOV  =O$RTN,WA
       JSR  CDWRD
*
*      Set label at end, to force off CMBLK
*
       JSR  NXTLB
       MOV  WA,XL
       JSR  LABST
       MOV  =NUM01,WA
       JSR  DSCLB
       MOV  PCLAB,XL
       MOV  R$PCB,XR
       ADD  R$LBV,XL         point to CDBLK
       MOV  (XL),PCCOD(XR)
       ZER  XL
       MOV  PCACT,PCNAR(XR)
       MOV  STATE,PCLOC(XR)
*
*      Now prepare for more
*
       MOV  =NUM01,WA
       JSR  DSCLB            discard proc head label
       MOV  STATE,PRCSP      save staic pointer
       ZER  PCACT
       ZER  RTTMP
       AOV  =PRCNC,PRCNO,GNPC1
       EXI
GNPC1  ERB  250,too many procedures
       ENP
       EJC
.IF    .CNPF
.ELSE
*
*      GENPF - Generate Profile Pseudo-Op
*
*      JSR  GENPF
*      (WA)                  destroyed
*
GENPF  PRC  E,0
       MOV  XR,-(XS)         Save input XR
       STI  PFSIA             and integer acc.
       ICV  PFNBB            Increment block nr
       MOV  =O$PFL,WA        Load profile op
       JSR  CDWRD            and generate
       MOV  PFNBB,WA         Get nr of block ending
       JSR  CDWRD            Generate that as arg
       MOV  =NULLS,XR        Do a dummy print to ensure ...
       JSR  PRTST            ... all nec. titling etc done
       MOV  =STPD2,PROFS
       MOV  =PFM02,XR        Tell whats happening (stmt nr ...
       JSR  PRTST            ... filled in later by PRTWD)
       MTI  PFNBB            Profile Block nr
       JSR  PRTIN
       MOV  =PFPDA,PROFS
       MOV  =PFM03,XR        Tack on /at/
       JSR  PRTST
*
       LDI  PFSIA            Restore int. acc.
       MOV  (XS)+,XR         and XR
       EXI                   Done
       ENP
       EJC
.FI
*
*      GENST -- generate a store instruction
*
*      (XR)                  tree node for assign oper
*      (XL)                  tree node for lh of assignment
*      JSR  GENST
*      (XR,XL,WC)            restored
*      (WA)                  destroyed
*
*
*      Current possibilties - name or subscripted expression
*      Either parentheses or curly subscripts
*
GENST  PRC  E,0
       BNE  (XL),=B$VRL,GNST1
       MOV  XL,WA            copy VRBLK pointer
       ICA  WA               point to VRSTO field
       JSR  CDWRD
       EXI
*
GNST1  MOV  XR,-(XS)         subscripted-save callers - assn blk
       MOV  XL,-(XS)                                    sub blk
       MOV  WC,-(XS)
       ZER  WA               count index level
GNST3  MOV  CMSXP(XL),XR
       BEQ  (XR),=B$VRL,GNST4
       ICV  WA               multiple index
       MOV  XL,-(XS)         save C$SUB block
       MOV  XR,XL
       BRN  GNST3
*
GNST4  MOV  XL,-(XS)         save last sub
       MOV  WA,-(XS)           and count
       MOV  XR,WA            load var
       JSR  CDWRD
       BZE  GENIS,GNS41      check if assign within iterator
       MOV  =O$COP,WA        if so, copy var
       JSR  CDWRD
GNS41  MOV  CMSBS(XL),XR     load subscript
       JSR  CDGEN
       MOV  OFFS1(XS),XL     recover subscript block
       BNE  CMTYP(XL),=C$SLC,GNST5 check if slice
*
*      Here if slice subscript - has 3 args
*
       MOV  CMSLE(XL),XR     load end subscript
       BNZ  XR,GNS42         check if t(a..)
       MOV  =TMPL1,WA        if so, copy t
       JSR  CDWRD
       MOV  =O$NUM,WA        then form #t as end index
       JSR  CDWRD
       BRN  GNS43
*
GNS42  JSR  CDGEN            here if t(a..b) - code for b
GNS43  BZE  (XS),GNST6       check index level
       MOV  =TMPL2,WA        multiple level for slice
       JSR  CDWRD            copy each of 3 args
       JSR  CDWRD
       JSR  CDWRD
       MOV  =O$SLC,WA
       BRN  GNS52
*
*      Here if () or {} subscript - 2 args
*
GNST5  BZE  (XS),GNST6
       MOV  =TMPL1,WA        multiple index
       JSR  CDWRD            reload entry
       JSR  CDWRD               and subscript
       BEQ  CMTYP(XL),=C$SUB,GNS51
       MOV  =O$SBM,WA        find curly subscript result
       BRN  GNS52
GNS51  MOV  =O$SUB,WA        find subscript entry
GNS52  JSR  CDWRD
       MOV  (XS)+,WA         retrieve count
       ICA  XS               discard current sub node
       MOV  (XS),XL          get parent subscr node
       DCV  WA
       MOV  WA,-(XS)
       BRN  GNS41
GNST6  ICA  XS               discard counter
*
*      Now proceed to create subscript stores
*
       MOV  =TMPLN,WA        reload rhs
       JSR  CDWRD
       ZER  WC               count depth again
       ZER  WA               count offset of rhs
       MOV  (XS)+,XL         recover top of subscript list
       MOV  XL,XR
GNST7  BNE  CMTYP(XR),=C$SLC,GNS71
       ADD  =NUM03,WA        count 3 args for slice
       BRN  GNS72
GNS71  ADD  =NUM02,WA        subscr have 2 args
GNS72  MOV  CMSXP(XR),XR
       BEQ  (XR),=B$VRL,GNST8  stop when XR at vrblk
       ICV  WC
       BRN  GNST7
GNST8  ICV  WC
       JSR  CDWRD            WA has distance of RHS
       LCT  WC,WC
GNST9  BEQ  CMTYP(XL),=C$SLC,GNS90
       BEQ  CMTYP(XL),=C$SUB,GNS91
       MOV  =O$SMA,WA        perform store with curly subscript
       BRN  GNS92
GNS90  MOV  =O$SLA,WA        store into slice
       BRN  GNS92
GNS91  MOV  =O$SBA,WA        perform stores
GNS92  JSR  CDWRD
       MOV  CMSXP(XL),XL     get next subscript or vrblk
       BCT  WC,GNST9
       MOV  XR,WA
       ICA  WA               recover VRBLK & get VRSTO field
       JSR  CDWRD
       MOV  =O$POP,WA        JVK-and pop the tuple
       JSR  CDWRD
       MOV  (XS)+,WC         recover the callers
       MOV  (XS)+,XL
       MOV  (XS)+,XR
       EXI
       ENP
       EJC
*
*      GPOPL -- generate code to pop loop temps
*
*      GPOPL is called to get rid of stacked temporaries inside
*      a loop, in case of QUIT, or equivalent
*
*      JSR  GPOPL
*      (WA,WB)                  destroyed
*
GPOPL  PRC  E,0
       MOV  =O$POP,WA        load pop instruction
       MOV  LPTMP,WB
GPPL1  BZE  WB,GPPL2
       JSR  CDWRD            generate 1 pop
       DCV  WB
       BRN  GPPL1
*
GPPL2  EXI
       ENP
       EJC
*
*      GPOPR -- generate code to pop temps for return
*      (might be inside loop)
*
*      JSR  GPOPR
*      (WA,WB)                destroyed
*
GPOPR  PRC  E,0
       MOV  =O$POP,WA
       MOV  RTTMP,WB
GPPR1  BZE  WB,GPPR2
       JSR  CDWRD
       DCV  WB
       BRN  GPPR1
GPPR2  EXI
       ENP
       EJC
*
*      GPOPX -- generate code to pop temps inside EXPR
*
*      (YIELD might occur inside loop or case)
*      JSR  GPOPX
*      (WA,WB)                  destroyed
*
GPOPX  PRC  E,0
       MOV  =O$POP,WA
       MOV  EXTMP,WB
GPPX1  BZE  WB,GPPX2
       JSR  CDWRD
       DCV  WB
       BRN  GPPX1
*
GPPX2  EXI
       ENP
       EJC
*
*      GTINT -- get integer value
*
*      GTINT is passed an object and returns an integer after
*      performing any necessary conversions.
*
*      (XR)                  value to be converted
*      JSR  GTINT            call to convert to integer
*      PPM  LOC              transfer loc for convert impossible
*      (XR)                  resulting integer
*      (WC,RA)               destroyed
*      (WA,WB)               destroyed (only on conversion ERR)
*      (XR)                  unchanged (on convert error)
*
GTINT  PRC  E,1              Entry point
       BEQ  (XR),=B$ICL,GTIN2 Jump if already an integer
       MOV  WA,GTINA         Else save WA
       MOV  WB,GTINB         Save WB
       JSR  GTNUM            Convert to numeric
       PPM  GTIN3            Jump if unconvertible
.IF    .CNRA
.ELSE
       BEQ  WA,=B$ICL,GTIN1  Jump if integer
*
*      Here we convert a real to integer
*
       LDR  RCVAL(XR)        Load real value
       RTI  GTIN3            Convert to integer (ERR if ovflow)
       JSR  ICBLD            If ok build ICBLK
.FI
*
*      Here after successful conversion to integer
*
GTIN1  MOV  GTINA,WA         Restore WA
       MOV  GTINB,WB         Restore WB
*
*      Common exit point
*
GTIN2  EXI                   Return to GTINT caller
*
*      Here on conversion error
*
GTIN3  EXI  1                Take convert error exit
       ENP                   End procedure GTINT
       EJC
*
*      GTNUM -- get numeric value
*
*      GTNUM is given an object and returns either an integer
*      or a real, performing any necessary conversions.
*
*      (XR)                  object to be converted
*      JSR  GTNUM            call to convert to numeric
*      PPM  LOC              transfer loc if convert impossible
*      (XR)                  pointer to result (int or real)
*      (WA)                  first word of result block
*      (WB,WC,RA)            destroyed
*      (XR)                  unchanged (on convert error)
*
GTNUM  PRC  E,1              Entry point
       MOV  (XR),WA          Load first word of block
       BEQ  WA,=B$ICL,GTN34  Jump if integer (no conversion)
.IF    .CNRA
.ELSE
       BEQ  WA,=B$RCL,GTN34  Jump if real (no conversion)
.FI
*
*      At this point the only possibility is to convert a string
*      to an integer or real as appropriate.
*
       MOV  XR,-(XS)         Stack argument in case convert ERR
       MOV  XR,-(XS)         Stack argument for GTSTG
       JSR  GTSTG            Convert argument to string
       PPM  GTN36            Jump if unconvertible
*
*      Initialize numeric conversion
*
       LDI  INTV0            Initialize integer result to zero
       BZE  WA,GTN32         Jump to exit with zero if null
       LCT  WA,WA            Set BCT counter for following loops
       ZER  GTNNF            Tentatively indicate result +
.IF    .CNRA
.ELSE
       STI  GTNEX            Initialise exponent to zero
       ZER  GTNSC            Zero scale in case real
       ZER  GTNDF            Reset flag for dec point found
       ZER  GTNRD            Reset flag for digits found
       LDR  REAV0            Zero real accum in case real
.FI
       PLC  XR               Point to argument characters
*
*      Merge back here after ignoring leading blank
*
GTN01  LCH  WB,(XR)+         Load first character
       BLT  WB,=CH$D0,GTN02  Jump if not digit
       BLE  WB,=CH$D9,GTN06  Jump if first char is a digit
       EJC
*
*      GTNUM (continued)
*
*      Here if first digit is non-digit
*
GTN02  BNE  WB,=CH$BL,GTN03  Jump if non-blank
GTNA2  BCT  WA,GTN01         Else decr count and loop back
       BRN  GTN07            Jump to return zero if all blanks
*
*      Here for first character non-blank, non-digit
*
GTN03  BEQ  WB,=CH$PL,GTN04  Jump if plus sign
.IF    .CAHT
       BEQ  WB,=CH$HT,GTNA2  Horizontal tab equiv to blank
.FI
.IF    .CNRA
       BNE  WB,=CH$MN,GTN36  Else fail
.ELSE
       BNE  WB,=CH$MN,GTN12  Jump if not minus (may be real)
.FI
       MNZ  GTNNF            If minus sign, set negative flag
*
*      Merge here after processing sign
*
GTN04  BCT  WA,GTN05         Jump if chars left
       BRN  GTN36            Else error
*
*      Loop to fetch characters of an integer
*
GTN05  LCH  WB,(XR)+         Load next character
       BLT  WB,=CH$D0,GTN08  Jump if not a digit
       BGT  WB,=CH$D9,GTN08  Jump if not a digit
*
*      Merge here for first digit
*
GTN06  STI  GTNSI            Save current value
.IF    .CNRA
       CVM  GTN36            Current*10-(new dig) jump if ovflow
.ELSE
       CVM  GTN35            Current*10-(new dig) jump if ovflow
       MNZ  GTNRD            Set digit read flag
.FI
       BCT  WA,GTN05         Else loop back if more chars
*
*      Here to exit with converted integer value
*
GTN07  BNZ  GTNNF,GTN32      Jump if negative (all set)
       NGI                   Else negate
       INO  GTN32            Jump if no overflow
       BRN  GTN36            Else signal error
       EJC
*
*      GTNUM (continued)
*
*      Here for a non-digit character while attempting to
*      convert an integer, check for trailing blanks or real.
*
GTN08  BEQ  WB,=CH$BL,GTNA9  Jump if a blank
.IF    .CAHT
       BEQ  WB,=CH$HT,GTNA9  Jump if horizontal tab
.FI
.IF    .CNRA
       BRN  GTN36            Error
.ELSE
       ITR                   Else convert integer to real
       NGR                   Negate to get positive value
       BRN  GTN12            Jump to try for real
.FI
*
*      Here we scan out blanks to end of string
*
GTN09  LCH  WB,(XR)+         Get next char
.IF    .CAHT
       BEQ  WB,=CH$HT,GTNA9  Jump if horizontal tab
.FI
       BNE  WB,=CH$BL,GTN36  Error if non-blank
GTNA9  BCT  WA,GTN09         Loop back if more chars to check
       BRN  GTN07            Return integer if all blanks
.IF    .CNRA
.ELSE
*
*      Loop to collect mantissa of real
*
GTN10  LCH  WB,(XR)+         Load next character
       BLT  WB,=CH$D0,GTN12  Jump if non-numeric
       BGT  WB,=CH$D9,GTN12  Jump if non-numeric
*
*      Merge here to collect first real digit
*
GTN11  SUB  =CH$D0,WB        Convert digit to number
       MLR  REAVT            Multiply real by 10.0
       ROV  GTN36            Convert error if overflow
       STR  GTNSR            Save result
       MTI  WB               Get new digit as integer
       ITR                   Convert new digit to real
       ADR  GTNSR            ADD to get new total
       ADD  GTNDF,GTNSC      Increment scale if after dec point
       MNZ  GTNRD            Set digit found flag
       BCT  WA,GTN10         Loop back if more chars
       BRN  GTN22            Else jump to scale
       EJC
*
*      GTNUM (continued)
*
*      Here if non-digit found while collecting a real
*
GTN12  BNE  WB,=CH$DT,GTN13  Jump if not dec point
       BNZ  GTNDF,GTN36      If dec point, error if one already
       MOV  =NUM01,GTNDF     Else set flag for dec point
       BCT  WA,GTN10         Loop back if more chars
       BRN  GTN22            Else jump to scale
*
*      Here if not decimal point
*
GTN13  BEQ  WB,=CH$LE,GTN15  Jump if e for exponent
       BEQ  WB,=CH$LD,GTN15  Jump if D for exponent
*
*      Here check for trailing blanks
*
GTN14  BEQ  WB,=CH$BL,GTNB4  Jump if blank
.IF    .CAHT
       BEQ  WB,=CH$HT,GTNB4  Jump if horizontal tab
.FI
       BRN  GTN36            Error if non-blank
*
GTNB4  LCH  WB,(XR)+         Get next character
       BCT  WA,GTN14         Loop back to check if more
       BRN  GTN22            Else jump to scale
*
*      Here to read and process an exponent
*
GTN15  ZER  GTNES            Set exponent sign positive
       LDI  INTV0            Initialize exponent to zero
       MNZ  GTNDF            Reset no dec point indication
       BCT  WA,GTN16         Jump skipping past e or D
       BRN  GTN36            Error if null exponent
*
*      Check for exponent sign
*
GTN16  LCH  WB,(XR)+         Load first exponent character
       BEQ  WB,=CH$PL,GTN17  Jump if plus sign
       BNE  WB,=CH$MN,GTN19  Else jump if not minus sign
       MNZ  GTNES            Set sign negative if minus sign
*
*      Merge here after processing exponent sign
*
GTN17  BCT  WA,GTN18         Jump if chars left
       BRN  GTN36            Else error
*
*      Loop to convert exponent digits
*
GTN18  LCH  WB,(XR)+         Load next character
       EJC
*
*      GTNUM (continued)
*
*      Merge here for first exponent digit
*
GTN19  BLT  WB,=CH$D0,GTN20  Jump if not digit
       BGT  WB,=CH$D9,GTN20  Jump if not digit
       CVM  GTN36            Else current*10, subtract new digit
       BCT  WA,GTN18         Loop back if more chars
       BRN  GTN21            Jump if exponent field is exhausted
*
*      Here to check for trailing blanks after exponent
*
GTN20  BEQ  WB,=CH$BL,GTNC0  Jump if blank
.IF    .CAHT
       BEQ  WB,=CH$HT,GTNC0  Jump if horizontal tab
.FI
       BRN  GTN36            Error if non-blank
*
GTNC0  LCH  WB,(XR)+         Get next character
       BCT  WA,GTN20         Loop back till all blanks scanned
*
*      Merge here after collecting exponent
*
GTN21  STI  GTNEX            Save collected exponent
       BNZ  GTNES,GTN22      Jump if it was negative
       NGI                   Else complement
       IOV  GTN36            Error if overflow
       STI  GTNEX            And store positive exponent
*
*      Merge here with exponent (0 if none given)
*
GTN22  BZE  GTNRD,GTN36      Error if not digits collected
       BZE  GTNDF,GTN36      Error if no exponent or dec point
       MTI  GTNSC            Else load scale as integer
       SBI  GTNEX            Subtract exponent
       IOV  GTN36            Error if overflow
       ILT  GTN26            Jump if we must scale up
*
*      Here we have a negative exponent, so scale down
*
       MFI  WA,GTN36         Load scale factor, ERR if ovflow
*
*      Loop to scale down in steps of 10**10
*
GTN23  BLE  WA,=NUM10,GTN24  Jump if 10 or less to go
       DVR  REATT            Else divide by 10**10
       SUB  =NUM10,WA        Decrement scale
       BRN  GTN23            And loop back
       EJC
*
*      GTNUM (continued)
*
*      Here scale rest of way from powers of ten table
*
GTN24  BZE  WA,GTN30         Jump if scaled
       LCT  WB,=CFP$R        Else get indexing factor
       MOV  =REAV1,XR        Point to powers of ten table
       WTB  WA               Convert remaining scale to bau ofs
*
*      Loop to point to powers of ten table entry
*
GTN25  ADD  WA,XR            Bump pointer
       BCT  WB,GTN25         Once for each value word
       DVR  (XR)             Scale down as required
       BRN  GTN30            And jump
*
*      Come here to scale result up (positive exponent)
*
GTN26  NGI                   Get absolute value of exponent
       IOV  GTN36            Error if overflow
       MFI  WA,GTN36         Acquire scale, error if ovflow
*
*      Loop to scale up in steps of 10**10
*
GTN27  BLE  WA,=NUM10,GTN28  Jump if 10 or less to go
       MLR  REATT            Else multiply by 10**10
       ROV  GTN36            Error if overflow
       SUB  =NUM10,WA        Else decrement scale
       BRN  GTN27            And loop back
*
*      Here to scale up rest of way with table
*
GTN28  BZE  WA,GTN30         Jump if scaled
       LCT  WB,=CFP$R        Else get indexing factor
       MOV  =REAV1,XR        Point to powers of ten table
       WTB  WA               Convert remaining scale to bau ofs
*
*      Loop to point to proper entry in powers of ten table
*
GTN29  ADD  WA,XR            Bump pointer
       BCT  WB,GTN29         Once for each word in value
       MLR  (XR)             Scale up
       ROV  GTN36            Error if overflow
       EJC
*
*      GTNUM (continued)
*
*      Here with real value scaled and ready except for sign
*
GTN30  BZE  GTNNF,GTN31      Jump if positive
       NGR                   Else negate
*
*      Here with properly signed real value in (RA)
*
GTN31  JSR  RCBLD            Build real block
       BRN  GTN33            Merge to exit
.FI
*
*      Here with properly signed integer value in (IA)
*
GTN32  JSR  ICBLD            Build ICBLK
*
*      Real merges here
*
GTN33  MOV  (XR),WA          Load first word of result block
       ICA  XS               Pop argument off stack
*
*      Common exit point
*
GTN34  EXI                   Return to GTNUM caller
.IF    .CNRA
.ELSE
*
*      Come here if overflow occurs during collection of integer
*
GTN35  LDI  GTNSI            Reload integer so far
       ITR                   Convert to real
       NGR                   Make value positive
       BRN  GTN11            Merge with real circuit
.FI
*
*      Here for unconvertible to string or conversion error
*
GTN36  MOV  (XS)+,XR         Reload original argument
       EXI  1                Take convert-error exit
       ENP                   End procedure GTNUM
.IF    .CNRA
.ELSE
       EJC
*
*      GTREA -- get real value
*
*      GTREA is passed an object and returns a real value
*      performing any necessary conversions.
*
*      (XR)                  object to be converted
*      JSR  GTREA            call to convert object to real
*      PPM  LOC              transfer loc if convert impossible
*      (XR)                  pointer to resulting real
*      (WA,WB,WC,RA)         destroyed
*      (XR)                  unchanged (convert error only)
*
GTREA  PRC  E,1              Entry point
       MOV  (XR),WA          Get first word of block
       BEQ  WA,=B$RCL,GTRE2  Jump if real
       JSR  GTNUM            Else convert argument to numeric
       PPM  GTRE3            Jump if unconvertible
       BEQ  WA,=B$RCL,GTRE2  Jump if real was returned
*
*      Here for case of an integer to convert to real
*
GTRE1  LDI  ICVAL(XR)        Load integer
       ITR                   Convert to real
       JSR  RCBLD            Build RCBLK
*
*      Exit with real
*
GTRE2  EXI                   Return to GTREA caller
*
*      Here on conversion error
*
GTRE3  EXI  1                Take convert error exit
       ENP                   End procedure GTREA
.FI
       EJC
*
*      GTSMI -- get small integer
*
*      GTSMI is passed a SETL object and returns an address
*      integer in the range (0 le N le DNAMB). Such a value can
*      only be derived from an integer in the appropriate range.
*      Small integers never appear as SETL values. However,
*      they are used internally for a variety of purposes.
*
*      -(XS)                 argument to convert (on stack)
*      JSR  GTSMI            call to convert to small integer
*      PPM  LOC              transfer loc for not integer
*      PPM  LOC              transfer loc for lt 0, gt DNAMB
*      (XR,WC)               resulting small int (two copies)
*      (XS)                  popped
*      (RA)                  destroyed
*      (WA,WB)               destroyed (on convert error only)
*      (XR)                  input arg (convert error only)
*
GTSMI  PRC  N,2              Entry point
       MOV  (XS)+,XR         Load argument
       BEQ  (XR),=B$ICL,GTSM1 Skip if already an integer
*
*      Here if not an integer
*
       JSR  GTINT            Convert argument to integer
       PPM  GTSM2            Jump if convert is impossible
*
*      Merge here with integer
*
GTSM1  LDI  ICVAL(XR)        Load integer value
       MFI  WC,GTSM3         Move as one word, jump if ovflow
       BGT  WC,MXLEN,GTSM3   Or if too small
       MOV  WC,XR            Copy result to XR
       EXI                   Return to GTSMI caller
*
*      Here if unconvertible to integer
*
GTSM2  EXI  1                Take non-integer error exit
*
*      Here if out of range
*
GTSM3  EXI  2                Take out-of-range error exit
       ENP                   End procedure GTSMI
       EJC
*
*      GTSTG -- get string
*
*      GTSTG is passed an object and returns a string with
*      any necessary conversions performed.
*
*      -(XS)                 input argument (on stack)
*      JSR  GTSTG            call to convert to string
*      PPM  LOC              transfer loc if convert impossible
*      (XR)                  pointer to resulting string
*      (WA)                  length of string in characters
*      (XS)                  popped
*      (RA)                  destroyed
*      (XR)                  input arg (convert error only)
*
GTSTG  PRC  N,1              Entry point
       MOV  (XS)+,XR         Load argument, pop stack
       BEQ  (XR),=B$SCL,GTS30 Jump if already a string
*
*      Here if not a string already
*
GTS01  MOV  XR,-(XS)         Restack argument in case error
       MOV  XL,-(XS)         Save XL
       MOV  WB,GTSVB         Save WB
       MOV  WC,GTSVC         Save WC
       MOV  (XR),WA          Load first word of block
       BEQ  XR,=OMEGA,GTS03
       BEQ  WA,=B$ICL,GTS05  Jump to convert integer
.IF    .CNRA
.ELSE
       BEQ  WA,=B$RCL,GTS10  Jump to convert real
.FI
       BEQ  WA,=B$TVL,GTS03  jump for TVBLK
*
*      Here on conversion error
*
GTS02  MOV  (XS)+,XL         Restore XL
       MOV  (XS)+,XR         Reload input argument
       EXI  1                Take convert error exit
*
*
*      Here with TVBLK - required SCBLK starts at 1(XR)
*      OMEGA is the same
*
GTS03  ICA  XR               point to string
       BRN  GTS29            jump to exit
*
*      Come here to convert an integer
*
GTS05  LDI  ICVAL(XR)        Load integer value
       MOV  =NUM01,GTSSF     Set sign flag negative
       ILT  GTS06            Skip if integer is negative
       NGI                   Else negate integer
       ZER  GTSSF            And reset negative flag
       EJC
*
*      GTSTG (continued)
*
*      Here with sign flag set and sign forced negative as
*      required by the CVD instruction.
*
GTS06  MOV  GTSWK,XR         Point to result work area
       MOV  =NSTMX,WB        Initialize counter to max length
       PSC  XR,WB            Prepare to store (right-left)
*
*      Loop to convert digits into work area
*
GTS07  CVD                   Convert one digit into WA
       SCH  WA,-(XR)         Store in work area
       DCV  WB               Decrement counter
       INE  GTS07            Loop if more digits to go
       CSC  XR               Complete store characters
*
*      Merge here after converting integer or real into work
*      area. WB is set to NSTMX - (number of chars in result).
*
GTS08  MOV  =NSTMX,WA        Get max number of characters
       SUB  WB,WA            Compute length of result
       MOV  WA,-(XS)         Remember length for move later on
       ADD  GTSSF,WA         ADD one for negative sign if needed
       JSR  ALOCS            Allocate string for result
       MOV  XR,WC            Save result pointer for the moment
       MOV  (XS)+,XL         Recover length
       PSC  XR               Point to chars of result block
       BZE  GTSSF,GTS09      Skip if positive
       MOV  =CH$MN,WA        Else load negative sign
       SCH  WA,(XR)+         And store it
       CSC  XR               Complete store characters
*
*      Here after dealing with sign
*
GTS09  MOV  XL,WA            Recall length to move
       MOV  GTSWK,XL         Point to result work area
       PLC  XL,WB            Point to first result character
       MVC                   Move chars to result string
       MOV  WC,XR            Restore result pointer
.IF    .CNRA
.ELSE
       BRN  GTS29            Jump to exit
       EJC
*
*      GTSTG (continued)
*
*      Here to convert a real
*
GTS10  LDR  RCVAL(XR)        Load real
       ZER  GTSSF            Reset negative flag
       REQ  GTS31            Skip if zero
       RGE  GTS11            Jump if real is positive
       MOV  =NUM01,GTSSF     Else set negative flag
       NGR                   And get absolute value of real
*
*      Now scale the real to the range (0.1 le X lt 1.0)
*
GTS11  LDI  INTV0            Initialize exponent to zero
*
*      Loop to scale up in steps of 10**10
*
GTS12  STR  GTSRS            Save real value
       SBR  REAP1            Subtract 0.1 to compare
       RGE  GTS13            Jump if scale up not required
       LDR  GTSRS            Else reload value
       MLR  REATT            Multiply by 10**10
       SBI  INTVT            Decrement exponent by 10
       BRN  GTS12            Loop back to test again
*
*      Test for scale down required
*
GTS13  LDR  GTSRS            Reload value
       SBR  REAV1            Subtract 1.0
       RLT  GTS17            Jump if no scale down required
       LDR  GTSRS            Else reload value
*
*      Loop to scale down in steps of 10**10
*
GTS14  SBR  REATT            Subtract 10**10 to compare
       RLT  GTS15            Jump if large step not required
       LDR  GTSRS            Else restore value
       DVR  REATT            Divide by 10**10
       STR  GTSRS            Store new value
       ADI  INTVT            Increment exponent by 10
       BRN  GTS14            Loop back
       EJC
*
*      GTSTG (continued)
*
*      At this point we have (1.0 le X lt 10**10)
*      complete scaling with powers of ten table
*
GTS15  MOV  =REAV1,XR        Point to powers of ten table
*
*      Loop to locate correct entry in table
*
GTS16  LDR  GTSRS            Reload value
       ADI  INTV1            Increment exponent
       ADD  *CFP$R,XR        Point to next entry in table
       SBR  (XR)             Subtract it to compare
       RGE  GTS16            Loop till we find a larger entry
       LDR  GTSRS            Then reload the value
       DVR  (XR)             And complete scaling
       STR  GTSRS            Store value
*
*      We are now scaled, so round by adding 0.5 * 10**(-CFP$S)
*
GTS17  LDR  GTSRS            Get value again
       ADR  GTSRN            ADD rounding factor
       STR  GTSRS            Store result
*
*      The rounding operation may have pushed us up past
*      1.0 again, so check one more time.
*
       SBR  REAV1            Subtract 1.0 to compare
       RLT  GTS18            Skip if ok
       ADI  INTV1            Else increment exponent
       LDR  GTSRS            Reload value
       DVR  REAVT            Divide by 10.0 to rescale
       BRN  GTS19            Jump to merge
*
*      Here if rounding did not muck up scaling
*
GTS18  LDR  GTSRS            Reload rounded value
       EJC
*
*      GTSTG (continued)
*
*      Now we have completed the scaling as follows
*
*      (IA)                  signed exponent
*      (RA)                  scaled real (absolute value)
*
*      If the exponent is negative or greater than CFP$S, then
*      we convert the number in the form.
*
*      (Neg sign) 0 . (cpf$s digits) e (EXP sign) (EXP digits)
*
*      If the exponent is positive and less than or equal to
*      CFP$S, the number is converted in the form.
*
*      (Neg sign) (exponent digits) . (CFP$S-exponent digits)
*
*      In both cases, the formats obtained from the above
*      rules are modified by deleting trailing zeros after the
*      decimal point. There are no leading zeros in the exponent
*      and the exponent sign is always present.
*
GTS19  MOV  =CFP$S,XL        Set num dec digits = CFP$S
       MOV  =CH$MN,GTSES     Set exponent sign negative
       ILT  GTS21            All set if exponent is negative
       MFI  WA               Else fetch exponent
       BLE  WA,=CFP$S,GTS20  Skip if we can use special format
       MTI  WA               Else restore exponent
       NGI                   Set negative for CVD
       MOV  =CH$PL,GTSES     Set plus sign for exponent sign
       BRN  GTS21            Jump to generate exponent
*
*      Here if we can use the format without an exponent
*
GTS20  SUB  WA,XL            Compute digits after decimal point
       LDI  INTV0            Reset exponent to zero
       EJC
*
*      GTSTG (continued)
*
*      Merge here as follows
*
*      (IA)                  exponent absolute value
*      GTSES                 character for exponent sign
*      (RA)                  positive fraction
*      (XL)                  number of digits after dec point
*
GTS21  MOV  GTSWK,XR         Point to work area
       MOV  =NSTMX,WB        Set character ctr to max length
       PSC  XR,WB            Prepare to store (right to left)
       IEQ  GTS23            Skip exponent if it is zero
*
*      Loop to generate digits of exponent
*
GTS22  CVD                   Convert a digit into WA
       SCH  WA,-(XR)         Store in work area
       DCV  WB               Decrement counter
       INE  GTS22            Loop back if more digits to go
*
*      Here generate exponent sign and e
*
       MOV  GTSES,WA         Load exponent sign
       SCH  WA,-(XR)         Store in work area
       MOV  =CH$LE,WA        Get character letter e
       SCH  WA,-(XR)         Store in work area
       SUB  =NUM02,WB        Decrement counter for sign and e
*
*      Here to generate the fraction
*
GTS23  MLR  GTSSC            Convert real to integer (10**CFP$S)
       RTI                   Get integer (overflow impossible)
       NGI                   Negate as required by CVD
*
*      Loop to suppress trailing zeros
*
GTS24  BZE  XL,GTS27         Jump if no digits left to do
       CVD                   Else convert one digit
       BNE  WA,=CH$D0,GTS26  Jump if not a zero
       DCV  XL               Decrement counter
       BRN  GTS24            Loop back for next digit
       EJC
*
*      GTSTG (continued)
*
*      Loop to generate digits after decimal point
*
GTS25  CVD                   Convert a digit into WA
*
*      Merge here first time
*
GTS26  SCH  WA,-(XR)         Store digit
       DCV  WB               Decrement counter
       DCV  XL               Decrement counter
       BNZ  XL,GTS25         Loop back if more to go
*
*      Here generate the decimal point
*
GTS27  MOV  =CH$DT,WA        Load decimal point
       SCH  WA,-(XR)         Store in work area
       DCV  WB               Decrement counter
*
*      Here generate the digits before the decimal point
*
GTS28  CVD                   Convert a digit into WA
       SCH  WA,-(XR)         Store in work area
       DCV  WB               Decrement counter
       INE  GTS28            Loop back if more to go
       CSC  XR               Complete store characters
       BRN  GTS08            Else jump back to exit
.FI
*
*      Exit point after successful conversion
*
GTS29  MOV  (XS)+,XL         Restore XL
       ICA  XS               Pop argument
       MOV  GTSVB,WB         Restore WB
       MOV  GTSVC,WC         Restore WC
*
*      Merge here if no conversion required
*
GTS30  MOV  SCLEN(XR),WA     Load string length
       EXI                   Return to caller
.IF    .CNRA
.ELSE
*
*      Here to return string for real zero
*
GTS31  MOV  =SCRE0,XL        Point to string
       MOV  =NUM02,WA        2 Chars
       ZER  WB               Zero offset
       JSR  SBSTR            Copy string
       BRN  GTS29            Return
.FI
       ENP                   End procedure GTSTG
       EJC
*
*      HASHS -- compute hash index for string
*
*      HASHS is used to convert a string to a unique integer
*      value. The resulting hash value is a positive integer
*      in the range 0 to CFP$M
*
*      (XR)                  string to be hashed
*      JSR  HASHS            call to hash string
*      (IA)                  hash value
*      (XR,WB,WC)            destroyed
*
*      The hash function used is as follows.
*
*      Take the first E$HNW words of the characters from
*      the string or all the words if fewer than E$HNW.
*
*      Compute the exclusive or of all these words treating
*      them as one word bit string values.
*
*      Move the result as an integer with the MTI instruction.
*
HASHS  PRC  E,0              Entry point
       MOV  SCLEN(XR),WC     Load string length in characters
       MOV  BITS0,WB         Initialize with all zero bits
       BZE  WC,HSHS3         Jump if null string
       CTW  WC,0             Else get number of words of chars
       ADD  *SCHAR,XR        Point to characters of string
       BLO  WC,=E$HNW,HSHS1  Use whole string if short
       MOV  =E$HNW,WC        Else set to involve first E$HNW wds
*
*      Here with count of words to check in WC
*
HSHS1  LCT  WC,WC            Set counter to control loop
*
*      Loop to compute exclusive or
*
HSHS2  XOB  (XR)+,WB         Exclusive or next word of chars
       BCT  WC,HSHS2         Loop till all processed
*
*      Merge here with exclusive or in WB
*
HSHS3  ZGB  WB               Zeroise undefined bits
       ANB  BITSM,WB         Ensure in range 0 to CFP$M
       MTI  WB               Move result as integer
       ZER  XR               Clear garbage value in XR
       EXI                   Return to HASHS caller
       ENP                   End procedure HASHS
       EJC
*
*      HASHV -- calculate hash value
*
*      The hash value returned is an integer in the range
*      0 to CFP$M.  This is computed for the various types
*      as follows -
*      integer                result is value modulo cfp$m
*      real                  convert to integer, then as above
*      string                 see HASHS
*      truth-value,OM        use the address
*      pair                  use the hash value of domain only
*                            (see FINDS for rationale)
*      aggregate values
*                            result is exclusive OR of the
*                            hashes of the components. (OMs
*      (XR)                  ptr to object to hash
*      JSR  HASHV
*      (IA)                  hash value
*      (WA, WB, WC)          destroyed
*
HASHV  PRC  R,0
       CHK
       MOV  XL,-(XS)         save callers XL
       MOV  (XR),XL          load type code
       LEI  XL               get EPI
       BSW  XL,BL$$D,HSHV0
*
       IFF  BL$IC,HSHV2
.IF    .CNRA
.ELSE
       IFF  BL$RC,HSHV1
.FI
       IFF  BL$SC,HSHV3
       IFF  BL$TP,HSHV4
       IFF  BL$PR,HSHV5
       IFF  BL$ST,HSHV6
       IFF  BL$MP,HSHV6
       ESW
       EJC
*
*      Default action here is to return address
*
HSHV0  MTI  XR
       MOV  (XS)+,XL
       EXI
*
.IF    .CNRA
.ELSE
HSHV1  LDR  RCVAL(XR)        load real value
       RTI                   turn it into a integer
       BRN  HSV21            merge with integer case
.FI
*
*      Here with integer
*
HSHV2  LDI  ICVAL(XR)        load integer value
*
*      Real merges here with integer in IA
*
HSV21  IGE  HSV22            check if non-negative
       NGI                   negate if needed
HSV22  RMI  HSV$M            reduce to required range
       MOV  (XS)+,XL
       EXI
*
*      Here a string
*
HSHV3  MOV  XR,-(XS)
       JSR  HASHS            call a friend
       MOV  (XS)+,XR
       MOV  (XS)+,XL
       EXI
       EJC
*
*      Tuple (TPBLK)
*
HSHV4  ZER  WB               clear for result
       BEQ  XR,=NLTUP,HSV42  return 0 for null tup
       BZE  TPNEL(XR),HSV42
       MOV  =NUM01,WA        load index for first element
*
*      Loop to extract successive elements
*
HSV40  MOV  XR,-(XS)         stack TPBLK
       MOV  WA,-(XS)         and index
       MOV  WB,-(XS)         and partial result
       JSR  TPELT            fetch element
       PPM  HSV41            leave loop when done
       JSR  HASHV            get hash of this one
       MFI  WB               put it in a reg
       XOB  (XS)+,WB         mix in result so far
       MOV  (XS)+,WA         recover index
       ICV  WA               and bump it
       MOV  (XS)+,XR         get the TPBLK
       BRN  HSV40
*
*      Here when the tuple is exhausted
*
HSV41  MTI  (XS)+            load the result
       ICA  XS               pop off index
       MOV  (XS)+,XR         recover argument
       MOV  (XS)+,XL
       EXI
*
*      Special case for null set or tuple
*
HSV42  MTI  WB               return 0
       MOV  (XS)+,XL
       EXI
       EJC
*
*      Here with PRBLK (pair)
*
HSHV5  MOV  XR,-(XS)         stack it
       MOV  PRDOM(XR),XR     load first
       JSR  HASHV            and hash that
       MOV  (XS)+,XR
       MOV  (XS)+,XL
       EXI
       EJC
*
*      All set-like objects come here
*
HSHV6  ZER  WB               clear for result
       BEQ  XR,=NLSET,HSV42  return 0 for null set
       BZE  STNEL(XR),HSV42
       MOV  *STSI$,XL        initialise offset
*
*      Now loop to extract elements - we know its finished
*      when we get wraparound, signalled by WB
*
HSV60  MOV  XR,-(XS)         save argument
       MOV  WB,-(XS)         and partial result
       JSR  NEXTS            get a element
       BNZ  WB,HSV61         leave loop
       BEQ  XR,=OMEGA,HSV66  ignore OMs
       JSR  HASHV            now hash element
       MFI  WB               get the value
HSV66  XOB  (XS)+,WB         mix in the est
       MOV  (XS)+,XR
       BRN  HSV60
*
*      Here when finished
*
HSV61  MTI  (XS)+            load result
       MOV  (XS)+,XR
       MOV  (XS)+,XL
       EXI
       ENP
       EJC
*
*      ICBLD -- build integer block
*
*      (IA)                  integer value for ICBLK
*      JSR  ICBLD            call to build integer block
*      (XR)                  pointer to result ICBLK
*      (WA)                  destroyed
*
ICBLD  PRC  E,0              Entry point
       MFI  XR,ICBL1         Copy small integers
       BLE  XR,=NUM02,ICBL3  Jump if 0,1 or 2
*
*      Construct ICBLK
*
ICBL1  MOV  DNAMP,XR         Load pointer to next available loc
       ADD  *ICSI$,XR        Point past new ICBLK
       BLO  XR,DNAME,ICBL2   Jump if there is room
       MOV  *ICSI$,WA        Else load length of ICBLK
       ZER  XL               JVK - clear for GBCOL
       JSR  ALLOC            Use standard allocator to get block
       ADD  WA,XR            Point past block to merge
*
*      Merge here with XR pointing past the block obtained
*
ICBL2  MOV  XR,DNAMP         Set new pointer
       SUB  *ICSI$,XR        Point back to start of block
       MOV  =B$ICL,(XR)      Store type word
       STI  ICVAL(XR)        Store integer value in ICBLK
       EXI                   Return to ICBLD caller
*
*      Optimise by not building icblks for small integers
*
ICBL3  WTB  XR               Convert integer to offset
       MOV  INTAB(XR),XR     Point to pre-built ICBLK
       EXI                   Return
       ENP                   End procedure ICBLD
       EJC
*
*      ICCMP -- compare integers
*
*      (XL)                  left operand ICBLK ptr
*      (XR)                  right operand ICBLK ptr
*      JSR  ICCMP
*      PPM  loc1             left less than right
*      PPM  loc2             left equal to right
*      PPM  loc3             left greater than right
*      (normal return never taken)
*
ICCMP  PRC  E,3
       LDI  ICVAL(XL)        load value of left
       SBI  ICVAL(XR)        subtract to compare
       IOV  ICCM3            jump with overflow
       IGT  ICCM1
       ILT  ICCM2
*
*      Fall through if equal
*
       EXI  2
ICCM1  EXI  3
ICCM2  EXI  1
*
*      Here if subtraction caused overflow
*
ICCM3  LDI  ICVAL(XR)        load right value
       ILT  ICCM1            greater than if negative
       BRN  ICCM2            else less than
       ENP
       EJC
*
*      INSTA -- USED TO INITIALIZE STRUCTURES IN STATIC REGION
*
*      (XR)                  PTR TO STARTING STATIC LOCATION
*      JSR  INSTA            CALL TO INITIALIZE STATIC STRUCTURE
*      (XR)                  PTR TO NEXT FREE STATIC LOCATION
*      (WA,WB,WC)            DESTROYED
*
INSTA  PRC  E,0              ENTRY POINT
*
*      Initialise print buffer with blank words
*
       MOV  PRLEN,WC         No of chars in print bfr
       MOV  XR,PRBUF         Print bfr is put at static start
       MOV  =B$SCL,(XR)+     Store string type code
       MOV  WC,(XR)+         And string length
       CTW  WC,0             Get number of words in buffer
       MOV  WC,PRLNW         Store for buffer clear
       LCT  WC,WC            Words to clear
*
*      Loop to clear buffer
*
INST1  MOV  NULLW,(XR)+      Store blank
       BCT  WC,INST1         Loop
       EXI
       ENP
       EJC
*
*
*      IOPUT -- establish i-o association
*
*      Called by INPUT or OUTPUT to check whether a file
*      corresponding to its argument is already open, if
*      not, to open it, and select for subsequent READ/PRINT
*
*      (WA)                  arg count for INPUT/OUTPUT
*      (WB)                  0/3 = in/out
*      -(XS),...             arguments on stack
*      JSR  IOPUT
*      PPM  loc              file cannot be opened
*      (XR)                  pre to IOBLK/0
*
IOPUT  PRC  N,1
       BNZ  WA,IOP01         jump if any args
       ERB  281,missing INPUT-OUTPUT file arg
*
*      Get the file identifier
*
IOP01  MOV  (XS)+,XR         retrieve first arg
       BNE  (XR),=B$SCL,IOP08 error if not string
       MOV  XR,R$IO1         save arg1 string
       MOV  XR,R$IO2         provisional also arg2
       DCV  WA                   count one argument
       BZE  WA,IOPX1             jump if no arg2
       MOV  (XS)+,XR         get second arg
       BNE  (XR),=B$SCL,IOP08 also must be string
       MOV  XR,R$IO2         save arg2 string
       DCV  WA               count the second argument
*
*      Remove any excess arguments from stack
*
IOPX1  WTB  WA
       ADD  WA,XS            discard
       MOV  R$IO1,XL         load arg1 pointer
       MOV  WB,IOPWB         save i/o indicator
       JSR  IOSRC            check for open file
       PPM  IOP02            go open it
*
*      If found, error if file open
*
       ERB  274,I/O file arg already open
*
*      If file not found, open it
*
IOP02  ZER  WC               nothing stacked yet
       ZER  WA               no existing FCBLK
       MOV  IOPWB,WB         restore i/o indicator
       MOV  R$IO1,XL         load arg1 ptr
       MOV  R$IO2,XR         and arg2
       BEQ  XR,=NULLS,IOPX2  jump if no arg2
       MOV  XR,-(XS)         else stack it
       ICV  WC               and record the fact
IOPX2  JSR  SYSFC            see about FCBLK
       ERR  278,invalid file argument
       BZE  WA,IOPX3         jump if private block
       JSR  ALLOC            allocate FCBLK if required
       EJC
       MOV  WA,WB
       BTW  WB               how many words to clear
       LCT  WB,WB
IOP04  ZER  (XR)+            clear a word of FCBLK
       BCT  WB,IOP04
       SUB  WA,XR            point back to start
       MOV  =B$XRT,(XR)      provisional XRBLK
       BZE  WC,IOP05         yes
       MOV  =B$XRT,(XR)      set XRBLK type word
IOP05  MOV  WA,OFFS1(XR)         and length
*
*      Set up i-o association
*
       MOV  XR,WA            copy FCBLK pointer if any
       BRN  IOP03
*
*      If no FCBLK is reuired, copy private pointer/0
*
IOPX3  MOV  XL,WA
IOP03  MOV  R$IO2,XR         clear XR pointer
       MOV  IOPWB,WB         copy i/o indicator
       MOV  R$IO1,XL         reload arg1
       JSR  SYSIO
       PPM  IOP06
       ERR  279,INPUT/OUTPUT not allowed on file
*
*      Now have FCBLK pointer in (XL) - add to chain
*      And set up IOBLK
*
       MOV  *IOSI$,WA        length of IOBLK
       JSR  ALLOC            get one
       MOV  =B$IOT,(XR)      set type
       MOV  R$IO1,IOSCB(XR)  ptr to filearg
       MOV  XL,IOFCB(XR)     ptr to FCBLK
       MOV  R$FCB,IOLNK(XR)  add to FCBLK..
       MOV  XR,R$FCB         ..chain
       MOV  IOPWB,IOUSE(XR)  save 0/3 indicator
       ZER  IOEOF(XR)        init not eof
       BNZ  IOPWB,IOP12      jump if output
       MOV  =NULLS,IOINL(XR) No image read
       ZER  IOOFS(XR)        Initial offset
       EXI
*
*      If output, clean up unused fields
*
IOP12  ZER  IOOFS(XR)
       ZER  IOINL(XR)
       EXI
*
IOP06  EXI  1                fail
IOP08  ERB  273,INPUT-OUTPUT arg not string type
       ENP
       EJC
*
*      IOSRC -- perform i-o search
*
*      Called to search FCBLK chain for an existing
*      IOBLK for its argument.  Current version converts
*      all file names to lower case, hence not sensitive
*      to use of different case in file names.  If needed,
*      could later make this a conditional assembly symbol.
*
*      (XL)                  SCBLK ptr (filearg)
*      JSR  IOSRC
*      PPM  loc              search fails
*      (XR)                  pointer to matching IOBLK
*      (WA,WB,WC)            destroyed
*
IOSRC  PRC  E,1
       MOV  XL,IOARG         save argument
*
*      Now convert file name to lower case
*
       MOV  XL,XR            copy right back to same block
       MOV  SCLEN(XL),WA     get string length
       PLC  XL
       PSC  XR
       LCT  WA,WA
IOSR5  LCH  WB,(XL)+         get one char
       BLT  WB,=CH$LA,IOSR6  only convert upper..
       BGT  WB,=CH$L$,IOSR6    .. case letters
.IF    .CSLL
       SUB  =LCDIF,WB        convert a char
.ELSE
       ADD  =LCDIF,WB
.FI
IOSR6  SCH  WB,(XR)+         store result
       BCT  WA,IOSR5         loop
       CSC  XR               and clean up
*
*      Now continue to look thru chain.  Note that all
*      the IOBLKs have lower case file names, since IOPUT
*      first calls IOSRC.
*
       MOV  IOARG,XL         retrieve argument
       MOV  R$FCB,XR         point to chain head
IOSR1  BZE  XR,IOSR2         jump if end of chain
       MOV  XR,IOSXR         save pointer
       MOV  IOSCB(XR),XR     load SCBLK ptr
       JSR  LCOMP            check for match
       PPM  IOSR3            no match
       PPM  IOSR4            jump if match
       PPM  IOSR3
*
IOSR3  MOV  IOARG,XL         recover arg
       MOV  IOSXR,XR         and pointer
       MOV  IOLNK(XR),XR     next on chain
       BRN  IOSR1            loop
*
*      Here on match
*
IOSR4  MOV  IOSXR,XR         recover result
       MOV  IOARG,XL         and arg pointer
       EXI
*
*      Failure
*
IOSR2  EXI  1
       ENP
       EJC
*
*      LABCR -- Check to see whether label has been referenced .
*
*      (XL)                  Label number
*      JSR  LABCR
*      PPM  loc              not referenced
*      (normal return)       referenced
*      (XL,WA)               destroyed
*
LABCR  PRC  E,1
       MOV  XL,WA            Copy label nr
       ADD  R$LBV,XL         point to table entry
       BNZ  (XL),LBCR6       jump if referenced
       MOV  R$LBR,XL         pt to chain of current refs
LBCR2  BZE  XL,LBCR4         not reffed if find chain end
       BEQ  LRCDB(XL),WA,LBCR6 OK if label nr matches
       MOV  LRNXT(XL),XL     else continue down chain
       BRN  LBCR2
LBCR4  EXI  1
*
LBCR6  EXI
       ENP
       EJC
*
*      LABRF -- make a label reference
*
*      Backward references are resolved immediately from the
*      table. Others are chained from R$LBR, because the LRCDB
*      fields cannot be set until the code block under
*      construction has been completed.
*
*      (XR)                  jump opcode (or 0 if unconditional)
*      (XL)                  label number
*      JSR  LABRF
*      (XR,XL,WA)            destroyed
*
LABRF  PRC  E,0
       BZE  XR,LBR00         omit some if unconditional
       MOV  XR,WA            else copy conditional jump
       JSR  CDWRD            and generate it
LBR00  MOV  XL,LRNUM         save the label number
       ADD  R$LBV,XL         point to entry in table
       BEQ  (XL),=R$LBC,LBR1A jump if current block
       BZE  (XL),LBR01       jump if unset
*
       MOV  (XL),XL          load block
       BNE  (XL),=B$CDS,LBR01 jump if label not yet seen
*
*      Here we have a reference to a albel already set
*
       MOV  XL,WA            copy pointer to CDBLK
       JSR  CDWRD            generate the jump
       BRN  LBR02
*
*      Here with reference to head of current block. Fudge the
*      label number to be special marker.
*
LBR1A  MOV  =R$LBC,LRNUM
*
*      Here with forward reference
*
LBR01  MOV  *LRSI$,WA        size for a LRBLK
       ZER  XL               JVK in case gbcol
       JSR  ALLOC             go and get one
       MOV  =B$LRB,(XR)      set type field
       MOV  R$LBR,LRNXT(XR)     add to chain
       MOV  LRNUM,LRCDB(XR)  put label number in unusable field
       MOV  CWCOF,LRCOF(XR)  offset is ok
       MOV  XR,R$LBR          reset chain head
*
       ZER  WA               clear register
       JSR  CDWRD            to generate  null codeword
LBR02  EXI
       ENP
       EJC
*
*      LABST -- set a label
*
*      When a label is set, the CCBLK at present under
*      construction can be carved off into a CDBLK. It is
*      only at this point that the final location of the
*      block is known, since, up till then CDWRD has the option
*      of allocating a new CCBLK if the present one gets full.
*      This means that we are now in a position to resolve
*      references to the label which points to the start of the
*      block.  On the other hand, references to this label
*      cannot be resolved until this CCBLK is finished with in
*      its turn.
*      See LRBLK description for details of the chains employed
*      to keep track of references.
*
*      (XL)                  number of this label
*      JSR  LABST
*      (XL, XR, WA,WB,WC) destroyed
*
LABST  PRC  E,0
       MOV  XL,LBSTN         save label number
*      First deal with the list of references made within this
*      CCBLK
*
       MOV  R$LBR,XL         get chain head
LBS01  BZE  XL,LBS02         quit if done
       MOV  LRCDB(XL),XR     get label number
       MOV  LRNXT(XL),WA     point to next item
       BEQ  XR,=R$LBC,LBS11  Jump if current block
       ADD  R$LBV,XR         Else point to table entry
LBS11  MOV  (XR),LRNXT(XL)   add to chain
       MOV  R$CCB,LRCDB(XL)  set ptr to CDBLK
       MOV  XL,(XR)          reset chain head
       MOV  WA,XL            get next item
       BRN  LBS01
*
LBS02  ZER  R$LBR
*
*      Now resolve the references to this CCBLK
*
       MOV  R$LBC,XL         get chain head
LBS03  BZE  XL,LBS04         exit if end
       MOV  LRCOF(XL),XR     get offset
       ADD  LRCDB(XL),XR     point to codeword with reference
       MOV  R$CCB,(XR)       resolve reference
       MOV  LRNXT(XL),XL     get next item
       BRN  LBS03
*
*      We can also set a value in the table
*
LBS04  MOV  LSLAB,XL
       BZE  XL,LBS05
       ADD  R$LBV,XL         add base
       MOV  R$CCB,(XL)
       EJC
*
*      Now deal with the present label
*      Set R$LBC to point to any references already made to it
*      and place =R$LBC to mark the entry in the table
*
LBS05  MOV  LBSTN,XL         retrieve argument
       MOV  XL,LSLAB         will now be current label
       ADD  R$LBV,XL
       MOV  (XL),R$LBC       use existing reference chain
       MOV  =R$LBC,(XL)      mark entry
*
*      Finally, we can actually cut off the CDBLK
*
       MOV  R$CCB,XR         point to CCBLK
       MOV  =B$CDS,(XR)      set type word
       MOV  XR,XL            copy pointer to CCBLK
       MOV  CCUSE(XR),WB     load length generated
       MOV  CCLEN(XR),WC     load total CCBLK length
       ADD  WB,XL            point past CDBLK
       SUB  WB,WC            get length left
       BLT  WC,*CCCOD,LBS12  check size of remainder
       MOV  =B$CCT,(XL)      set type field of new CCBLK
       MOV  *CCCOD,CCUSE(XL) set initial code offset
       MOV  *CCCOD,CWCOF     re-initialise current offset
       MOV  WC,CCLEN(XL)     set new length
       MOV  XL,R$CCB         set new current CCBLK
       MOV  CCSTN,CDSTM(XR)  set statement number
       MOV  CDGSN,CCSTN      and reset value for next block
       EXI
*
*      Here if remaining block too small for CCBLK
*
LBS12  ADD  WC,CCUSE(XR)     count extra in block size
       BTW  WC               number of garbage words
       LCT  WC,WC
LBS13  ZER  (XL)+            empty the fields
       BCT  WC,LBS13
       MOV  CCSTN,CDSTM(XR)  set statement number
       MOV  CDGSN,CCSTN      and reset value for next block
*
*      Here we allocate a fresh CCBLK
*
       MOV  *E$CBS,WA        load initial length
       ZER  XL
       JSR  ALLOC            allocate block
       MOV  =B$CCT,(XR)      set type field
       MOV  WA,CCLEN(XR)     block length
       MOV  *CCCOD,CCUSE(XR) set initial code offset
       MOV  *CCCOD,CWCOF     re-initialise current offset
       MOV  XR,R$CCB         set new current CCBLK
       EXI
       ENP
       EJC
*
*      LCOMP -- compare two strings lexically
*
*
*      (XL)                  left comparand
*      (XR)                  right comparand
*      JSR  LCOMP
*      PPM  loc              left llt right
*      PPM  loc              left leq right
*      PPM  loc              left lgt right
*      (XR,XL)                destroyed
*      (WA,WB,WC)            destroyed
*
LCOMP  PRC  E,3
       BNE  XR,=NULLS,LCMP0
       BNE  XL,=NULLS,LCMP3  must be lgt if not null
       EXI  2                else equal if both are
*
LCMP0  BEQ  XL,=NULLS,LCMP4  llt if other was non-null
       MOV  SCLEN(XR),WB     load right length
       MOV  SCLEN(XL),WA     load left length
       MOV  WA,WC            and save it
       PLC  XL
       PLC  XR
       BLO  WA,WB,LCMP1      jump if left length smaller
       MOV  WB,WA            else swap (WA)
*
*      Here with smaller length in WA
*
LCMP1  CMC  LCMP4,LCMP3      compare strings
       BNE  WB,WC,LCMP2      if equal, jump with diff lengths
       EXI  2                else entirely equal
       EJC
*
*      Here if initial strings equal, but total lengths
*      diferent
*
LCMP2  BLO  WC,WB,LCMP4
*
*      Fall through for greater exit
*
LCMP3  EXI  3
*
LCMP4  EXI  1
       ENP
       EJC
*
*      LISTR -- list source line
*
*      LISTR is used to list a source line during the initial
*      compilation. It is called from SCANE and scanl.
*
*      JSR  LISTR            call to list line
*      (XR,XL,WA,WB,WC)      destroyed
*
*      Global locations used by LISTR
*
*      ERLST                 if listing on account of an error
*
*      LSTLC                 count lines on current page
*
*      LSTNP                 max number of lines/page
*
*      LSTPF                 set non-zero if the current source
*                            line has been listed, else zero.
*
*      LSTPG                 compiler listing page number
*
*      LSTSN                  0 or stmt nr to put on listing
*
*      R$CIM                 pointer to current input line.
*
*      R$TTL                 title for source listing
*
*      R$STL                 ptr to SUB-title string
*
*      Entry point
*
LISTR  PRC  E,0              Entry point
*       BNZ  cnttl,list5      jump if -title or -stitl
       BNZ  LSTPF,LIST4      Immediate exit if already listed
       BGE  LSTLC,LSTNP,LIST6 Jump if no room
*
*      Here after printing title (if needed)
*
LIST1  MOV  LSTNO,WC         Line number
       MTI  WC               Convert to integer
       JSR  PRTIN            Place in output buffer
       MOV  =STNPD,PROFS     Offset past stmt number
       MOV  LSTSN,WC         Load statement number
       BZE  WC,LIST2         Jump if no statement number
       MTI  WC               Else get stmnt number as integer
       JSR  PRTIN            Print statement number
       EJC
*
*      LISTR (continued)
*
*      Line and statement numbers placed
*
LIST2  MOV  =STNPD,PROFS     Point past line number
       ADD  =STNPD,PROFS     Point past statement number
       MOV  R$CIM,XR         Load pointer to current image
       JSR  PRTST            Print it
       ICV  LSTLC            Bump line counter
       BNZ  ERLST,LIST3      Jump if error copy to int.Ch.
       JSR  PRTNL            Terminate line
*
*      Here after printing source image
*
LIST3  MNZ  LSTPF            Set flag for line printed
*
*      Merge here to exit
*
LIST4  EXI                   Return to LISTR caller
*
*      Print title after -title or -stitl card
*
*       List5  ZER  cnttl            clear flag
*
*      Eject to new page and list title
*
LIST6  JSR  PRTPS            Eject
       BZE  PRICH,LIST7      Skip if listing to regular printer
       BEQ  R$TTL,=NULLS,LIST1 Terminal listing omits null title
*
*      List title
*
LIST7  JSR  LISTT            List title
       BRN  LIST1            Merge
       ENP                   End procedure LISTR
       EJC
*
*      LISTT -- list title and subtitle
*
*      Used during compilation to print page heading
*
*      JSR  LISTT            call to list title
*      (XR,WA)               destroyed
*
LISTT  PRC  E,0              Entry point
       MOV  R$TTL,XR         Point to source listing title
       JSR  PRTST            Print title
       MOV  LSTPO,PROFS      Set offset
       MOV  =LSTMS,XR        Set page message
       JSR  PRTST            Print page message
       ICV  LSTPG            Bump page number
       MTI  LSTPG            Load page number as integer
       JSR  PRTIN            Print page number
       JSR  PRTNL            Terminate title line
       ADD  =NUM02,LSTLC     Count title line and blank line
*
*      Print SUB-title (if any)
*
       MOV  R$STL,XR         Load pointer to SUB-title
       BZE  XR,LSTT1         Jump if no SUB-title
       JSR  PRTST            Else print SUB-title
       JSR  PRTNL            Terminate line
       ICV  LSTLC            Bump line count
*
*      Return point
*
LSTT1  JSR  PRTNL            Print a blank line
       EXI                   Return to caller
       ENP                   End procedure LISTT
       EJC
*
*      NEXTS -- return next element from set/map
*
*      NEXTS is used by all the operations which have to
*      iterate over sets.  A set (type code = B$STL) may
*      have entries which are lists of pairs, a map will
*      have nothing but.  See FINDS for description of
*      chains.
*
*      (XR)                  ptr to set/map block
*      (XL)                  iterator variable
*      JSR  NEXTS
*      (XR)                  returned value
*      (XL)                  updated for next time
*      (WA)                  copy of set/map ptr
*      (WB)                  non zero if wraparound occurs
*
*      The value in (XL) may be either a simple offset or
*      a pointer.  The offset is allowed to exceed the length
*      of the set block - if an excess value is detected, it
*      is reset to *STSI$, and the flag is set in (WB).  This
*      means that an operation to iterate over an entire set
*      can proceed by starting with (XL) = *STSI$, and going on
*      until a non-zero value is returned in (WB), without
*      having to count.
*      If the value in (XL) is a pointer, it means that we are
*      in the middle of a pair chain, and appropriate action is
*      taken.  We will have set up the PRNXT field of the last
*      pair in the chain so that it contains an appropriate
*      value for next time.
*      Dead entries are represented by 0 and are skipped.
*
       EJC
NEXTS  PRC  E,0
       ZER  WB               clear flag
*
*      Check value in (XL).  It is possible to get here
*      with (WB) non zero, if we have a set with nothing
*      but dead entries
*
NXTS0  BZE  WB,NXTSX
       EXI                   immediate exit if so
NXTSX  BGE  XL,MXLEN,NXTS1   jump with a pointer
       BLT  XL,STLEN(XR),NXTS2 jump if no wraparound
       MOV  *STSI$,XL        offset to first element
       MNZ  WB               set flag
*
*      Merge to select element
*
NXTS2  MOV  XR,WA            copy set pointer
       ADD  XL,XR            point to entry
       MOV  (XR),XR          load entry
       ICA  XL               update offset
       BNZ  XR,NXTS3         jump if live value
       MOV  WA,XR            recover ptr
       BRN  NXTS0            and try again
*
NXTS3  BEQ  (XR),=B$PRL,NXTS4 jump if we got a pair
       EXI
*
*      Here for a pair
NXTS1  MOV  XL,XR            this is the result
NXTS4  MOV  PRNXT(XR),XL     update for next time
       EXI
       ENP
       EJC
*
*      NXTLB -- get parameter to identify generated label
*
*      These parameters are allocated in address-sized
*      increments for easy indexing into the label table
*
*      JSR  NXTLB
*      (WA)                  result
*
NXTLB  PRC  E,0
       MOV  LBNUM,WA         get next value
       ICA  LBNUM            increment by BAU in a word
       BGT  LBNUM,*MAXLB,NXL00 jump if overflowed
       EXI
*
*      Here to bomb out if we ve exhausted label numbers -
*      hope this never happens.
*
NXL00  ERB  270,too many labels needed
       ENP
       EJC
*
*      NXTNP -- update to next NPOW selector
*
*      Called during construction of NPOW, which uses a selector
*      tuple (of 0s and 1s), indicating which set elements should
*      be selected.  This procedure updates a given selector to
*      the next value.  The caller must recognize termination, in
*      which case the selector value ends in n 1s.
*
*      (XL)                  pointer to selector tuple
*      JSR  NXTNP            call to update selector tuple
*      (XL)                  restored
*      (WA,WB,WC)            destroyed
*
NXTNP  PRC  E,0
       MOV  XL,-(XS)         save selector
       ZER  WA               count to entry to shift
       ADD  *TPSI$,XL        point to 1st entry
NXNP1  BNZ  (XL),NXNP2       find lowest 1 entry
       ICA  XL
       ICV  WA               count
       BRN  NXNP1
*
NXNP2  ZER  WB               count # of 1s to replace
NXNP3  BZE  (XL),NXNP4       find first 1 to increment
       ICA  XL
       ICV  WA
       ICV  WB
       BRN  NXNP3
*
NXNP4  MOV  =NUM01,(XL)      shift the selector
       LCT  WA,WA
NXNP5  ZER  -(XL)            reset all preceeding entries to 0
       BCT  WA,NXNP5
       DCV  WB
NXNP6  BZE  WB,NXNP7         reset 1st entries to 1
       MOV  =NUM01,(XL)+
       DCV  WB
       BRN  NXNP6
*
NXNP7  MOV  (XS)+,XL         restore ptr to selector
       EXI
       ENP
       EJC
*
*      NXTVR -- point to next VRBLK
*
*      Called by B$PCC and OPRTN to point in turn to
*      the arguments and locals of a procedure, when
*      saving/restoring their values.
*
*      (XR)                  VRBLK pointer
*      JSR  NXTVR
*      (XR)                  updated past VRBLK
*      (WC)                  length of VRBLK in BAUs
*
NXTVR  PRC  E,0
       MOV  VRLEN(XR),WC
       ANB  PRCMX,WC         clear procno bits to get ch ct
       CTB  WC,VRCHS         this is the block length
       ADD  WC,XR            point past end
       EXI
       ENP
       EJC
*
*      PATCT -- Pattern construction for ANY,NOTANY,BREAK,
*               and SPAN PATTERN FUNCTIONS.
*
*      Similar to PATST in Spitbol.  This is a simplified version,
*      however, since the simpler string primitives in SETLS require
*      only the CTBLKs, not the pattern blocks.
*
*      (XR)                  ptr to pattern string
*      JSR  PATST            Call to update CTBLK
*      (XR)                  ptr to CTBLK
*      (XL,WA,WB,WC)         destroyed
*
*      Global locations used:
*      R$CTP                 ptr to current CTBLK
*      CTMSK                 mask indicating current pattern column
*
PATCT  PRC  E,0
       MOV  XR,-(XS)         SAVE STRING POINTER
       MOV  CTMSK,WC         LOAD CURRENT MASK BIT
       LSH  WC,1             SHIFT TO NEXT POSITION
       NZB  WC,PATC4         SKIP IF POSITION LEFT IN THIS TBL
*
*      HERE WE MUST ALLOCATE A NEW CHARACTER TABLE
*
       MOV  *CTSI$,WA        SET SIZE OF CTBLK
       ZER  XL               in case of gbcol
       JSR  ALLOC            ALLOCATE CTBLK
       MOV  XR,R$CTP         STORE PTR TO NEW CTBLK
       MOV  =B$CTT,(XR)+     STORE TYPE CODE, BUMP PTR
       LCT  WB,=CFP$A        SET NUMBER OF WORDS TO CLEAR
       MOV  BITS0,WC         LOAD ALL ZERO BITS
*
*      LOOP TO CLEAR ALL BITS IN TABLE TO ZEROS
*
PATC3  MOV  WC,(XR)+         MOVE WORD OF ZERO BITS
       BCT  WB,PATC3         LOOP TILL ALL CLEARED
       MOV  BITS1,WC         SET INITIAL BIT POSITION
*
*      MERGE HERE WITH BIT POSITION AVAILABLE
*
PATC4  MOV  WC,CTMSK         SAVE PARM2 (NEW BIT POSITION)
       MOV  (XS)+,XL         RESTORE POINTER TO ARGUMENT STRING
       MOV  SCLEN(XL),WB     LOAD STRING LENGTH
       BZE  WB,PATC6         JUMP IF NULL STRING CASE
       LCT  WB,WB            ELSE SET LOOP COUNTER
       PLC  XL               POINT TO CHARACTERS IN ARGUMENT
       EJC
*
*      PATST (CONTINUED)
*
*      LOOP TO SET BITS IN COLUMN OF TABLE
*
PATC5  LCH  WA,(XL)+         LOAD NEXT CHARACTER
       WTB  WA               CONVERT TO BYTE OFFSET
       MOV  R$CTP,XR         POINT TO CTBLK
       ADD  WA,XR            POINT TO CTBLK ENTRY
       MOV  WC,WA            COPY BIT MASK
       ORB  CTCHS(XR),WA     OR IN BITS ALREADY SET
       MOV  WA,CTCHS(XR)     STORE RESULTING BIT STRING
       BCT  WB,PATC5         LOOP TILL ALL BITS SET
*
*      COMPLETE PROCESSING FOR MUTI-CHAR STRING CASE
*
PATC6  MOV  R$CTP,XR         LOAD CTBLK PTR
       ZER  XL               CLEAR GARBAGE PTR IN XL
       EXI
       ENP                   END PROCEDURE PATCT
       EJC
*
.IF    .CNPF
.ELSE
*
*      PFPRH - print profile table header line
*
*      (XR) ptr to msg
*      JSR  PFPRH
*      (WA) destroyed
*
PFPRH  PRC  E,0
       LCT  WA,PFNCL         get nr times to duplicate
PFPH1  JSR  PRTST            print one copy
       BCT  WA,PFPH1         loop for nr required
       JSR  PRTNL            output complete line
       EXI                   and return
       ENP
       EJC
.FI
*
*      PRINT -- print a line
*
*      Called to write the contents of the print buffer
*      to appropriate channel -- listing file at compile
*      time, or currently selected output file.
*
*      (XR)                  pointer to line buffer
*      (WA)                  line length
*      JSR  PRINT
*      PPM  loc              output not possible
*      (WA,WB)                destroyed
*
PRINT  PRC  E,1
       BEQ  STAGE,=STGST,PRNT0 jump if in stopr
       BNE  STAGE,=STGIC,PRNT1 jump if not compile
*
*      For compiler, just a call to SYSPR
*
PRNT0  JSR  SYSPR
       PPM  PRNT3
       EXI
*
*      At execute-time, check whether there is a file for
*      output
*
PRNT1  BNZ  R$FOU,PRNT2      jump if file selected
*
*      Otherwise write it to the terminal
*
       JSR  SYSPI
       PPM  PRNT3
       EXI
*
*      Here to write line to a file
*      First trim trailing blanks
*
PRNT2  MOV  XL,-(XS)         save XL
       MOV  WC,-(XS)         and WC
       MOV  XR,XL            copy SCBLK ptr
       JSR  ALOCS            allocate another one
       MOV  WC,WA            recover ch count
       MOV  XR,WC            and save SCBLK pointer
       PLC  XL               load from old
       PSC  XR               store into new
       MVC                   copy characters
       MOV  WC,XR            point to SCBLK again
       MOV  R$FOU,XL         point to file descriptor
       MOV  IOFCB(XL),WA     point to FCBLK
       JSR  SYSOU
       PPM  PRNT4
       ERR  275,i/o error
       MOV  (XS)+,WC
       MOV  (XS)+,XL
       EXI
*
PRNT3  EXI  1
PRNT4  MOV  (XS)+,WC
       MOV  (XS)+,XL
       EXI  1
       ENP
       EJC
*
*      PRPAR -- process print parameters
*
*      JSR  PRPAR            call to process print parameters
*      (XL,XR,WA,WB,WC)      destroyed
*
PRPAR  PRC  E,0              Entry point
       JSR  SYSPP            Get print parameters
       BNZ  WB,PRPA1         Jump if lines/page specified
       MOV  =CFP$M,WB        Else use a large value
       RSH  WB,1             But not too large
*
*      Store line count/page
*
PRPA1  MOV  WB,LSTNP         Store number of lines/page
       MOV  WB,LSTLC         Pretend page is full initially
       ZER  LSTPG            Clear page number
       MOV  PRLEN,WB         Get prior length if any
       BZE  WB,PRPA2         Skip if no length
       BGT  WA,WB,PRPA3      Skip storing if too big
*
*      Store print buffer length
*
PRPA2  MOV  WA,PRLEN         Store value
*
*      Process bits options
*
PRPA3  MOV  BITS3,WB         Bit 3 mask
       ANB  WC,WB            Get listing bit
       ZRB  WB,PRPA4         Skip if clear
       ZER  LSTSW            Set switch for no listing
*
*      Check if fail reports goto interactive channel
*
PRPA4  MOV  BITS1,WB         Bit 1 mask
       ANB  WC,WB            Get bit
       MOV  WB,ERICH         Store int. Chan. Error flag
       MOV  BITS2,WB         Bit 2 mask
       ANB  WC,WB            Get bit
       MOV  WB,PRICH         Flag for std printer on int. Chan.
       MOV  BITS4,WB         Bit 4 mask
       ANB  WC,WB            Get bit
       MOV  WB,CPSTS         Flag for compile stats suppressn.
       MOV  BITS5,WB         Bit 5 mask
       ANB  WC,WB            Get bit
       MOV  WB,EXSTS         Flag for exec stats suppression
       EJC
*
*      PRPAR (continued)
*
       MOV  BITS6,WB         Bit 6 mask
       ANB  WC,WB            Get bit
       MOV  WB,PRECL         Extended/compact listing flag
       SUB  =NUM08,WA        Point 8 chars from line end
       ZRB  WB,PRPA5         Jump if not extended
       MOV  WA,LSTPO         Store for listing page headings
*
*       Continue option processing
*
PRPA5  MOV  BITS7,WB         Bit 7 mask
       ANB  WC,WB            Get bit 7
       MOV  WB,ININX         Set noexecute if non-zero
       MOV  BIT10,WB         Bit 10 mask
       ANB  WC,WB            Get bit 10
       MOV  WB,HEADP         Pretend printed to omit headers
       MOV  BITS9,WB         Bit 9 mask
       ANB  WC,WB            Get bit 9
       MOV  WB,PRSTO         Keep it as std listing option
       ZRB  WB,PRPA6         Skip if clear
       MOV  PRLEN,WA         Get print buffer length
       SUB  =NUM08,WA        Point 8 chars from line end
       MOV  WA,LSTPO         Store page offset
*
*      Check for terminal
*
PRPA6  ANB  BITS8,WC         See if terminal to be activated
       MOV  WC,INITR         Note request
       EXI                   Return
       ENP                   End procedure PRPAR
       EJC
*
*      PRTCH -- print a character
*
*      PRTCH is used to print a single character
*
*      (WA)                  character to be printed
*      JSR  PRTCH            call to print character
*
PRTCH  PRC  E,0              Entry point
       MOV  XR,-(XS)         Save XR
       BNE  PROFS,PRLEN,PRCH1 Jump if room in buffer
       JSR  PRTNL            Else print this line
*
*      Here after making sure we have room
*
PRCH1  MOV  PRBUF,XR         Point to print buffer
       PSC  XR,PROFS         Point to next character location
       SCH  WA,(XR)          Store new character
       CSC  XR               Complete store characters
       ICV  PROFS            Bump pointer
       MOV  (XS)+,XR         Restore entry XR
       EXI                   Return to PRTCH caller
       ENP                   End procedure PRTCH
       EJC
*
*      PRTIC -- print to interactive channel
*
*      PRTIC is called to print the contents of the standard
*      print buffer to the interactive channel. It is only
*      called after PRTST has set up the string for printing.
*      It does not clear the buffer.
*
*      JSR  PRTIC            call for print
*      (WA,WB)               destroyed
*
PRTIC  PRC  E,0              Entry point
       MOV  XR,-(XS)         Save XR
       MOV  PRBUF,XR         Point to buffer
       MOV  PROFS,WA         No of chars
       JSR  SYSPI            Print
       PPM  PRTC2            Fail return
*
*      Return
*
PRTC1  MOV  (XS)+,XR         Restore XR
       EXI                   Return
*
*      Error occured
*
PRTC2  ZER  ERICH            Prevent looping
       ERB  201,error on printing to interactive channel
       BRN  PRTC1            Return
       ENP                   Procedure PRTIC
       EJC
*
*      PRTIS -- print to interactive and standard printer
*
*      PRTIS puts a line from the print buffer onto the
*      interactive channel (if any) and the standard printer.
*      It always prints to the standard printer but does
*      not duplicate lines if the standard printer is
*      interactive.  It clears down the print buffer.
*
*      JSR  PRTIS            call for printing
*      (WA,WB)               destroyed
*
PRTIS  PRC  E,0              Entry point
       BNZ  PRICH,PRTS1      Jump if standard printer is int.Ch.
       BZE  ERICH,PRTS1      Skip if not doing int. Error reps.
       JSR  PRTIC            Print to interactive channel
*
*      Merge and exit
*
PRTS1  JSR  PRTNL            Print to standard printer
       EXI                   Return
       ENP                   End procedure PRTIS
       EJC
*
*      PRTIN -- print an integer
*
*      PRTIN prints the integer value which is in the integer
*      accumulator. Blocks built in dynamic storage
*      during this process are immediately deleted.
*
*      (IA)                  integer value to be printed
*      JSR  PRTIN            call to print integer
*      (IA,RA)               destroyed
*
PRTIN  PRC  E,0              Entry point
       MOV  XR,-(XS)         Save XR
       JSR  ICBLD            Build integer block
       BLO  XR,DNAMB,PRTI1   Jump if ICBLK below dynamic
       BHI  XR,DNAMP,PRTI1   Jump if above dynamic
       MOV  XR,DNAMP         Immediately delete it
*
*      Delete ICBLK from dynamic store
*
PRTI1  MOV  XR,-(XS)         Stack ptr for GTSTG
       JSR  GTSTG            Convert to string
       PPM                   Convert error is impossible
       MOV  XR,DNAMP         Reset pointer to delete SCBLK
       JSR  PRTST            Print integer string
       MOV  (XS)+,XR         Restore entry XR
       EXI                   Return to PRTIN caller
       ENP                   End procedure PRTIN
       EJC
*
*      PRTMI -- print message and integer
*
*      PRTMI is used to print messages together with an integer
*      value starting in column 15 (used by the routines at
*      the end of compilation).
*
*      JSR  PRTMI            call to print message and integer
*
PRTMI  PRC  E,0              Entry point
       JSR  PRTST            Print string message
       MOV  =PRTMF,PROFS     Set offset to col 15
       JSR  PRTIN            Print integer
       JSR  PRTNL            Print line
       EXI                   Return to PRTMI caller
       ENP                   End procedure PRTMI
       EJC
*
*      PRTMX  -- as PRTMI with extra copy to interactive chan.
*
*      JSR  PRTMX            call for printing
*      (WA,WB)               destroyed
*
PRTMX  PRC  E,0              Entry point
       JSR  PRTST            Print string message
       MOV  =PRTMF,PROFS     Set ptr to column 15
       JSR  PRTIN            Print integer
       JSR  PRTIS            Print line
       EXI                   Return
       ENP                   End procedure PRTMX
       EJC
*
*      PRTNL -- print new line (END print line)
*
*      PRTNL prints the contents of the print buffer, resets
*      the buffer to all blanks and resets the print pointer.
*
*      JSR  PRTNL            call to print line
*
PRTNL  PRC  R,0              Entry point
       BNZ  HEADP,PRNL0      Were headers printed
       JSR  PRTPS            No - print them
*
*      Call SYSPR
*
PRNL0  MOV  XR,-(XS)         Save entry XR
       MOV  WA,PRTSA         Save WA
       MOV  WB,PRTSB         Save WB
       MOV  PRBUF,XR         Load pointer to buffer
       MOV  PROFS,WA         Load number of chars in buffer
       JSR  PRINT            Call system print routine
       PPM  PRNL2            Jump if failed
       LCT  WA,PRLNW         Load length of buffer in words
       ADD  *SCHAR,XR        Point to chars of buffer
       MOV  NULLW,WB         Get word of blanks
*
*      Loop to blank buffer
*
PRNL1  MOV  WB,(XR)+         Store word of blanks, bump ptr
       BCT  WA,PRNL1         Loop till all blanked
*
*      Exit point
*
       MOV  PRTSB,WB         Restore WB
       MOV  PRTSA,WA         Restore WA
       MOV  (XS)+,XR         Restore entry XR
       ZER  PROFS            Reset print buffer pointer
       EXI                   Return to PRTNL caller
*
*      File full or no output file for load module
*
PRNL2  BNZ  PRTEF,PRNL3      Jump if not first time
       MNZ  PRTEF            Mark first occurrence
       ERB  202,print limit exceeded on standard output channel
*
*      Stop at once
*
PRNL3  MOV  =NINI8,WB        Ending code
       MOV  KVSTN,WA         Statement number
       JSR  SYSEJ            Stop
       ENP                   End procedure PRTNL
       EJC
*
*      PRTPG  -- print a page throw
*
*      Prints a page throw or a few blank lines on the standard
*      listing channel depending on the listing options chosen.
*
*      JSR  PRTPG            call for page eject
*
PRTPG  PRC  E,0              Entry point
       BEQ  STAGE,=STGXT,PRP01 Jump if execution time
       BZE  LSTLC,PRP06      Return if top of page already
       ZER  LSTLC            Clear line count
*
*      Check type of listing
*
PRP01  MOV  XR,-(XS)         Preserve XR
       BZE  HEADP,PRP04      JVK-no FF with headers for PC
       BNZ  PRSTD,PRP02      Eject if flag set
       BNZ  PRICH,PRP03      Jump if interactive listing channel
       BZE  PRECL,PRP03      Jump if compact listing
*
*      Perform an eject
*
PRP02  JSR  SYSEP            Eject
       BRN  PRP04            Merge
*
*      Compact or interactive channel listing. Cant print
*      blanks until check made for headers printed and flag set.
*
*
PRP03  MOV  HEADP,XR         Remember HEADP
       MNZ  HEADP            Set to avoid repeated PRTPG calls
       JSR  PRTNL            Print blank line
       JSR  PRTNL            Print blank line
       JSR  PRTNL            Print blank line
       MOV  =NUM03,LSTLC     Count blank lines
       MOV  XR,HEADP         Restore header flag
       EJC
*
*      Prptg (continued)
*
*      Print the heading
*
PRP04  BNZ  HEADP,PRP05      Jump if header listed
       MNZ  HEADP            Mark headers printed
       MOV  XL,-(XS)         Keep XL
       MOV  =HEADR,XR        Point to listing header
       JSR  PRTST            Place it
       JSR  SYSID            Get system identification
       JSR  PRTST            Append extra chars
       JSR  PRTNL            Print it
       MOV  XL,XR            Extra header line
       JSR  PRTST            Place it
       JSR  PRTNL            Print it
       JSR  PRTNL            Print a blank
       JSR  PRTNL            And another
       ADD  =NUM04,LSTLC     Four header lines printed
       MOV  (XS)+,XL         Restore XL
*
*      Merge if header not printed
*
PRP05  MOV  (XS)+,XR         Restore XR
*
*      Return
*
PRP06  EXI                   Return
       ENP                   End procedure PRTPG
       EJC
*
*      PRTPS - print page with test for standard listing option
*
*      If the standard listing option is selected, insist that
*      an eject be done
*
*      JSR  PRTPS            call for eject
*
PRTPS  PRC  E,0              Entry point
       MOV  PRSTO,PRSTD      Copy option flag
       JSR  PRTPG            Print page
       ZER  PRSTD            Clear flag
       EXI                   Return
       ENP                   End procedure PRTPS
       EJC
*
*      PRTST -- print string
*
*      PRTST places a string of characters in the print buffer
*
*      See PRTNL for global locations used
*
*      Note that the first word of the block (normally B$SCL)
*      is not used and need not be set correctly (see prtvn)
*
*      (XR)                  string to be printed
*      JSR  PRTST            call to print string
*      (PROFS)               updated past chars placed
*
PRTST  PRC  R,0              Entry point
       BNZ  HEADP,PRST0      Were headers printed
       JSR  PRTPS            No - print them
*
*      Call SYSPR
*
PRST0  MOV  WA,PRSVA         Save WA
       MOV  WB,PRSVB         Save WB
       ZER  WB               Set chars printed count to zero
*
*      Loop to print successive lines for long string
*
PRST1  MOV  SCLEN(XR),WA     Load string length
       SUB  WB,WA            Subtract count of chars already out
       BZE  WA,PRST4         Jump to exit if none left
       MOV  XL,-(XS)         Else stack entry XL
       MOV  XR,-(XS)         Save argument
       MOV  XR,XL            Copy for eventual move
       MOV  PRLEN,XR         Load print buffer length
       SUB  PROFS,XR         Get chars left in print buffer
       BNZ  XR,PRST2         Skip if room left on this line
       JSR  PRTNL            Else print this line
       MOV  PRLEN,XR         And set full width available
       EJC
*
*      PRTST (continued)
*
*      Here with chars to print and some room in buffer
*
PRST2  BLO  WA,XR,PRST3      Jump if room for rest of string
       MOV  XR,WA            Else set to fill line
*
*      Merge here with character count in WA
*
PRST3  MOV  PRBUF,XR         Point to print buffer
       PLC  XL,WB            Point to location in string
       PSC  XR,PROFS         Point to location in buffer
       ADD  WA,WB            Bump string chars count
       ADD  WA,PROFS         Bump buffer pointer
       MOV  WB,PRSVC         Preserve char counter
       MVC                   Move characters to buffer
       MOV  PRSVC,WB         Recover char counter
       MOV  (XS)+,XR         Restore argument pointer
       MOV  (XS)+,XL         Restore entry XL
       BRN  PRST1            Loop back to test for more
*
*      Here to exit after printing string
*
PRST4  MOV  PRSVB,WB         Restore entry WB
       MOV  PRSVA,WA         Restore entry WA
       EXI                   Return to PRTST caller
       ENP                   End procedure PRTST
       EJC
*
*      PRTTR -- print to terminal
*
*      Called to print contents of standard print buffer to
*      online terminal. Clears buffer down and resets PROFS.
*
*      JSR  PRTTR            call for print
*
PRTTR  PRC  E,0              Entry point
       MOV  XR,-(XS)         Save XR
       MOV  WA,PRTSA
       MOV  WB,PRTSB
       JSR  PRTIC            Print buffer contents
       MOV  PRBUF,XR         Point to print bfr to clear it
       LCT  WA,PRLNW         Get buffer length
       ADD  *SCHAR,XR        Point past SCBLK header
       MOV  NULLW,WB         Get blanks
*
*      Loop to clear buffer
*
PRTT1  MOV  WB,(XR)+         Clear a word
       BCT  WA,PRTT1         Loop
       MOV  PRTSA,WA
       MOV  PRTSB,WB
       ZER  PROFS            Reset PROFS
       MOV  (XS)+,XR         Restore XR
       EXI                   Return
       ENP                   End procedure PRTTR
.IF    .CNPF
.ELSE
*
*      PRTWD -- Print a program symbol in profile skeleton.
*
*      (XL) ptr to (pseudo-)SCBLK
*      JSR  PRTWD
*
PRTWD  PRC  E,0
       MOV  XR,-(XS)         preserve XR
       MOV  =STNPD,PROFS     Set up to ...
       MTI  CDGSN            ... print smt nr
       JSR  PRTIN
       MOV  =PFPDW,PROFS     Back to end of line
       MOV  XL,XR            copy WDBLK ptr
       JSR  PRTST            print it
       JSR  PRTNL            and newline
       MOV  (XS)+,XR         restore XR
       EXI
       ENP
       EJC
.FI
*
*      PRCMP -- compare two pairs for equality
*
*      On entry, both arguments are known to be PRBLKs.
*
*      (XL)                  left comparand
*      (XR)                  right comparand
*      JSR  PRCMP
*      PPM  loc              equal
*      PPM  loc              not equal
*
*      PRCMP may be called recursively by COMPV
*
PRCMP  PRC  R,2
       MOV  XL,-(XS)         save left
       MOV  PRDOM(XL),XL     load first element
       MOV  XR,-(XS)         save right
       MOV  PRDOM(XR),XR     load first element
       JSR  COMPV            jump to compare
       PPM  PRCM1            equal
       PPM  PRCX2            not equal - fail
*
*      Here if we need to compare ranges
*
PRCM1  MOV  (XS),XR          reload right
       MOV  PRRNG(XR),XR     load second element
       MOV  OFFS1(XS),XL         reload left
       MOV  PRRNG(XL),XL     load second element
       JSR  COMPV            jump to compare second elements
       PPM  PRCX1            succeed
       PPM  PRCX2            fail
       EJC
*
*      Here if both elements equal
*
PRCX1  MOV  (XS)+,XR
       MOV  (XS)+,XL
       EXI  1
*
*      Here if either differed
*
PRCX2  MOV  (XS)+,XR
       MOV  (XS)+,XL
       EXI  2
       ENP
       EJC
*
*      PRTUP -- convert a pair into a tuple
*
*      (XL)                  ptr to PRBLK
*      JSR PRTUP
*      (XR)                  ptr to TPBLK
*      (WA)                  destroyed
*
PRTUP  PRC  E,0
       MOV  XL,-(XS)         save PRBLK
       MOV  WB,-(XS)           and entry WB
       MOV  =NUM02,WA        load number of elements
       JSR  ALOTS            allocate TPBLK
       MOV  =B$TPL,(XR)      set its type field
       MOV  (XS)+,WB
       MOV  (XS)+,XL         get PRBLK
       MOV  PRDOM(XL),TPDOM(XR)
       MOV  PRRNG(XL),TPRNG(XR)
       EXI
       ENP
       EJC
*
.IF    .CNRA
.ELSE
       EJC
*
*      RCBLD -- build a real block
*
*      (RA)                  real value for RCBLK
*      JSR  RCBLD            call to build real block
*      (XR)                  pointer to result RCBLK
*      (WA)                  destroyed
*
RCBLD  PRC  E,0              Entry point
       MOV  DNAMP,XR         Load pointer to next available loc
       ADD  *RCSI$,XR        Point past new RCBLK
       BLO  XR,DNAME,RCBL1   Jump if there is room
       MOV  *RCSI$,WA        Else load RCBLK length
       JSR  ALLOC            Use standard allocator to get block
       ADD  WA,XR            Point past block to merge
*
*      Merge here with XR pointing past the block obtained
*
RCBL1  MOV  XR,DNAMP         Set new pointer
       SUB  *RCSI$,XR        Point back to start of block
       MOV  =B$RCL,(XR)      Store type word
       STR  RCVAL(XR)        Store real value in RCBLK
       EXI                   Return to RCBLD caller
       ENP                   End procedure RCBLD
.FI
       EJC
*
.IF    .CNRA
.ELSE
*
*      RCCMP -- compare real values
*
*      On entry, both operands are known to be reals
*      (XL)                  ptr to left RCBLK
*      (XR)                  ptr to right RCBLK
*      JSR  RCCMP
*      PPM  loc              left lt right
*      PPM  loc              left eq right
*      PPM  loc              left gt right
*
RCCMP  PRC  E,3
       LDR  RCVAL(XL)        load value of left
       SBR  RCVAL(XR)        subtract to compare
       ROV  RCCM3            jump with overflow
       RGT  RCCM1
       RLT  RCCM2
*
*
*      Fall through if equal
*
       EXI  2
RCCM1  EXI  3
RCCM2  EXI  1
*
*      Here if subtraction caused overflow
*
RCCM3  LDR  RCVAL(XR)        load right value
       RLT  RCCM1            greater than if negative
       BRN  RCCM2            else less than
       ENP
       EJC
.FI
*
*      READL -- read a line at execution time
*
*      Called via SCANX or SCANG from Setl-s READ function to get
*      a new line of input from the currently selected
*      input file/terminal
*
*      JSR  READL
*      PPM  loc              endfile
*      (XR)                  pointer to input record
*      (XL,WA,WB,WC)         destroyed
*
*      Global R$RDI is updated to point to (XR)
*
READL  PRC  E,1
       BNZ  R$FIN,RDL01      jump if file selected
       MOV  =RILEN,WA        terminal input buffer length
       JSR  ALOCS            allocate the buffer
       MOV  XR,DNAMP         temporarliy delete it
       JSR  SYSRI            read from terminal
       PPM  RDL02
       BRN  RDL03
*
*      Here if we have to read from a file
*
RDL01  MOV  R$FIN,XL         point to file descriptor
       MOV  IOFCB(XL),WA     point to FCBLK
       MOV  WA,WB            copy FCBLK ptr
       JSR  SYSIL            get image length
       JSR  ALOCS            allocate a buffer
       MOV  XR,DNAMP         reset dynamic pointer for a while
       MOV  WB,WA            recover FCBLK pointer
       JSR  SYSIN            read record
       PPM  RDL02            endfile
       ERR  276,i/o error
       ERR  280,record format error
RDL03  MOV  SCLEN(XR),WB
       CTB  WB,SCSI$               size of SCBLK
       ADD  WB,DNAMP         add it to dynamic
       MOV  XR,R$RDI
       EXI
*
*      Endfile return
*
RDL02  EXI  1
       ENP
       EJC
*
*      READR -- read source image at compile time
*
*      READR is used to read the next source image.
*      To permit lookahead, the compiler must read one
*      line ahead. Thus READR does not destroy the current image
*      see also the READS routine which actually gets the image.
*
*      JSR  READR            call to read next image
*      PPM  LOC              End of source file
*      (XR)                  ptr to next image
*      (R$CNI)               copy of pointer
*      (WA,WB,WC,XL)         destroyed
*
READR  PRC  E,1              Entry point
       MOV  R$CNI,XR         Get ptr to next image
       BNZ  XR,READ3         Exit if already read
       BGT  STAGE,=STGIC,READ3 Exit unless parse table /compile
READ0  MOV  =INILN,WA        Max read length
       ZER  XL               Clear any dud value
       JSR  ALOCS            Allocate buffer
       JSR  SYSRD            Read input image
       PPM  READ4            Jump if end of file
       MNZ  WB               Set TRIMR to perform trim
       JSR  TRIMR            Trim trailing blanks
       MOV  XR,R$CNI         Store copy of pointer
*
*      Merge here if no read attempted
*
READ3  EXI                   Return to READR caller
*
.IF    .CSFN
*
*      Here on end of file or new source name.  In case of
*      new source name, it is currently omitted and we proceed
*      to a new read.  For SETLS, syntax only permits ONE source,
*      since we otherwise can't recognize the end of source.
*
READ4  BZE  SCLEN(XR),READ5  Jump if true end of file
       MNZ  WB
       JSR  TRIMR            For now, just cut name string
       BNZ  RDEOF,READ5      Allow only one input file for SETLS
       MNZ  RDEOF            If open file, flag only one JVK
       BRN  READ0            Now reissue read for record data
*
*      Here on end of file
*
READ5  MOV  =NULLS,R$CNI
.ELSE
*      Here on end of file
*
READ4  MOV  =NULLS,R$CNI
.FI
       JSR  READS            Possibly list last line
*
*      Since SCANE will be re-entered at compile time after
*      the endfile condition has occurred once, we have to
*      clean up so that it will call a read first time in.
*
       ZER  SCNIL            Clear image length
       EXI  1                End source return
       ENP                   End procedure READR
       EJC
*
*      READS -- read source image into current line
*
*      READS is used to acquire the next source image at compile
*      time. It assumes that a prior call to READR has input
*      a line image (see procedure READR). Before the current
*      image is finally lost it may be listed here.
*
*      JSR  READS            call to acquire next input line
*      (XR,XL,WA,WB,WC)      destroyed
*
*      Global values affected
*
*      R$CNI                 on input, next image. On
*                            exit reset to zero
*
*      R$CIM                 on exit, set to point to image
*
*      SCNIL                 input image length on exit
*
*      SCNPT                 reset to zero
*
*      SCNSE                 reset to zero
*
*      LSTPF                 cleared on exit
*
READS  PRC  E,0              Entry point
       BZE  LSTSW,REDS1      Jump if nolist
       MOV  R$CIM,XR         Point to image
       BZE  XR,REDS1         Jump if no image
       JSR  LISTR            List line
*
*      Here after possible listing
*
REDS1  MOV  R$CNI,XR         Point to next image
       MOV  XR,R$CIM         Set as next image
       ZER  R$CNI            Clear next image pointer
       MOV  SCLEN(XR),SCNIL  Get input image length
       ZER  SCNPT            Reset SCNPT
       ZER  SCNSE            Reset SCNSE
       ZER  LSTPF            Set line not listed yet
       ICV  LSTNO            Bump listing line number
       MOV  CMPSN,LSTSN      Copy current stmt nr for LISTR
       EXI                   Return to READS caller
       ENP                   End procedure READS
       EJC
*
*      RPLIC -- replicate a string
*
*      (XR)                  ptr to SCBLK
*      (IA)                  replication count
*      JSR  RPLIC
*      (XR)                  ptr to result SCBLK
*      (WA, WB, WC, XL)      destroyed
*
RPLIC  PRC  E,0
       MFI  WB               copy count
       BZE  WB,REP11         jump if count zero
       MOV  XR,RPLXR         copy ptr
       MLI  SCLEN(XR)        calculate result length
       MFI  WA,REP20         copy that
       JSR  ALOCS            allocate result block
       MOV  XR,-(XS)         save it
       LCT  WB,WB            set up a loop counter
       PSC  XR               prepare to store chars into result
REP10  MOV  RPLXR,XL         recover initial SCBLK
       MOV  SCLEN(XL),WA     no of chars to move
       PLC  XL               prepare to fetch chars
       MVC                   move characters
       BCT  WB,REP10         loop if not done
       ZER  XL               clear out garbage
       MOV  (XS)+,XR         return new block
       EXI                   and return
*               zero reps, return null string
REP11  MOV  =NULLS,XR
       EXI
*
REP20  ERB  155,address overflow replicating a string
       ENP
       EJC
*
*      RPLTP -- replicate a tuple
*
*      (IA)                  replication count
*      (XR)                  ptr to TPBLK
*      JSR  RPLTP
*      (XR)                  prt to result TPBLK
*      (WA, WB, WC, XL)      destroyed
*
RPLTP  PRC  E,0
       MFI  WB
       BZE  WB,RPLT8         jump if mult by zero
       MOV  XR,-(XS)         save tuple
       MOV  WB,-(XS)           and replic count
       MLI  TPNEL(XR)        calculate result size
       MFI  WA,RPLT9         copy that
       JSR  ALOTS            get new block
       MOV  (XS)+,WB         recover replic count
       MOV  =B$TPL,(XR)        set type
       MOV  XR,-(XS)           and save
       MOV  =NUM01,WA        init indices
       MOV  WA,-(XS)           source index
       MOV  WA,-(XS)           and target index
       LCT  WB,WB            set up replic loop counter
RPLT1  MOV  OFFS3(XS),XR     get orig tuple
       MOV  WB,-(XS)         save counter
       JSR  TPELT            fetch an element
       PPM  RPLT2            exit loop when done
       JSR  COPYV            copy elt if needed
       MOV  XL,XR              and shift to XR
       MOV  OFFS1(XS),WA          get target index
       MOV  OFFS3(XS),XL     get new tuple
       JSR  ADTEL              and add new elt
       MOV  (XS)+,WB         recover loop counter
       ICV  (XS)             incr target index
       ICV  OFFS1(XS)          and source index
       MOV  OFFS1(XS),WA     reload source index
       BRN  RPLT1
RPLT2  MOV  (XS)+,WB         recover loop counter
       MOV  =NUM01,WA        init source index
       MOV  WA,OFFS1(XS)       and save
       BCT  WB,RPLT1         loop if more copies
       ICA  XS               discard indices
       ICA  XS
       MOV  (XS)+,XR         fetch result copy
       ICA  XS               discard orig tuple
       EXI
*
*      Here if zero copies
*
RPLT8  MOV  =NLTUP,XR        return null tuple
       EXI
*
RPLT9  ERB  154,address overflow replicating a tuple
       ENP
       EJC
*
*      SBSTR -- build a substring
*
*      (XL)                  ptr to SCBLK containing chars
*      (WA)                  number of chars in substring
*      (WB)                  offset to first char in SCBLK
*      JSR  SBSTR            call to build substring
*      (XR)                  ptr to new SCBLK with substring
*      (XL)                  zero
*      (WA,WB,WC,XL,IA)      destroyed
*
*      Note that SBSTR is called with a dummy string pointer
*      (pointing into a VRBLK or SVBLK) to copy the name of a
*      variable as a standard string value.
*
SBSTR  PRC  E,0              Entry point
       BZE  WA,SBST2         Jump if null substring
       MOV  XL,-(XS)
       JSR  ALOCS            Else allocate SCBLK
       MOV  WC,WA            Move number of characters
       MOV  XR,WC            Save ptr to new SCBLK
       MOV  (XS)+,XL
       PLC  XL,WB            Prepare to load chars from old BLK
       PSC  XR               Prepare to store chars in new BLK
       MVC                   Move characters to new string
       MOV  WC,XR            Then restore SCBLK pointer
*
*      Return point
*
SBST1  ZER  XL               Clear garbage pointer in XL
       EXI                   Return to SBSTR caller
*
*      Here for null substring
*
SBST2  MOV  =NULLS,XR        Set null string as result
       BRN  SBST1            Return
       ENP                   End procedure SBSTR
       EJC
*
*      SCANE -- scan an element
*
*      SCANE is called at compile time
*      to scan one element from the input image.
*
*      (WA,WB)               must be collectable (put on stack)
*      JSR  SCANE            call to scan element
*      (XR)                  result pointer (see below)
*      (XL)                  syntax type code (t$xxx)
*      (WC)                  destroyed
*
*      The following global locations are used.
*
*      R$CIM                 pointer to string block (SCBLK)
*                            for current input image.
*
*      R$CNI                 pointer to next input image string
*                            pointer (zero if none).
*
*      R$SCP                 save pointer (exit XR) from last
*                            call in case rescan is set.
*
*
*      R$SRP                  save pointer from previous
*                             reduction
*      SCNIL                 length of current input image
*
*      SCNPT                 offset to current loc in R$CIM
*
*      SCNRS                 if set non-zero on entry, SCANE
*                            returns the same result as on the
*                            last call (rescan). SCNRS is reset
*                            when a rescanned result is
*                            returned. SCANE may set SCNRS as a
*                            result of scanning ahead for a
*                            string break. The caller may not
*                            therefore request rescan of strings
*
*      SCNRT                  save nonterminal from a preceding
*                            reduction (set by B$RST)
*
*      SCNSE                 offset to start of element
*
*      SCNTP                 save syntax type from last
*                            call (in case rescan is set).
       EJC
*
*
*      If a lexical error is detected, SCANE clears the stack to
*      its entry level, then pushes a pointer to an error
*      routine.  The stack is then in the state expected by the
*      error recovery routines.
*
*      SCANE (continued)
*
*      Element scanned       XL        XR
*      ---------------       --        --
*
*      Operator              WOPxx     ptr to operator routine O$xxx
*      Assignment            T$ASG     ptr to O$ASS routine
*      Assign w operator     WOPAS     ptr to operator routine
*      Compound operator     WOPCM     ptr to operator routine
*      Keyword               WTxxx     WTxxx keyword number
*      Procedure name        T$FNA     ptr to PCBLK
*      Variable              T$VAR     ptr to VRBLK
*      String constant       T$STR     ptr to SCBLK
*      Integer constant      T$CON     ptr to ICBLK
.IF    .CNRA
.ELSE
*      Real constant         T$CON     ptr to RCBLK
*
.FI
*      System constants      T$RNM     ptr to TVBLK or SCBLK
*        (true,false,om)
*      System functions      T$RNM     F$xxx ptr to S$xxx routine
*      I/O functions         T$FNA     INPUT & OUTPUT, ptr to rout
*
*      Misc punctuation      T$xxx     T$xxx
*      Parse end marker      T$EOF     T$EOF
       EJC
*
*      SCANE (continued)
*
*      Entry point
*
SCANE  PRC  R,0              Entry point
       MOV  WA,-(XS)         Save WA
       MOV  WB,-(XS)         Save WB
*
       BZE  SCNRS,SCN02      Jump if no rescan
*
*      Here for rescan request
*
       MOV  SCNTP,XL         Set previous returned scan type
       MOV  R$SCP,XR         Set previous returned pointer
       ZER  SCNRS            Reset scan switch
       BRN  SCN17            Jump to exit
*
*      Come here to read new line image at end of current one
*
SCN01  JSR  READR            Read next image
       PPM  SCN03            End of source
       JSR  READS            Acquire the next image
*
*      Merge here to scan next element on current line
*
SCN02  MOV  SCNPT,WA         Load current offset
       BEQ  WA,SCNIL,SCN01   Jump if end
       MOV  R$CIM,XL         Point to current line
       PLC  XL,WA            Point to current character
       MOV  WA,SCNSE         Set start of element location
       MNZ  SCNCN            Clear constant flag
       MNZ  WB               Clear constant, name flag
       BRN  SCN05            Start scanning
       EJC
*
*      SCANE (continued)
*
*      End source return
*
SCN03  ZER  XR
       MOV  =T$EOF,XL        Else get special endfile marker
       BRN  SCN16            And exit with that
*
*      Loop here to ignore leading blanks and tabs
*
SCN04  BZE  WB,SCN13         Jump if trailing
       ICV  SCNSE            Increment start of element
       BEQ  WA,SCNIL,SCN01   Jump if end of image
*
*      The following jump is used repeatedly for scanning out
*      the characters of a numeric constant or variable name.
*      The registers are used as follows.
*
*      (XR)                  scratch
*      (XL)                  ptr to next character
*      (WA)                  current scan offset
*      (WB)                  0 if scanning name, constant
*      (WC)                  Lookahead char or CH$BL if end line
*      (SCNCN)               0 if scanning constant
*
SCN05  LCH  XR,(XL)+         Get next character
       MOV  XR,SCNCH         Preserve a copy of character
       ICV  WA               Bump scan offset
       MOV  WA,SCNPT         Store offset past char scanned
       MOV  =CH$BL,WC        Pseudo lookahead if image end
       BEQ  WA,SCNIL,SCN06   Jump if image end
       LCH  WC,(XL)          Get lookahead
*
*      Switch on character
*
SCN06  BSW  XR,CFP$A,SCN08   Switch on scanned character
*
*      Switch table for switch on character
*
       IFF  CH$BL,SCN04      Blank
.IF    .CAHT
       IFF  CH$HT,SCN04      Horizontal tab
.FI
       IFF  CH$D0,SCN11      Digit 0
       IFF  CH$D1,SCN11      Digit 1
       IFF  CH$D2,SCN11      Digit 2
       IFF  CH$D3,SCN11      Digit 3
       IFF  CH$D4,SCN11      Digit 4
       IFF  CH$D5,SCN11      Digit 5
       IFF  CH$D6,SCN11      Digit 6
       IFF  CH$D7,SCN11      Digit 7
       IFF  CH$D8,SCN11      Digit 8
       IFF  CH$D9,SCN11      Digit 9
       EJC
*
*      SCANE (continued)
*
       IFF  CH$LA,SCN12      Letter A
       IFF  CH$LB,SCN12      Letter B
       IFF  CH$LC,SCN12      Letter C
       IFF  CH$LD,SCN12      Letter D
       IFF  CH$LE,SCN12      Letter E
       IFF  CH$LF,SCN12      Letter F
       IFF  CH$LG,SCN12      Letter G
       IFF  CH$LH,SCN12      Letter H
       IFF  CH$LI,SCN12      Letter I
       IFF  CH$LJ,SCN12      Letter J
       IFF  CH$LK,SCN12      Letter K
       IFF  CH$LL,SCN12      Letter L
       IFF  CH$LM,SCN12      Letter M
       IFF  CH$LN,SCN12      Letter N
       IFF  CH$LO,SCN12      Letter O
       IFF  CH$LP,SCN12      Letter P
       IFF  CH$LQ,SCN12      Letter Q
       IFF  CH$LR,SCN12      Letter R
       IFF  CH$LS,SCN12      Letter S
       IFF  CH$LT,SCN12      Letter T
       IFF  CH$LU,SCN12      Letter U
       IFF  CH$LV,SCN12      Letter V
       IFF  CH$LW,SCN12      Letter W
       IFF  CH$LX,SCN12      Letter X
       IFF  CH$LY,SCN12      Letter Y
       IFF  CH$L$,SCN12      Letter Z
*
.IF    .CASL
       IFF  CH$$A,SCN10      Shifted A
       IFF  CH$$B,SCN10      Shifted B
       IFF  CH$$C,SCN10      Shifted C
       IFF  CH$$D,SCN10      Shifted D
       IFF  CH$$E,SCN10      Shifted E
       IFF  CH$$F,SCN10      Shifted F
       IFF  CH$$G,SCN10      Shifted G
       IFF  CH$$H,SCN10      Shifted H
       IFF  CH$$I,SCN10      Shifted I
       IFF  CH$$J,SCN10      Shifted J
       IFF  CH$$K,SCN10      Shifted K
       IFF  CH$$L,SCN10      Shifted L
       IFF  CH$$M,SCN10      Shifted M
       IFF  CH$$N,SCN10      Shifted N
       IFF  CH$$O,SCN10      Shifted O
       IFF  CH$$P,SCN10      Shifted P
       IFF  CH$$Q,SCN10      Shifted Q
       IFF  CH$$R,SCN10      Shifted R
       IFF  CH$$S,SCN10      Shifted S
       IFF  CH$$T,SCN10      Shifted T
       IFF  CH$$U,SCN10      Shifted U
       IFF  CH$$V,SCN10      Shifted V
       IFF  CH$$W,SCN10      Shifted W
       IFF  CH$$X,SCN10      Shifted X
       IFF  CH$$Y,SCN10      Shifted Y
       IFF  CH$$$,SCN10      Shifted Z
.ELSE
.FI
       EJC
*
*      SCANE (continued)
*
       IFF  CH$AS,SCN63      Asterisk
.IF    .CBSL
       IFF  CH$BS,SCN65      Backslash
.FI
       IFF  CH$CL,SCN55      Colon
       IFF  CH$CM,SCN47      Comma
       IFF  CH$DL,SCN56      Dollar
       IFF  CH$DT,SCN48      Dot
       IFF  CH$EQ,SCN67      Equals
       IFF  CH$MN,SCN68      Minus
       IFF  CH$NM,SCN70      Number sign
.IF    .CNOT
       IFF  CH$NT,SCN71      Not
.FI
       IFF  CH$OG,SCN72      Greater than
       IFF  CH$OL,SCN73      Less than
       IFF  CH$PL,SCN74      Plus
       IFF  CH$QU,SCN75      Question mark
       IFF  CH$SM,SCN46      Semi-colon
       IFF  CH$SL,SCN76      Slash
.IF    .CSST
       IFF  CH$ST,SCN44      Such that
.FI
       IFF  CH$SQ,SCN23      Single quote
       IFF  CH$UN,SCN07      Underline
       IFF  CH$OP,SCN35      Left paren
       IFF  CH$CP,SCN37      Right paren
.IF    .CSBR
       IFF  CH$CS,SCN41      Closing set bracket
       IFF  CH$OS,SCN39      Opening set bracket
.FI
.IF    .CTBR
       IFF  CH$CT,SCN43      Closing tuple brcket
       IFF  CH$OT,SCN36      Opening tuple brcket
.FI
       ESW                   End switch on character
*
*      Here for underline
*
SCN07  BZE  WB,SCN12         Part of name if scanning name
*
*      Here for illegal character (underline merges)
*
SCN08  BZE  WB,SCN13         Jump if scanning name or constant
SCN09  ADD  *NUM03,XS        clean up stack
       MOV  =O$ERR,(XS)      stack error ptr
       ERB  001,syntax error - illegal character
       EJC
*
*      SCANE (continued)
*
.IF    .CASL
*
*      Here for lower case letter. Convert to upper case and
*      store over the original.
*
SCN10  MOV  SCNCH,WB         Get the character
.IF    .CSLL
       ADD  =LCDIF,WB        Convert to upper case
.ELSE
       SUB  =LCDIF,WB        Convert to upper case
.FI
       MOV  R$CIM,XR         Point to image
       PSC  XR,SCNPT         Point after character
       SCH  WB,-(XR)         Replace character
       CSC  XR               Note completion of char storing
       BRN  SCN12            Merge to accept character
.FI
*
*      Here for digits 0-9
*
SCN11  BZE  WB,SCN12         Keep scanning if name/constant
       ZER  SCNCN            Else set flag for scanning constant
*
*      Merge with character accepted into name/constant
*
SCN12  BEQ  WA,SCNIL,SCN14   Jump if end of image
       ZER  WB               Set flag for scanning name/const
       BRN  SCN05            Merge back to continue scan
*
*      Come here for delimiter ending name or constant
*
SCN13  DCV  WA               Reset offset to point to delimiter
*
*      Come here after finishing scan of name or constant
*
SCN14  MOV  WA,SCNPT         Store updated scan offset
       MOV  SCNSE,WB         Point to start of element
       SUB  WB,WA            Get number of characters
       MOV  R$CIM,XL         Point to line image
       BNZ  SCNCN,SCN19      Jump if name
*
*      Here after scanning out numeric constant
*
       JSR  SBSTR            Get string for constant
       MOV  XR,DNAMP         Delete from storage (not needed)
       JSR  GTNUM            Convert to numeric
       PPM  SCN18            Jump if conversion failure
*
*      Merge here to exit with constant
*
SCN15  MOV  =T$CON,XL        Set result type of constant
*
*      Common exit point (XR,XL) set
*
SCN16  MOV  XR,R$SCP         Save XR in case rescan
       MOV  XL,SCNTP         Save XL in case rescan
       EJC
*
*      SCANE (continued)
*
*      Merge if SCANE has set rescan request
*
SCN17  MOV  (XS)+,WB         Restore WB
       MOV  (XS)+,WA         Restore WA
       EXI                   Return to SCANE caller
       EJC
*
*      SCANE (continued)
*
*      Here if conversion error on numeric item
*
SCN18  ADD  *NUM03,XS        clean up stack
       MOV  =O$ERR,(XS)      stack error ptr
       ERB  002,syntax error - invalid number
*
*      Here after scanning out variable name
*
SCN19  BLT  WA,=VRMXL,SCN1A  Jump if name length short enough
       MOV  =VRMXL,WA        Else truncate
*
*      Name length available - make name into a string
*
SCN1A  JSR  SBSTR            Get string name of variable
       ZER  WA               Search global and local tables
       JSR  SYMTS            Locate/build VRBLK
       BLE  XR,=WDYYY,SCN22  Skip if reserved word
.IF    .CASL
*
*      Convert non-reserved word to lower case for listing
*
       MOV  XR,R$SCP         Preserve block ptr
       MOV  R$CIM,XL         Pointer to current image
       MOV  XL,XR            Copy it
       MOV  SCNSE,WB         Offset to start of element
       PLC  XL,WB            ready to get chars
       PSC  XR,WB            ready to store them
       MOV  SCNPT,WA         Pointer past chars
       SUB  WB,WA            Number of chars in name
       LCT  WA,WA            Counter set up
       EJC
*
*      Loop to convert to lower case
*
SCN20  LCH  WB,(XL)+         Next char
       BEQ  WB,=CH$UN,SCN2B  Dont convert underline
       BLT  WB,=CH$D0,SCN2A  Also leave ...
       BLE  WB,=CH$D9,SCN2B  ... digits alone
.IF    .CSLL
SCN2A  SUB  =LCDIF,WB        Convert a char
.ELSE
SCN2A  ADD  =LCDIF,WB        Convert a char
.FI
SCN2B  SCH  WB,(XR)+         Store it
       BCT  WA,SCN20         Loop
       CSC  XR               Char storing is complete
       MOV  R$SCP,XR         Recover block ptr
.FI
*
*      Variable
*
       MOV  =T$VAR,XL        Set type as variable
       BNE  (XR),=B$VRL,SCN21 must be PVBLK
       BZE  SCNUD,SCN16      Skip if not user-defined
       BRN  SCN62            invalid - no user defined oper support
*      ZER  SCNUD            Clear flag
*      MOV  =T$UOP,XL        Set type as user-defined
*      BRN  SCN16            Back to exit
*
*      Reserved word
*
SCN22  BNE  (XR),=WD$OP,SCN21 Jump if not operator
       MOV  WDPR1(XR),XL     Get class
       MOV  WDPR2(XR),XR     Get operator routine address
       BEQ  SCNPT,SCNIL,SCN16 Jump if image end
       MOV  XL,WB            Copy class
       MOV  R$CIM,XL         Point to current image
       PLC  XL,SCNPT         Set up character pointer again
       LCH  WC,(XL)          Get lookahead char
       MOV  SCNPT,WA         Restore scan offset
       BEQ  WB,=WOP04,SCN60  If unary op, jump.  NOT
       BEQ  WB,=WOP10,SCN60    unary op
       BEQ  WB,=WOP11,SCN60    from
       BRN  SCN58            If binary, check compound operator
       EJC
*
*      SCANE (continued)
*
*      Keyword
*
SCN21  MOV  WDPR1(XR),XL     Return code
       MOV  WDPR2(XR),XR     and /value/
       BRN  SCN16            Return
*
*      Here for single quote (start of string constant)
*
SCN23  BZE  WB,SCN13         Terminator if scanning name or cnst
*
*      Loop to scan out string constant
*
SCN24  BEQ  WA,SCNIL,SCN25   Jump if end of image
       LCH  WC,(XL)+         Else load next character
       ICV  WA               Bump offset
       BNE  WC,=CH$SQ,SCN24  Loop back if not terminator
       ZER  SCNNC            In case string break or quoted quot
       BEQ  WA,SCNIL,SCN27   Jump if image end
       LCH  WC,(XL)          Get next char
       BNE  WC,=CH$SQ,SCN26  Skip if not quote
       ZER  WC               Note quoted quote
       BNE  WA,SCNIL,SCN27   Ok if not image end
*
*      No closing quote found
*
SCN25  MOV  WA,SCNPT         Update to image end
       ADD  *NUM03,XS        clean up stack
       MOV  =O$ERR,(XS)      stack error ptr
       ERB  003,syntax error - unmatched string quote
*
*      String followed by non-string
*
SCN26  MNZ  SCNNC            Concatenation not required
       EJC
*
*      SCANE (continued)
*
*      Here after scanning out string constant
*
SCN27  MOV  SCNPT,WB         Point to first character
       MOV  WA,SCNPT         Save offset past final quote
       BZE  WC,SCN28         Skip if quoted quote
       DCV  WA               Point back past last character
*
*      Extract string
*
SCN28  SUB  WB,WA            Get number of characters
       MOV  R$CIM,XL         Point to input image
       JSR  SBSTR            Build substring value
       BNZ  SCNNC,SCN30      Return string if no concatenation
       MOV  XR,-(XS)         Stack string
       JSR  SCANE            Scan next element
       BNE  XL,=T$STR,SCN29  Jump if non-string
       BNE  (XR),=B$SCL,SCN29 Jump if not a string
       MOV  (XS)+,XL         Get left substring
       JSR  SCONC            Concatenate strings
       BRN  SCN30            Return string result
*
*      Element following string scanned. Set up for rescan,
*      remembering that SCANE call will have set SCNTP, R$SCP
*
SCN29  MNZ  SCNRS            Set rescan flag
       MOV  (XS)+,XR         Recover string ptr
*
*      Do not return via regular exit for strings to avoid
*      trampling over rescan of next element.
*
SCN30  MOV  =T$STR,XL        Returning a string
       BRN  SCN17            Back to exit with constant result
*
*      Update scan ptr after multi-character token
*
SCN31  ICV  WA               Bump pointer
*
*      Here after a possible multi character special token.
*
SCN32  MOV  WA,SCNPT         Bump pointer past end of token
*
*      Merge here for special character exit
*
SCN33  BZE  WB,SCN13         Jump if end of name/constant
*
*      Prepare for exit
*
SCN34  MOV  XR,XL            Copy code
       BRN  SCN16            And jump to exit
       EJC
*
*      SCANE (continued)
*
*      Processing for special characters
*
SCN35  MOV  =T$LPR,XR        Set left paren return code
       BNE  WC,=CH$SL,SCN33  Exit if not slash
       BZE  WB,SCN13         Jump if name or constant delim
       ICV  WA               Bump past slash and drop through
*
SCN36  MOV  =T$LTB,XR        Left tuple bracket, set code
       BRN  SCN32            Take special character exit
*
SCN37  MOV  =T$RPR,XR        Right paren, set code
       BRN  SCN33            Take special character exit
*
SCN38  ICV  WA               Bump past /less than/
SCN39  MOV  =T$LSB,XR        Left set bracket, set code
       BRN  SCN32            Take special character exit
*
SCN40  ICV  WA               Bump past /greater than/
SCN41  MOV  =T$RSB,XR        Right set bracket, set code
       BRN  SCN32            Take special character exit
*
SCN42  ICV  WA               Bump past right paren
SCN43  MOV  =T$RTB,XR        Right tuple bracket, set code
       BRN  SCN32            Take special character exit
*
SCN44  MOV  =WT$ST,XR        Such that
       BRN  SCN33            Take special character exit
*
SCN46  MOV  =T$SMC,XR        Semi-colon, set code
       BRN  SCN33            Take special character exit
*
SCN47  MOV  =T$CMA,XR        Comma, set code
       BRN  SCN33            Take special character exit
       EJC
*
*      SCANE (continued)
*
*      Dot
*
SCN48  BZE  SCNCN,SCN51      Jump if scanning constant
       BZE  WB,SCN13         Jump if delimiter for name
       BEQ  WC,=CH$DT,SCN52  Skip if followed by dot
       BRN  SCN54            fail
*
*      Scanning a constant. Test if dot starts iterator or
*      is part of real constant.
*
SCN51  BNE  WC,=CH$DT,SCN12  Jump if no more dots
       BRN  SCN13            Iterator terminates constant
*
*      Iterator consisting of several dots
*
SCN52  MOV  =T$ITR,XR        Ready for return
*
*      Loop to eat dots
*
SCN53  ICV  WA               Bump past dot
       BEQ  WA,SCNIL,SCN32   Done if line end
       LCH  WC,(XL)+         Absorb dot
       LCH  WC,(XL)          Get lookahead
       BEQ  WC,=CH$DT,SCN53  Loop if dot again
       BRN  SCN32            Jump when finished
*
SCN54  MOV  =O$ERR,-(XS)     stack error value for recovery
       ERB  004,syntax error - misplaced dot
*
*      Colon
*
SCN55  BZE  WB,SCN13         Jump if acting as delimiter
       BEQ  WC,=CH$EQ,SCN66  Jump if followed by equals
       MOV  =T$COL,XR        Colon token
       BRN  SCN33            Take special character exit
       EJC
*
*      SCANE (continued)
*
*      Dollar - comment symbol
*
SCN56  BZE  WB,SCN13         Jump if name, constant delim
       BRN  SCN01            Now get next line
*
*      Merge for multi-char operators to advance pointer over
*      second character.
*
SCN57  ICV  WA               Advance pointer
       BEQ  WA,SCNIL,SCN60   Skip if end image
       LCH  WC,(XL)+         Absorb second char
       LCH  WC,(XL)          Get lookahead char
*
*      Merge here for all operators to check next char
*
SCN58  BNE  WC,=CH$CL,SCN61  Skip if not bop :=
       ICV  WA               Bump past colon
       BEQ  WA,SCNIL,SCN62   Fail if end line
       LCH  WC,(XL)+         Absorb colon
       LCH  WC,(XL)          Get lookahead
       BNE  WC,=CH$EQ,SCN62  Fail unless equals
       MOV  =WOPAS,WB        Token type - assigning opr
*
*      Scan past lookahead
*
SCN59  ICV  WA               Bump pointer
*
*      Store updated scan pointer
*
SCN60  MOV  WA,SCNPT         Store it
       MOV  WB,XL            Place syntax type
       BRN  SCN16            Exit
*
*      Compound oper bop slash
*
SCN61  BNE  WC,=CH$SL,SCN60  jump if operator not compound
       ICV  WA               bump past slash
       LCH  WC,(XL)+         absorb slash
       LCH  WC,(XL)
       MOV  WA,SCNPT         store scan ptr
       MOV  =WOPCM,XL        return compound oper type
       BRN  SCN16
*
*      Invalid compound assignment operator
*
SCN62  ADD  *NUM03,XS        clean up stack
       MOV  =O$ERR,(XS)      stack error ptr
       ERB  005,syntax error - invalid operator
       EJC
*
*      SCANE (continued)
*
*      Operators
*
*      Asterisk
*
SCN63  BZE  WB,SCN13         Jump if acting as delimiter
       BEQ  WC,=CH$AS,SCN64  Jump if **
       MOV  =WOP08,WB        Priority class
       MOV  =O$MUL,XR        Multiply routine
       BRN  SCN58            Exit
*
*      Exponentiate
*
SCN64  MOV  =WOP09,WB        Priority class
       MOV  =O$EXP,XR        Exponentiate routine
       BRN  SCN57            Exit
*
.IF    .CBSL
*
*      Backslash
*
SCN65  BZE  WB,SCN13         Jump if acting as delimiter
       BNE  WC,=CH$SL,SCN62  Fail if not followed by slash
       MOV  =WOP02,WB        Priority class
       MOV  =O$IOR,XR        Inclusive OR routine
       BRN  SCN57            Exit
.FI
*
*      Assignment operator
*
SCN66  MOV  =T$ASG,WB        Priority class
       MOV  =O$ASS,XR        Assignment routine
       BRN  SCN59            Exit
*
*      Equals
*
SCN67  BZE  WB,SCN13         Jump if acting as a delimiter
       MOV  =WOPEQ,WB        Priority class
       MOV  =O$EQL,XR        Equals routine
       BRN  SCN58            Exit
       EJC
*
*      SCANE (continued)
*
*      Minus
*
SCN68  BZE  WB,SCN13         Jump if acting as delimiter
       BEQ  WC,=CH$OG,SCN69  Jump if greater than
       BZE  SCNCN,SCN12      Minus can be part of constant
       MOV  =WOPMN,WB        Priority class
       MOV  =O$MNS,XR        Minus routine
       BRN  SCN58            Exit
*
*      Implies
*
SCN69  MOV  =WOP01,WB        Priority class
       MOV  =O$IMP,XR        Implies routine
       BRN  SCN57            Exit
*
*      Number sign
*
SCN70  BZE  WB,SCN13         Jump if acting as delimiter
       MOV  =WOP10,WB        Priority class
       MOV  =O$NUM,XR        Number routine
       BRN  SCN60            Exit unary
*
*      Not sign
*
SCN71  BZE  WB,SCN13         Jump if acting as delimiter
       MOV  =WOP04,WB        Priority class
       MOV  =O$NOT,XR        Not routine
       BRN  SCN60            Exit unary
*
*      Greater than
*
SCN72  BZE  WB,SCN13         Jump if acting as delimiter
       BEQ  WC,=CH$OG,SCN40  Jump if closing set bracket
       MOV  =WOP05,WB        Priority class
       MOV  =O$OGT,XR        Greater than routine
       BNE  WC,=CH$EQ,SCN58  Jump if greater than
*
*      Greater than or equals
*
       MOV  =O$OGE,XR        Greater than or equals routine
       BRN  SCN57            Exit
*
*      Less than
*
SCN73  BZE  WB,SCN13         Jump if acting as delimiter
       BEQ  WC,=CH$OL,SCN38  Jump if opening set bracket
       MOV  =WOP05,WB        Priority class
       MOV  =O$OLT,XR        Less than routine
       BNE  WC,=CH$EQ,SCN58  Jump if less than
*
*      Less or equal
*
       MOV  =O$OLE,XR        Less or equal routine
       BRN  SCN57            Exit
       EJC
*
*      SCANE (continued)
*
*      Plus
*
SCN74  BZE  WB,SCN13         Jump if acting as delimiter
       MOV  =WOPLS,WB        Priority class
       MOV  =O$PLS,XR        Plus routine
       BRN  SCN58            Exit
*
*      Question mark
*
SCN75  BZE  WB,SCN13         Jump if acting as delimiter
       MOV  =WOP09,WB        Priority class
       MOV  =O$QMK,XR        Quest mark routine
       BRN  SCN58            Exit binary
*
*      Slash
*
SCN76  BZE  WB,SCN13         Jump if acting as terminator
       BEQ  WC,=CH$CP,SCN42  Jump if right tuple bracket
.IF    .CBSL
       BNE  WC,=CH$BS,SCN77  Jump if not followed by slash
       MOV  =WOP03,WB        Priority class
       MOV  =O$AND,XR        And routine
       BRN  SCN57            Exit
*
*      Try for not equal
*
SCN77  BEQ  WC,=CH$EQ,SCN78  Jump for not equal
.ELSE
       BEQ  WC,=CH$EQ,SCN78  Jump for not equal
.FI
       MOV  =WOP08,WB        Priority class
       MOV  =O$DIV,XR        Divide routine
       BRN  SCN58            Exit
*
*      Not equal
*
SCN78  MOV  =WOP05,WB        Priority class
       MOV  =O$NEQ,XR        Not equal routine
       BRN  SCN57            Exit
       EJC
       ENP
       EJC
*
*      SCANG -- scan line for GET at execution time
*
*      Reads the next line from the file at R$FIN
*
*      JSR  SCANG             call to fetch line
*      (XR)                   value
*      (XL,WA,WB,WC)          destroyed by READL
*
SCANG  PRC  E,0
       JSR  READL             read a new line
       PPM  SCNG3             jump at eof
       ZER  WB                set trim indicator
       JSR  TRIMR             trim record & reset dnamp
       BRN  SCNG6             result in XR
*
*      Here if eof
*
SCNG3  MNZ  EOFLG
       MOV  R$FIN,XR          get ioblk
       BZE  XR,SCNG4          skip if term input
       MOV  EOFLG,IOEOF(XR)   set file eof marker
SCNG4  MOV  =OMEGA,XR
*
*      Merge cases
*
SCNG6  MOV  =NULLS,R$RDI      clear input marker
       ZER  SCXCP               and offset
       ZER  SCXIL
       EXI
       ENP
       EJC
*
*      SCANX -- scan element at execution time
*
*      Reads the next item from the standard input channel
*      which is taken to be the interactive terminal.
*
*      JSR  SCANX             call to fetch element
*      (XR)                  value
*      (XL,WA,WB)             destroyed
*
*      On end file OMs are returned - there is some doubt as
*      to whether the endfil handling is clean.
*
SCANX  PRC  E,0
SCX01  MOV  SCXCP,WA         load offset
SCX02  BGE  WA,SCXIL,SCX03   jump if end of line
       MOV  R$RDI,XL         point to current line
       PLC  XL,WA            prepare pointer to next character
       MOV  WA,SCXSE         remember start of element
       BRN  SCX06
*
*      Here if a new line has to be read
*
SCX03  JSR  READL            read a new line
       PPM  SCX33            jump at eof
       ZER  WB               set trim indicator
       JSR  TRIMR            trim record-reset dnamp
       ZER  WA               clear offset
       ZER  SCXCP
       MOV  SCLEN(XR),SCXIL  record length we got
       BRN  SCX02            jump back to get character
       EJC
*
*      Here to look at successive characters
*
SCX05  BGE  WA,SCXIL,SCX03   get another line if needs be
       MOV  WA,SCXSE         this will be start of an element
SCX06  LCH  XR,(XL)+         get next char
       ICV  WA               and increment offset
*
*      Perform a series of tests on the character
*
       BLT  XR,=CH$D0,SCX07  jump if not digit
       BLE  XR,=CH$D9,SCX10  jump with digit
SCX07  BEQ  XR,=CH$MN,SCX10  or minus
       BEQ  XR,=CH$PL,SCX10  or plus sign
*
*      Cannot be a number - try for a name-like string
*
.IF    .CASL
       BLT  XR,=CH$$A,SCX08  jump if under range
       BLE  XR,=CH$$$,SCX22  jump with a letter
.FI
*      Try the u/c letters
SCX08  BLT  XR,=CH$LA,SCX09
       BLE  XR,=CH$L$,SCX22  jump with one
*
*      Try for specials
*
SCX09  BEQ  XR,=CH$BL,SCX05  ignore loose spaces
.IF    .CAHT
       BEQ  XR,=CH$HT,SCX05  and tabs
.FI
       BEQ  XR,=CH$AS,SCX12  asterisk
       BEQ  XR,=CH$NM,SCX13  number sign
       BEQ  XR,=CH$SQ,SCX26  single quote
*
*      This procedure doesnt know about the alternative set
*      and tuple brackets
*
.IF    .CSBR
       BEQ  XR,=CH$CS,SCX20  right set bracket
       BEQ  XR,=CH$OS,SCX17  left set bracket
.FI
.IF    .CTBR
       BEQ  XR,=CH$CT,SCX21
       BEQ  XR,=CH$OT,SCX18
.FI
*
*      Chance of a comma inside set or tuple
*
       BNZ  SCXTC,SCX1A
       BZE  SCXSC,SCX1B      error if neither
SCX1A  BEQ  XR,=CH$CM,SCX05  loop
*
*      Sorry chaps
*
SCX1B  ERB  030,illegal character in input
       EJC
*
*      Here to deal with numbers
*
SCX10  BEQ  WA,SCXIL,SCX1C   done if line end
       LCH  XR,(XL)+         load next character
       ICV  WA               and update offset
       BEQ  XR,=CH$DT,SCX10  loop with dot
       BEQ  XR,=CH$LE,SCX10  or E (maybe part of real)
.IF    .CASL
       BEQ  XR,=CH$$E,SCX10  or even e
.FI
       BLT  XR,=CH$D0,SCX11  done if not a digit
       BLE  XR,=CH$D9,SCX10  but loop if a digit
*
*      Here we ve got to the end of a number
*
SCX11  DCV  WA               forget terminator
SCX1C  MOV  WA,SCXCP         store new offset
       MOV  SCXSE,WB         get offset to start
       SUB  WB,WA            get length
       MOV  R$RDI,XL         point to string
       JSR  SBSTR            extract substring
       JSR  GTNUM            and get a number from it
       ERR  031,ill formed number in input
       BRN  SCX38
       EJC
*
*      Here with * - means OM
*
SCX12  MOV  =OMEGA,XR        load for return
       BRN  SCX36
*
*      Number sign should be true or false
*
SCX13  BEQ  WA,SCXIL,SCX14   jump if end of line
       LCH  XR,(XL)+         get next char
       ICV  WA
       BEQ  XR,=CH$LF,SCX16  false
       BEQ  XR,=CH$LT,SCX15  true
.IF    .CASL
       BEQ  XR,=CH$$F,SCX16
       BEQ  XR,=CH$$T,SCX15
.FI
SCX14  ERB  032,incorrect bollean item on input
*
SCX15  MOV  =TRUE$,XR
       BRN  SCX36
SCX16  MOV  =FALSE,XR
       BRN  SCX36
       EJC
*
*      Left set bracket
*
SCX17  ICV  SCXSC            count it
       BRN  SCX19            merge with tuples
*
*      Left tuple bracket
*
SCX18  ICV  SCXTC            count it
SCX19  MOV  SCXEC,-(XS)      stack element count
       ZER  SCXEC            and clear it
       BRN  SCX05            loop
*
*      Right set bracket
*
SCX20  MOV  WA,SCXCP         update pointer
       MOV  SCXEC,WA         get element count
       JSR  FMSET            form a set
       MOV  SCXCP,WA         recover offset
       MOV  (XS)+,SCXEC      pop enclosing count
       DCV  SCXSC            uncount bracket
       BRN  SCX38
*
*      Right tuple bracket
*
SCX21  MOV  WA,SCXCP         save pointer
*
*      Unfortunately, the tuple elements have been stacked in
*      the wrong order for FMTPL, so they must be reversed
*
       MOV  SCXEC,WA         get number of elements
       BNZ  WA,SCX2F         check if 0 elts
       MOV  =NLTUP,XR        if so return null tuple
       ZER  XL
       BRN  SCX2G
SCX2F  ZER  XL
       JSR  ALLOC            grab some scratch space
       MOV  XR,DNAMP         immediately delete from dynamic
       LCT  WA,SCXEC         prepare to count elements
SCX2B  MOV  (XS)+,(XR)+      copy a value
       BCT  WA,SCX2B         loop for more
*
*      Now move them all back
*
       MOV  DNAMP,XR         point to start of scratch
       LCT  WA,SCXEC
SCX2C  MOV  (XR)+,-(XS)      restack a value
       BCT  WA,SCX2C
*
*      Now they can be put into a TPBLK
*
       MOV  SCXEC,WA         get element count
       JSR  FMTPL            make the tuple
SCX2G  MOV  SCXCP,WA         recover offset
       MOV  (XS)+,SCXEC      pop enclosing count
       DCV  SCXTC            count
       BRN  SCX38
       EJC
*
*      Here with non-quoted string
*
SCX22  BEQ  WA,SCXIL,SCX2A   end if end of line
       LCH  XR,(XL)+         get next
       ICV  WA
       BEQ  XR,=CH$UN,SCX22  loop with underline
*
*      Check for letters and digits - loop with them
*
.IF    .CASL
       BLT  XR,=CH$$A,SCX23
       BLE  XR,=CH$$$,SCX22
.FI
SCX23  BLT  XR,=CH$LA,SCX24
       BLE  XR,=CH$L$,SCX22
SCX24  BLT  XR,=CH$D0,SCX25
       BLE  XR,=CH$D9,SCX22
*
*      Here at end
*
SCX25  DCV  WA               terminator not included
SCX2A  MOV  WA,SCXCP
       MOV  SCXSE,WB         get starting offset
       SUB  WB,WA            compute string length
       MOV  R$RDI,XL         point to whole string
       JSR  SBSTR            extract substring
       BRN  SCX38
*
*      Here with single quote
*
SCX26  ICV  SCXSE            string starts with next char
SCX27  BEQ  WA,SCXIL,SCX29   jump at line end
       LCH  XR,(XL)+
       ICV  WA
       BEQ  XR,=CH$SQ,SCX2D  jump if a quote
       BRN  SCX27            or loop
*
*      Check if doubled quote or end quote
*
SCX2D  BEQ  WA,SCXIL,SCX28   end quote if last char on line
       LCH  XR,(XL)          check next char
       BNE  XR,=CH$SQ,SCX28  jump if not dbl quote
       MOV  SCXSE,WB         get start
       MOV  WA,SCXCP
       ICV  SCXCP            drop 2nd quote for next scan
       SUB  WB,WA            get length thru 1st quote
       MOV  R$RDI,XL
       JSR  SBSTR            pull out init string
       MOV  R$RDS,XL         check if prior partial string
       BZE  XL,SCX2E         jump if not
       JSR  SCONC            if so, concatenate
SCX2E  MOV  XR,R$RDS         preserve partial string
       MOV  SCXCP,WA         reset start of next part
       MOV  WA,SCXSE
       MOV  R$RDI,XL         recover input line
       PLC  XL,WA
       BRN  SCX27            back to loop
*
*      Here if end quote
*
SCX28  MOV  SCXSE,WB
       MOV  WA,SCXCP
       DCV  WA               lose closing quote
       SUB  WB,WA            gives length
       MOV  R$RDI,XL
       JSR  SBSTR
       BZE  R$RDS,SCX38      done if it was all on this line
       MOV  R$RDS,XL         else get stuff so fa
       JSR  SCONC            stick together
       BRN  SCX38
       EJC
*
*      Here with newline inside a quoted string
*
SCX29  BNZ  SCXSE,SCX32      jump if not whole line
       MOV  R$RDI,XR         point to this line
SCX30  MOV  R$RDS,XL         point to partial string
       BZE  XL,SCX31         jump if none before
       JSR  SCONC
SCX31  MOV  XR,R$RDS         preserve partial string
       JSR  READL
       ERR  033,eof encountered inside string
       ZER  WA               clear initial offset
       ZER  SCXSE            fudge start offset
       MOV  SCLEN(XR),SCXIL  record image length
       MOV  XR,XL            copy buffer pointer
       PLC  XL               prepare character pointer
       BRN  SCX27            back to loop
*
*      Here to extract an initial substring before a newline
*
SCX32  MOV  SCXSE,WB         starting offset
       SUB  WB,WA            compute length
       MOV  R$RDI,XL         point to start of string
       JSR  SBSTR            pull out substring
       BRN  SCX30            merge to get next line
*
*      Here on endfile - make sure it is not inside a set
*      or tuple and return OM
*
SCX33  BNZ  SCXTC,SCX34
       BZE  SCXSC,SCX35
SCX34  ERB  034,eof encountered inside set or tuple
SCX35  MNZ  EOFLG
       MOV  R$FIN,XR         get ioblk
       BZE  XR,SCX3A         skip if term input
       MOV  EOFLG,IOEOF(XR)  set eof marker on file
SCX3A  MOV  =OMEGA,XR
       MOV  =NULLS,R$RDI
       ZER  SCXSE
       ZER  SCXIL
       ZER  XL
       EXI
       EJC
*
*      Here with an individual item in XR -- if inside a set
*      or tuple, stack and count it, otherwise return it
*
*      First - element whose extraction has left the character
*      pointer in (XL) ok, but SCXCP is not updated.
*
SCX36  MOV  WA,SCXCP         preserve offset
       BNZ  SCXTC,SCX37      jump iside a tuple
       BZE  SCXSC,SCX40      not in a set
*
*      Here its one element of a set or tuple
*
SCX37  MOV  XR,-(XS)         stack this element
       ICV  SCXEC            count it
       BRN  SCX05            look for more
*
*      Here for those case which have destroyed the character
*      pointer.
*
SCX38  BNZ  SCXTC,SCX39
       BZE  SCXSC,SCX40
SCX39  MOV  XR,-(XS)         stack the element
       ICV  SCXEC
       BRN  SCX01            look for more
*
*      here to return one element
*
SCX40  ZER  XL               clean up character pointer
       ZER  R$RDS            and clear string workspace
       EXI
       ENP
       EJC
*
*      SCONC -- string concatenate
*
*      SCONC is used to concatenate a pair of arguments known
*      already to be strings.
*
*      (XL)                  left string arg
*      (XR)                  right string arg
*      JSR  SCONC            call to do string concatenation
*      (XR)                  result string
*      (XL,WA)            destroyed
*
SCONC  PRC  E,0              Entry point
       MOV  SCLEN(XL),WA     Load left argument length
       BZE  WA,SCON1         Skip if null left arg
       BZE  SCLEN(XR),SCON2  Skip if null right arg
       ADD  SCLEN(XR),WA     Compute result length
       MOV  XR,-(XS)         Keep right arg
       MOV  XL,-(XS)
       JSR  ALOCS            Allocate SCBLK for result
       MOV  (XS)+,XL
       MOV  XR,SCNCR            Keep result ptr
       PSC  XR               Prepare to store chars of result
       MOV  SCLEN(XL),WA     Get number of chars in left arg
       PLC  XL               Prepare to load left arg chars
       MVC                   Move characters of left argument
       MOV  (XS)+,XL         Load right arg pointer
       MOV  SCLEN(XL),WA     Load number of chars in right arg
       PLC  XL               Prepare to load right arg chars
       MVC                   Move characters of right argument
       MOV  SCNCR,XR            Return result string
*
*      Merge for null argument cases
*
SCON1  EXI                   Return to caller
*
*      Here for null right arg
*
SCON2  MOV  XL,XR            Return left arg
       BRN  SCON1            Return
       ENP                   End procedure SCONC
       EJC
*
*      SELST -- select set elts from a tuple
*
*      Useful in POW and NPOW, a selector tuple, with 0 and 1
*      entries is used to indicate which elements of a tuple
*      are to selected.  A set is formed of those selected
*      elements.
*
*      (XL)                  ptr to selector tuple
*      (XR)                  ptr to tuple of elts
*      JSR  SELST            call to copy selected elts into set
*      (XR)                  ptr to resulting set
*      (WA,WB,WC)            destroyed
*
SELST  PRC  E,0
       MOV  XR,-(XS)         save tuple
       MOV  XL,-(XS)           selector tuple
       MOV  *TPSI$,-(XS)       init tuple offset
       MOV  TPNEL(XL),WA
       WTB  WA
       ADD  *TPSI$,WA
       MOV  WA,-(XS)           and terminator offset
       MOV  =NLSET,XL        init result set
*
SST01  MOV  OFFS2(XS),XR     get selector
       ADD  OFFS1(XS),XR     point to selector entry
       BZE  (XR),SST02       jump to skip selection
       MOV  OFFS3(XS),XR     get tuple
       ADD  OFFS1(XS),XR     add offset to get entry
       MOV  (XR),XR
       JSR  ADSEL            add elt
*
SST02  ICA  OFFS1(XS)        update iterator
       MOV  OFFS1(XS),WA
       BLT  WA,(XS),SST01    loop thru selector
*
       MOV  XL,XR            return power set
       ADD  *NUM04,XS        discard iter lim,iter,sel,tup
       EXI
       ENP
       EJC
*
*      SETTP -- copy set elements to a tuple
*
*      Elements of a set are copied into successive locations in
*      a tuple.  This is especially useful for POW and NPOW, since
*      we have to be able to easily select elements from a set.
*      After using SETTP, we can simply use the tuple version.
*      The selector tuple is initialized.
*
*      (XR)                  pointer to STBLK
*      JSR  SETTP            call to copy set elts to tuple
*      (XR)                  pointer to result TPBLK
*      (XL)                  pointer to selector TPBLK
*      (WA,WB,WC)            destroyed
*
SETTP  PRC  E,0
       MOV  XR,-(XS)         save set
       MOV  STNEL(XR),WA     get # elts in set
       JSR  ALOTS            create new tuple block
       MOV  =B$TPL,(XR)
       MOV  (XS),XL
       MOV  STNEL(XL),TPNEL(XR)
       MOV  XR,-(XS)         and save it
       MOV  *STSI$,WA        init set iterator
       MOV  WA,-(XS)           and save
       ADD  *TPSI$,XR        init tuple entry ptr
       MOV  XR,-(XS)
*
       MOV  OFFS3(XS),XR     retrieve set
       MOV  STNEL(XR),WC     get # elts
       LCT  WC,WC              and set counter
STP01  MOV  OFFS1(XS),XL     retrieve iterator
STP02  JSR  NEXTS            get elt
       BNE  XR,=OMEGA,STP03  jump if real entry
       MOV  WA,XR
       BRN  STP02            if om, try again
*
STP03  MOV  XL,OFFS1(XS)     save updated iterator
       MOV  (XS)+,XL         retrieve tuple entry ptr
       MOV  XR,(XL)+         and insert entry
       MOV  XL,-(XS)
       MOV  OFFS3(XS),XR     recover set
       BCT  WC,STP01
*
       ICA  XS               discard tuple entry ptr
       ICA  XS                 and set iterator
*
*      New create the selector tuple
*
       MOV  STNEL(XR),WA
       JSR  ALOTS            create selector
       MOV  =B$TPL,(XR)
       MOV  (XS),XL
       MOV  TPNEL(XL),WA
       MOV  WA,TPNEL(XR)
       MOV  XR,-(XS)         and save
*
       ADD  *TPSI$,XR        point to first entry
       LCT  WA,WA
STP04  ZER  (XR)+
       BCT  WA,STP04
*
       MOV  (XS)+,XL         retrieve selector
       MOV  (XS)+,XR         retrieve tuple
       ICA  XS               discard set
       EXI
       ENP
       EJC
*
*      SLICT -- extract slice from tuple  t(i..j)
*
*      On entry, the tuple, i, and j are on the stack.
*      Also i is known to be in range 1..#t
*
*      2(XS)                 ptr to tpblk
*      1(XS)                 ptr to i icblk
*      (XS)                  ptr to j icblk
*      JSR  SLICT            get tuple slice
*      (XR)                  ptr to result slice tpblk
*      (XL,WA)               destroyed
*
SLICT  PRC  N,0
       MOV  (XS)+,XR         get end index icblk
       MOV  ICVAL(XR),SLCIE  save value
       MOV  (XS)+,XR         get init index
       MOV  ICVAL(XR),SLCIC
       MOV  (XS),XL          get tuple
       MOV  TPNEL(XL),WA
       BGE  WA,SLCIE,SLCT1
       MOV  WA,SLCIE         if j>#t reset j=#t
SLCT1  MOV  SLCIE,WA         compute size of target
       SUB  SLCIC,WA
       ICV  WA
       JSR  ALOTS            get new block
       MOV  =B$TPL,(XR)      set block type
       MOV  XR,-(XS)           and save
       MOV  =NUM01,SLCTC     init target index
*
SLCT2  MOV  OFFS1(XS),XR     get source tuple
       MOV  SLCIC,WA           and index
       JSR  TPELT            get elt
       PPM  SLCT3            skip if om
       JSR  COPYV            copy elt if needed
       MOV  XL,XR
       MOV  (XS),XL          get target
       MOV  SLCTC,WA           and index
       JSR  ADTEL
SLCT3  ICV  SLCIC            incr indices
       ICV  SLCTC
       BLE  SLCIC,SLCIE,SLCT2  loop if not done
*
       MOV  (XS)+,XR         return target
       ICA  XS               discard orig tuple
       EXI
       ENP
       EJC
*
*      SLTPI -- Insert a tuple slice into a tuple
*
*      On entry, the indices are known to be within the
*      index range for the source tuple.  Target may be updated
*      if needed during ADTEL.
*
*      (XR)                  source tuple
*      (XL)                  target tuple
*      (WA)                  init source index
*      (WB)                  end source index
*      (WC)                  init target index
*      JSR  SLTPI            insert source slice into target
*      (XR)                  restored
*      (XL)                  target (updated)
*      (WC)                  updated target index (to next index)
*      (WA,WB)               destroyed
*
*      Global refs:
*      SLTIE                 source end index
*      SLTIC                 source index counter
*      SLTTC                 target index counter
*
SLTPI  PRC  E,0
       MOV  WA,SLTIC         init counter
       MOV  WB,SLTIE           and end index
       MOV  WC,SLTTC         init target counter
       MOV  XR,-(XS)         save source
       MOV  XL,-(XS)           and target
SLTP1  MOV  OFFS1(XS),XR     get source tuple
       MOV  SLTIC,WA           and index
       JSR  TPELT            get elt
       PPM  SLTP2            never out of range
       JSR  COPYV            copy elt if needed
       MOV  XL,XR
       MOV  (XS),XL          get target
       MOV  SLTTC,WA           and index
       JSR  ADTEL            insert elt
       MOV  XL,(XS)          update target
SLTP2  ICV  SLTIC            incr indices
       ICV  SLTTC
       BLE  SLTIC,SLTIE,SLTP1  loop until done
*
       MOV  SLTTC,WC         update target index
       MOV  (XS)+,XL         update target
       MOV  (XS)+,XR         restore source
       EXI
       ENP
       EJC
*
*      STCMP -- compare two sets for equality
*
*      On entry, both arguments are known to be either
*      sets or maps. Since it is possible for a set to
*      have become a map, by removal of non-pairs, yet still
*      not have its type word set, we compare all elements.
*
*      (XL)                  Left comparand
*      (XR)                  Right comparand
*      JSR  STCMP
*      PPM  loc              equal
*      PMM  loc              not equal
*      normal return never taken
*
STCMP  PRC  R,2
       BEQ  STNEL(XL),STNEL(XR),STCM0 if diff sizes
       EXI  2                immediate fail
*      Preserve all registers, because we have to call
*      all sorts of procedures which dont
*
STCM0  MOV  WC,-(XS)
       MOV  WB,-(XS)
       MOV  WA,-(XS)
       MOV  XL,-(XS)
       MOV  XR,-(XS)
*
       EJC
       MOV  *STSI$,-(XS)     also stack initial iterator offset
STCM1  MOV  (XS),XL          load an offset
       MOV  OFFS1(XS),XR         and a set
       JSR  NEXTS            get an element
       BNZ  WB,STCX1         succeed if wrapped round
       MOV  XL,(XS)          else stack new offset
       BEQ  XR,=OMEGA,STCM1
       MOV  OFFS2(XS),XL         get other set
       JSR  FINDS            look for this element
       PPM  STCM1            loop if found
       PPM  STCX2            fail if fail
       PPM  STCX2            fail if fail
*
*      Here if we succeed
*
STCX1  ZER  WC               flag success
       BRN  STCXX            merge
*
*      Here on failure
*
STCX2  MNZ  WC               flag
*
*      Merge to recover regs
*
STCXX  ICA  XS               discard offset
       MOV  (XS)+,XR
       MOV  (XS)+,XL
       MOV  (XS)+,WA
       MOV  (XS)+,WB
       BZE  WC,STXX1         jump if succeeded
       MOV  (XS)+,WC
       EXI  2
STXX1  MOV  (XS)+,WC
       EXI  1
       ENP
       EJC
*
*      STNCL -- test for set inclusion
*
*      STNCL is called to test whether arg1 INCL arg2
*      On entry both arguments are known to be
*      either STBLKs or MPBLKs.
*
*      (XL)                  ptr to arg1
*      (XR)                  ptr to arg2
*      JSR  STNCL
*      PPM  loc              yes
*      PPM  loc              no
*
*      STNCL is called fo the INCS and SUBSET operators of
*      SETL - it does not seem worth calling CHKMP to pick
*      out the fact that map INCL set is impossible.
*
STNCL  PRC  E,2
       BGT  STNEL(XR),STNEL(XL),STN10 worth checking
       MOV  XR,NCLXR
       MOV  XL,NCLXL
       MOV  *STSI$,XL        initialise set iterator
*
       EJC
STN22  JSR  NEXTS            get next from arg
       BNZ  WB,STN20         jump if done
       MOV  XL,-(XS)         else stack iterator
       BEQ  XR,=OMEGA,STN21  ignore OMs
       MOV  NCLXL,XL         reload arg
       JSR  FINDS            look for element
       PPM  STN21            found
       PPM  STN11
       PPM  STN11
*
*      Keep checking
*
STN21  MOV  (XS)+,XL         reload iterator
       MOV  NCLXR,XR         and arg
       BRN  STN22            loop
*
*      Success exit
*
STN20  EXI  1
*
*      Fail if element was missing
*
STN11  ICA  XS               throw away iterator
STN10  EXI  2
       ENP
       EJC
*
*      STRGV -- get string value
*
*      STRGV is given a SETL-s object and returns a string
*      for STR and PRINT.
*
*      (XR)                  ptr to object
*      (WC)                  must be collectable
*      JSR  STRGV
*      (XR)                  ptr to SCBLK
*      (WA,WB)            destroyed
*
*      GTSTG (ex SBL) is used to do the numeric conversions
*      Aggregates are handled simply by calling STRGV
*      recursively and SCONCing the strings, with commas
*      etc thrown in here and there.  This is a wasteful
*      approach, and a better man than I might like to
*      integrate STRGV and GTSTG so that they used a
*      global buffer to build the string in - if it fills
*      up, you overflow into an SCBLK (initiallu NULLS)
*      and use SCONC to stick together overflow and final
*      buffer contents.
*
*      Note also that at present strings are simply returned,
*      which is not strictly what is specified in the
*      SETL book.
*
       EJC
STRGV  PRC  R,0
       MOV  WC,-(XS)
       MOV  XL,-(XS)
       MOV  XR,-(XS)
       BEQ  (XR),=B$STL,STRG1
       BEQ  (XR),=B$MPL,STRG1
       BEQ  (XR),=B$PRL,STRG2
       BEQ  (XR),=B$TPL,STRG3
       BEQ  (XR),=B$ATL,STRGA
*
*      That only leaves things we already know about
*
       JSR  GTSTG            call a friend
       PPM                   cant fail
       MOV  (XS)+,XL
       MOV  (XS)+,WC
       EXI
       EJC
*
*      For atom, adopt a lazy solution
*
STRGA  LDI  ATVAL(XR)        load print value
       JSR  ICBLD            build an ICBLK
       MOV  XR,(XS)          pass on stack
       JSR  GTSTG            get string for it
       PPM                   how can it fail
       MOV  =ATSTR,XL        fetch sign
       JSR  SCONC            stick these together
       MOV  (XS)+,XL         restore for caller
       MOV  (XS)+,WC
       EXI
*
*      Here for set/map
*
STRG1  MOV  *STSI$,WB        this will be iterator
       MOV  =NULLS,XR        start from nothing
       MOV  =LSETB,WC        string for left set bracket
*
STRG4  MOV  WB,XL            get set iterator
       MOV  XR,WB            save string
STRG7  MOV  (XS),XR          reload set
       MOV  WB,-(XS)         and stack result string
       JSR  NEXTS            fetch an element
       BNZ  WB,STRG5         done if wraparound
       BEQ  XR,=OMEGA,STRG6  skip OMs
       JSR  STRGV            build string for element
       MOV  XL,WB            save iterator
       MOV  WC,XL            get separator
       JSR  SCONC            stick together
       MOV  (XS)+,XL         get string so far
       MOV  WB,-(XS)         save in case of GBCOL
       JSR  SCONC            add this one
       MOV  (XS)+,WB         restore
       MOV  =COMMA,WC        load a comma
       BRN  STRG4            and loop
*
*      Here when skipping OMs
*
STRG6  MOV  (XS)+,WB
       BRN  STRG7
*
*      Here to finish off
*
STRG5  MOV  =RSETB,XR        for end
       MOV  (XS)+,XL
       BNE  XL,=NULLS,STRGB  must have been empty set
       MOV  =LSETB,XL
STRGB  JSR  SCONC            stick it on
*
*      Merge here to exit
*
STRG0  ICA  XS               pop original XR
       MOV  (XS)+,XL         restore
       MOV  (XS)+,WC
       EXI
       EJC
*
*      Here with a pair
*
STRG2  MOV  =LTUPB,XL        load left tuple bracket
       MOV  PRDOM(XR),XR     get first element
       JSR  STRGV            as a string
       JSR  SCONC            concatenate these
       MOV  XR,XL
       MOV  =COMMA,XR        add a comma
       JSR  SCONC
       MOV  XR,XL
       MOV  (XS),XR          reload pair
       MOV  PRRNG(XR),XR     and get second element
       JSR  STRGV            as a string
       JSR  SCONC            concatenate
       MOV  XR,XL
       MOV  =RTUPB,XR        right tuple bracket
       JSR  SCONC            goes on the end
       BRN  STRG0            merge to return
       EJC
*
*      Here to convert tuple into string
*
STRG3  MOV  =NULLS,XR        build from nothing
       MOV  =LTUPB,WC        left bracket
       MOV  =NUM01,-(XS)     stack index of first element
*
STRG8  MOV  XR,XL
       MOV  (XS)+,WA         get index
       MOV  (XS),XR          and load tuple
       JSR  TPELT            fetch element
       PPM  STRG9            jump if exhausted
       ICV  WA               bump
       MOV  WA,-(XS)         and save
       JSR  STRGV            get string for this element
       MOV  XL,-(XS)         save what we got
       MOV  WC,XL            load sparator
       JSR  SCONC
       MOV  (XS)+,XL
       JSR  SCONC            add it on
       MOV  XR,XL
       MOV  =COMMA,WC        ready with the comma
       BRN  STRG8            loop
*
*      Here after all elements dealt with
*
STRG9  MOV  =RTUPB,XR        right tuple bracket
       BNE  XL,=NULLS,STRGC  no elements
       MOV  =LTUPB,XL        frig it
STRGC  JSR  SCONC            for end
       BRN  STRG0
       ENP
       EJC
*
*      STRSB -- look for substring
*
*      (i am running out of good 5 char names)
*
*      (XL)                  target substring
*      (XR)                  string to be searched
*      JSR  STRSB
*      PPM  loc              not found
*      PPM  loc              found
*      (WA,WB,WC)            destroyed
*
STRSB  PRC  E,2
       BGT  SCLEN(XL),SCLEN(XR),STRB1 fail if (XL) longer
       MOV  XL,STRBL
       MOV  XR,STRBR
       ZER  WB               initial offset
*
*      We just keep doing CMCs, using substrings of the
*      longer string starting at successive positions, til
*      we run out.
*
STRB4  MOV  SCLEN(XL),WA     load shorter length
       MOV  SCLEN(XR),WC     load longer
       SUB  WA,WC            get difference
       ICV  WC               one of those things
       BGE  WB,WC,STRB1      this is the end condition JVK rev
       PLC  XR,WB            point to substring
       PLC  XL
       CMC  STRB3,STRB3
*
*      Success
*
       MOV  STRBL,XL
       MOV  STRBR,XR
       EXI  2
*
*      Else try further along
*
STRB3  MOV  STRBL,XL         recover
       MOV  STRBR,XR         index regs
       ICV  WB
       BRN  STRB4
*
*      Fail here
*
STRB1  EXI  1
       ENP
       EJC
*
*      SYMTS -- symbol table search
*
*      SYMTS locates a variable block (VRBLK) or reserved
*      word block (WDBLK) given a string argument.
*      If WA is 0 then search either for global or local symbol.
*      If WA is non-zero, it is a WDBLK ptr for a reserved word
*      symbol for which a global entry is to be made. If symbol
*      is not found, then either a WDBLK entry is made or a new
*      VRBLK is created and entered which will be global if
*      PRCNO is zero when SYMTS is called or will be local to
*      the procedure corresponding to current value of PRCNO.
*      Note that PRCNO is incremented by =PRCNC, a power of two,
*      so that it may be ORed into a word with a name length
*      not exceeding =VRMXL. Search for a symbol is made by
*      initially checking VRLEN field of VRBLK on hash chain
*      for a match on name length only (ultimate match indicates
*      global) and also on current PRCNO ORed with name length
*      (ultimate match indicates local). Initial match for
*      either of above is followed by character check of names.
*      Note SETL does not allow use of a global variable also
*      as a local, so only one lookup is capable of succeeding.
*
*      (XR)                  argument (SCBLK)
*      (WA)                  WDBLK pointer / 0
*      JSR  SYMTS            call to lookup symbol
*      (XR)                  pointer to VRBLK or WDBLK
*
SYMTS  PRC  E,0              Entry point
       MOV  WA,SYMSA         Save WA
       MOV  WB,SYMSB         Save WB
       MOV  XL,-(XS)         Save XL
       MOV  XR,-(XS)         Stack string ptr for later
       MOV  XR,WB            Copy string pointer
       ADD  *SCHAR,WB        Point to characters of string
       MOV  WB,SYMSC         Save pointer to characters
       MOV  SCLEN(XR),WA     Get name length for global search
       MOV  WA,WB            Copy it
       ORB  PRCNO,WB         Include PRCNO for local search
       MOV  WB,SYMNL         Keep copy for reference
       MOV  WA,WB            Get length again
       CTW  WB,0             Get number of words in name
       MOV  WB,SYMNW         Save for later
       JSR  HASHS            Compute hash index for string
       STI  SYMHS            Keep hash value
       RMI  HSHNB            Compute hash offset mod header no.
       MFI  WC               Get as offset
       WTB  WC               Convert offset to BAUS
       ADD  HSHTB,WC         Point to proper hash chain
       SUB  *VRNXT,WC        Subtract offset to merge into loop
       EJC
*
*      SYMTS (continued)
*
*      Loop to search hash chain
*
SYM01  MOV  WC,XL            Copy hash chain pointer
       MOV  VRNXT(XL),XL     Point to next VRBLK on chain
       BZE  XL,SYM05         Jump if end of chain
       MOV  XL,WC            Save pointer to this VRBLK
       BEQ  WA,VRLEN(XL),SYM02 Jump if equal lengths
       BNE  SYMNL,VRLEN(XL),SYM01 Cont if uneq (lnths OR PRCNO)
*
*      Length match. Now check actual characters of names
*
SYM02  ADD  *VRCHS,XL        Else point to chars of chain entry
       LCT  WB,SYMNW         Get word counter to control loop
       MOV  SYMSC,XR         Point to chars of new name
*
*      Loop to compare characters of the two names
*
SYM03  CNE  (XR),(XL),SYM01  Jump if no match for next VRBLK
       ICA  XR               Bump new name pointer
       ICA  XL               Bump VRBLK in chain name pointer
       BCT  WB,SYM03         Loop till all compared
       MOV  WC,XR            We have found a match, get entry
*
*      Exit point after finding entry or making new one
*
SYM04  MOV  SYMSA,WA         Restore WA
       MOV  SYMSB,WB         Restore WB
       ICA  XS               Pop string pointer
       MOV  (XS)+,XL         Restore XL
       EXI                   Return to SYMTS caller
*
*      Not found - make an insertion, checking to see if WDBLK
*
SYM05  MOV  WC,XL            Ptr to end of hash chain
       MOV  SYMSA,XR         Get WDBLK ptr
       BZE  XR,SYM06         Jump if not initlisn of WDBLK
       MOV  XR,VRNXT(XL)     Store ptr to WDBLK on hash chain
       BRN  SYM04            Return
       EJC
*
*      SYMTS (continued)
*
*      Not found. Make a new VRBLK.
*
SYM06  MOV  =VRCHS,WA        Load size of standard fields
       ADD  SYMNW,WA         Adjust for chars of name
       WTB  WA               Convert length to BAUS
       MOV  XL,-(XS)
       JSR  ALOST            Allocate space for VRBLK (static)
       MOV  (XS)+,XL
       MOV  XR,VRNXT(XL)     Add new block to end of chain
       MOV  XR,WB            Save VRBLK pointer
       MOV  =STNVR,XL        Point to model variable block
       MOV  *VRLEN,WA        Set length of standard fields
       MVW                   Set initial fields of new block
       MOV  SYMNL,(XR)+      Set VRLEN field, bump ptr
       MOV  SYMNW,WA         Get length in words
       WTB  WA               Convert to length in BAUS
       MOV  (XS),XL          Point back to string name
       ADD  *SCHAR,XL        Point to chars of name
       MVW                   Move characters into place
       MOV  WB,XR            Restore VRBLK pointer
       BRN  SYM04            Jump back to exit
       ENP                   End procedure SYMTS
       EJC
*
*      TACTN -- terminal action
*
*      TACTN is called by the LALR compiler in order to determine
*      the action to be taken for a given input terminal.
*
*      ACTLR                 Current State
*      CTOKN                 Terminal - token number
*      JSR  TACTN            call to determine action
*      ACTLR                 Return action
*
TACTN  PRC  E,0
       MOV  XL,-(XS)         save registers
       MOV  WA,-(XS)
       MOV  ACTLR,WA         get args
       ADD  CTOKN,WA         compute WA as index into table
       SUB  =NMRUL,WA        adjust to 1.. offset
       WTB  WA                 then byte offset
*
*      Test check table entry
*
       MOV  R$CHK,XL        get addr of check table
       ADD  WA,XL            get entry
       BNE  (XL),CTOKN,TACT2  jump for default action
*
       MOV  R$ACT,XL        find action table
       ADD  WA,XL            get entry at  action(state+term)
       MOV  (XL),ACTLR       return entry
       BRN  TACT3
*
*      Return default entry
*
TACT2  MOV  R$ACT,XL        get action table
       MOV  ACTLR,WA         recover state
       SUB  =NMRUL,WA        adjust to 1.. index
       WTB  WA               offset into table
       ADD  WA,XL            get entry  action(state)
       MOV  (XL),ACTLR         and return it
*
*      Merge for exit
*
TACT3  MOV  (XS)+,WA         recover registers
       MOV  (XS)+,XL
       EXI
       ENP
       EJC
*
*      TCONC -- tuple concatenation - JVK addition
*
*      TCONC is used to concatenate two arguments already
*      known to be tuples.
*
*      (XL)                  left tuple arg
*      (XR)                  right tuple arg
*      JSR  TCONC            call to do tuple concatenation
*      (XR)                  result tuple
*      (XL,WA,WB,WC)         destroyed
*
TCONC  PRC  E,0
       BZE  TPNEL(XL),TCON8  empty left arg
       BZE  TPNEL(XR),TCON9  empty right arg
       MOV  XR,-(XS)         save right arg
       MOV  TPNEL(XL),WA     get total number elts
       ADD  TPNEL(XR),WA
       MOV  XL,-(XS)         save left arg
       JSR  ALOTS            get new block
       MOV  =B$TPL,(XR)        set type
       MOV  XR,-(XS)           and save
*               first copy left argument
       MOV  =NUM01,WA        init index
       MOV  WA,-(XS)           and save it
TCON4  MOV  OFFS2(XS),XR     get left tuple
       JSR  TPELT            fetch element
       PPM  TCON5            exit loop if done
       JSR  COPYV            copy elt if needed
       MOV  (XS),WA          retrieve index
       MOV  XL,XR            shift copy
       MOV  OFFS1(XS),XL     get new block
       JSR  ADTEL              and add elt to it
       ICV  (XS)             increment index
       MOV  (XS),WA            and reload it
       BRN  TCON4
*             after left is copied
TCON5  ICA  XS               discard index
       MOV  (XS)+,XL         get new tuple
       MOV  (XS)+,XR         get left arg
       MOV  XL,-(XS)         save new tuple
*             next copy right arg
       MOV  =NUM01,WA        init source index
       MOV  WA,-(XS)           and save it
       MOV  WA,WC            init target index
       ADD  TPNEL(XR),WC       past last element
       MOV  WC,-(XS)           and save
TCON1  MOV  OFFS3(XS),XR     get right tuple
       JSR  TPELT            fetch an element
       PPM  TCON2            exit loop when done
       JSR  COPYV            copy elt if necessary
       MOV  XL,XR              and shift to xr
       MOV  (XS),WA          get target index
       MOV  OFFS2(XS),XL     get new tuple
       JSR  ADTEL              and add new elt
       ICV  (XS)             incr target index
       ICV  OFFS1(XS)          and source index
       MOV  OFFS1(XS),WA     reload source index
       BRN  TCON1
TCON2  ICA  XS               discard indices
       ICA  XS
       MOV  (XS)+,XR         fetch result copy
       ICA  XS               discard left
       EXI
*                null right arg, return left
TCON9  MOV  XL,XR            then merge
*                null left arg, return right
TCON8  JSR  COPYV            make copy if needed
       MOV  XL,XR
       EXI
       ENP
       EJC
*
*      TNBLD -- build a tree node
*
*      Builds a tree-node (CMBLK) to represent the structure
*      for the production being applied at this reduction.
*      LALR version
*
*      ACTLR                 Production rule nbr
*      (XS)                  2 * length of production + 1
*      PRNE1(XS)             last element of production
*      PRNE2(XS)             second last element
*      etc.
*      JSR  TNBLD
*      (XL, XR, WA, WB)      destroyed
*      R$SRP                  ptr to treenode
*
*      See CMBLK format for a description of the nodes built.
*      At each reduction, the descendants of the node being
*      built correspond only to symbols in the right side of
*      the production being applied and the values of these
*      symbols will have been stacked during previous shift
*      moves - the position of each on the stack is known from
*      its place in the production.  The node returned from this
*      procedure will be returned by SCANE (qv) as the token
*      value corresponding to the non-terminal which is the
*      subject of the production, and hence will get stacked in
*      its turn.
*
TNBLD  PRC  N,0
       MOV  ACTLR,XR         load production number
       MOV  XR,WB            JVK-save prod #, XR destroyed by BSW
       MOV  XS,XT            set up second stack pointer
       BZE  ERFLG,TNBSW      jump to switch if no error
       ERB  013,parse error-illegal rule nbr
       EJC
*
*      Switch on production number to select the correct
*      semantic action - this code should be read in conjunction
*      with a numbered listing of the Setl-s grammar (Minimal
*      restrictions on character set preclude a sensible
*      reproduction of it here).  The comments appended to each
*      IFF indicate the subject symbol of the
*      corresponding production.
*      Note that although the procedure is mainly for building
*      tree nodes, in a few cases it performs some other
*      semantic action
*
TNBSW  BSW  XR,PCC25,TNB01
       IFF  PRN07,TNB02       Body
       IFF  PRN21,TNB31       Constant_Declaration
       IFF  PRN26,TNB32       Init_Declaration
       IFF  PRN30,TNB33       Procedure_Predecl_Name
       IFF  PRN31,TNB83       Routine
       IFF  PRN32,TNB35       Procedure_Header
       IFF  PRN38,TNB43       Formal
       IFF  PRN39,TNB42       Procedure_Body
       IFF  PRN42,TNS04       Statement_Block
       IFF  PRN43,TNS00       Statement_Block
       IFF  PRN44,TNS36       Statement_List
       IFF  PRN57,TNS27       If_Statement
       IFF  PRN58,TNS27       Elseif_Stmt_List
       IFF  PRN59,TNS03       Elseif_Stmt_List
       IFF  PRN61,TNS10       Opt_Else_Stmt
       IFF  PRN64,TNS37       Case_Statement
       IFF  PRN65,TNS70       Case_Stmt_Body
       IFF  PRN67,TNS03       Case_Stmt_List
       IFF  PRN68,TNS76       Case_Tag
       IFF  PRN71,TNS39       Yield_Statement
       IFF  PRN72,TNS79       Return_Statement
       IFF  PRN73,TNS80       Return_Statement
       IFF  PRN79,TNS84       Procedure_Call
       IFF  PRN81,TNS03       Parameter_List
       IFF  PRN82,TNS10       Parameter_List
       IFF  PRN83,TNS10       Parameter_List
       IFF  PRN84,TNS23       Store_Value_Statement
       IFF  PRN85,TNS23       Store_Value_Statement
       IFF  PRN86,TNS23       Store_Value_Statement
       IFF  PRN87,TNS23       Store_Value_Statement
       IFF  PRN88,TNS64       Input_Output_Statement
       IFF  PRN89,TNS63       Input_Output_Statement
       IFF  PRN90,TNS62       Input_Output_Statement
       IFF  PRN91,TNS61       Input_Output_Statement
       IFF  PRN92,TNS41       Signed_Number
       IFF  PRN98,TNS44       Constant
       IFF  PRC00,TNS05       Constant_List
       IFF  PRC02,TNB88       Id_List
       IFF  PRC03,TNB88       Id_List
       IFF  PRC04,TNS08       Loop_Statement
       IFF  PRC05,TNS08       Loop_Statement
       IFF  PRC12,TNS09       Full_Iterator
       IFF  PRC14,TNS10       Opt_Init
       IFF  PRC16,TNS10       Opt_Doing
       IFF  PRC18,TNS10       Opt_While
       IFF  PRC20,TNS10       Opt_Step
       IFF  PRC22,TNS10       Opt_Until
       IFF  PRC24,TNS10       Opt_Term
       IFF  PRC25,TNS48       Iterator
       IFF  PRC27,TNS48       Simple_Iterator_List
       IFF  PRC29,TNS15       Simple_Iterator
       IFF  PRC30,TNS15       Simple_Iterator
       IFF  PRC31,TNS66       Simple_Iterator
       IFF  PRC32,TNS67       Simple_Iterator
       IFF  PRC33,TNS49       Existential_Expression
       IFF  PRC34,TNS50       Existential_Expression
       IFF  PRC35,TNS51       Universal_Expression
       IFF  PRC36,TNS16       Set_Former
       IFF  PRC37,TNS19       Set_Former
       IFF  PRC38,TNS17       Tuple_Former
       IFF  PRC39,TNS20       Tuple_Former
       IFF  PRC41,TNS52       Former_Inside
       IFF  PRC43,TNS56       Former_Extension
       IFF  PRC46,TNS53       Former_Extension
       IFF  PRC47,TNS55       Former_Iterator
       IFF  PRC48,TNS54       Former_Progression
       IFF  PRC49,TNS05       Expression_List
       IFF  PRC58,TNX01       Aterm
       IFF  PRC60,TNX01       Bterm
       IFF  PRC62,TNX01       Dterm
       IFF  PRC64,TNX13       Eterm
       IFF  PRC66,TNX11       Fterm
       IFF  PRC67,TNX11       Fterm
       IFF  PRC68,TNX11       Fterm
       IFF  PRC70,TNX11       Hterm
       IFF  PRC71,TNX11       Hterm
       IFF  PRC72,TNX11       Hterm
       IFF  PRC74,TNX11       Iterm
       IFF  PRC76,TNX30       Jterm
       IFF  PRC78,TNX11       Kterm
       IFF  PRC80,TNX13       Lterm
       IFF  PRC81,TNX24       Lterm
       IFF  PRC82,TNX31       Lterm
       IFF  PRC89,TNS03       Primary
       IFF  PRC92,TNX57       Primary
       IFF  PRC93,TNX57       Primary
       IFF  PRC94,TNX58       Primary
       IFF  PRC96,TNS03       Parallel_Lhs
       IFF  PRC97,TNS05       Special_List
       IFF  PRC98,TNS07       Special_List
       IFF  PCC00,TNS10       Special
       IFF  PCC01,TNS05       Name_List
       IFF  PCC05,TNX57       Selected_Name
       IFF  PCC06,TNX69       Subscript_List
       IFF  PCC08,TNX71       Subscript
       IFF  PCC09,TNX72       Subscript
       IFF  PCC10,TNX75       Subscript
       IFF  PCC11,TNX76       Subscript
       IFF  PCC12,TNX74       Subscript
       IFF  PCC13,TNS23       Assignment_Expression
       IFF  PCC14,TNS23       Assignment_Expression
       IFF  PCC15,TNS27       If_Expression
       IFF  PCC16,TNS27       Else_Expr_List
       IFF  PCC17,TNS03       Else_Expr_List
       IFF  PCC19,TNS10       Opt_Else_Expr
       IFF  PCC20,TNS37       Case_Expression
       IFF  PCC21,TNS38       Case_Expr_Body
       IFF  PCC23,TNS03       Case_Expr_List
       IFF  PCC24,TNX59       Expression_Block
       ESW
       EJC
*
*      Reduce Statement to StmtBlock - incr stmt nr.
*
TNS00  ICV  CMPSN
*
*      Fall thru to do single symbol reduction
*
*      Default action
*      This will be a reduction by a production with a
*      single symbol on the right, so just set R$SRP to
*      its value.  This wasteful action will not have to
*      be done very often, as reductions by single productions
*      have mostly been eliminated.
*
*      Reductions where only the last element is semantically
*      significant also come here.
*
TNB01  MOV  PRNE1(XS),R$SRP
       EXI
*
*      Reduce to Body - go and generate code
*
TNB02  MOV  PRNE2(XS),XR     get tree for program
       JSR  CODEG            codegenerate
       EXI
*
*      Constant item - write protect VRBLK
*
TNB31  MOV  PRNE3(XS),XR
       MOV  =B$VER,VRSTO(XR)
       BRN  TNB60            merge to set value
*
*      Initialised item - set value
*
TNB32  MOV  PRNE3(XS),XR
TNB60  MOV  PRNE1(XS),VRVAL(XR)
*
*      Fall through to check scope
*      Merge with namelist = $name
*
TNB28  BGT  PRCNO,=PRCNC,TNB27 jump if inside procedure
       MOV  PVNML(XR),WA     load length with PRCNO bits
       ANB  PRCMX,WA         clear bits
       MOV  WA,PVNML(XR)     make global
       BRN  TNBEX            leave with it
TNB27  BHI  PVNML(XR),=PRCNC,TNBEX ok unless global
       ERB  251,global name re-declared as local
       EJC
*
*      IdList for VARs
*
TNB88  MOV  PRNE1(XS),XR
       BRN  TNB28            back to old routine
*
*      Proc predeclaration - set up PCBLK and fix VRBLK
*      to be PVBLK
*
TNB33  MOV  *PCSI$,WA        size of PCBLK
       ZER  XL
       JSR  ALLOC
       MOV  XR,XL            copy pointer to PCBLK
       ADD  WA,XL            point past end
       MOV  =B$PCC,(XR)+     set type word
       MOV  PRNE1(XS),(XR)+  point to eventual PVBLK
TNB34  ZER  (XR)+            loop to clear remaining fields
       BLT  XR,XL,TNB34
       SUB  WA,XL            point back to start
       MOV  PRNE1(XS),XR     fetch VRBLK
       MOV  XL,PVVAL(XR)     set value to PCBLK
       MOV  =T$FNA,PVTYP(XR) set type for SCANE
       MOV  PVNML(XR),WA
       ANB  PRCMX,WA         clear procno bits
       MOV  WA,PVNML(XR)     to make global
       MOV  R$PVB,(XR)       add to PVBLK chain
       MOV  XR,R$PVB         reset chain head
       BRN  TNBEX
*
*      Procedure header
*
TNB35  MOV  PRNE3(XS),XR     get PCBLK
       MOV  PRCSP,PCARG(XR)  fill PVBLK field of PCBLK
       BZE  PCCOD(XR),TNBEX  return if unset
       ERB  252,procedure name re-used
*
*      Procedure body - extract node for statements
*
TNB42  MOV  PRNE3(XS),R$SRP
       EXI
*
*      Formal Parameter
*
TNB43  ICV  PCACT            count it
       EXI
*
*      Procedure code completed
*
TNB83  MOV  PRNE2(XS),XL     load the PVBLK
       MOV  PRNE1(XS),XR     and the tree
       JSR  GENPC            go generate code for this procedure
       EXI
       EJC
*
*      Select second last element - parenth exp etc.
*
TNS03  MOV  PRNE2(XS),R$SRP  extract statements/expresssion
       EXI
*
*      stmt block - increment stmnt count - return statements
*
TNS36  MOV  =C$STM,WB        statement list node
       MOV  *CSI$2,WA
       MOV  PRNE2(XT),-(XS)  inelegant this
       ZER  -(XS)            null statement
       BRN  TNBBN
*
*      Form a list for statements
*
TNS04  MOV  =C$STM,WB        get type code
       ICV  CMPSN            Increment compile stmt nr
       BRN  TNS06            merge
*
*      Form a list for expressions
*
TNS05  MOV  =C$EXP,WB        get type code
*
*      Merge here to set up 3rd and 2nd last elements
*      (statement list, expression list, unary op expression
*      full former)
*
TNS06  MOV  *CSI$2,WA        two element size
       MOV  PRNE3(XT),-(XS)
       MOV  PRNE1(XT),-(XS)
       BRN  TNBBN            go make CMBLK
       EJC
*
*      Here for first on parallel lhs list
*
TNS07  MOV  =C$EXP,WB        Unusual - must mark first also
       MOV  *CSI$2,WA
       ZER  -(XS)            mark end of list
       MOV  PRNE1(XT),-(XS)  current entry
       BRN  TNBBN            make cmblk
*
*      IF statement - form a node from test, then-clause and
*      else - block
*
TNS27  MOV  *CSI$3,WA        length for 3 element node
       MOV  =C$IFS,WB        type code
       MOV  PRNE4(XT),-(XS)
       MOV  PRNE2(XT),-(XS)
       MOV  PRNE1(XT),-(XS)
       BRN  TNBBN            go make CMBLK
*
*      CASE statement/expression - extract body and
*      controlling expression
*
TNS37  MOV  =C$CAS,WB
       BRN  TNS06
*
*      case body is recursively defined, essentially giving
*      tag plus corresponding block plus chain to rest
*      of cases.  For case stmt, ensure that single stmt
*      becomes stmt list (for correct cdgen)
*
TNS70  MOV  PRNE2(XT),XR     get stmt block
       BNE  (XR),=B$CMT,TNS71 check if stmt list
       BEQ  CMTYP(XR),=C$STM,TNS38 if so, merge below
TNS71  MOV  PRNE3(XT),-(XS)  save other parts of rhs
       MOV  PRNE1(XT),-(XS)
       MOV  =C$STM,WB        create stmt list node
       MOV  *CSI$2,WA
       MOV  XR,-(XS)
       ZER  -(XS)            inelegant trailing null
       JSR  CMBLD
       MOV  =C$TAG,WB        now create tag node
       MOV  (XS)+,WA         repair order of nodes on stack
       MOV  XR,-(XS)
       MOV  WA,-(XS)
       MOV  *CSI$3,WA
       BRN  TNBBN
*
TNS38  MOV  =C$TAG,WB        here if case expr or stmt list
       MOV  *CSI$3,WA
       MOV  PRNE3(XT),-(XS)
       MOV  PRNE2(XT),-(XS)
       MOV  PRNE1(XT),-(XS)
       BRN  TNBBN
*
*      Case Tag - extract cexplist
*
TNS76  MOV  PRNE3(XS),XR
       BRN  TNBEX
*
*      YIELD statement
*
TNS39  MOV  =C$YLD,WB
       MOV  *CSI$1,WA
       MOV  PRNE1(XT),-(XS)
       BRN  TNBBN
*
*      Procedure call
*
TNS84  MOV  PRNE2(XT),XR     get PCBLK or sys fcn
       BEQ  XR,=F$ANY,TNS87  string prim require syntax check
       BEQ  XR,=F$BRK,TNS87
       BEQ  XR,=F$LEN,TNS87
       BEQ  XR,=F$MCH,TNS87
       BEQ  XR,=F$NAY,TNS87
       BEQ  XR,=F$RAN,TNS87
       BEQ  XR,=F$RBR,TNS87
       BEQ  XR,=F$RLN,TNS87
       BEQ  XR,=F$RMC,TNS87
       BEQ  XR,=F$RNA,TNS87
       BEQ  XR,=F$RSP,TNS87
       BEQ  XR,=F$SPN,TNS87
TNS86  MOV  =C$CAL,WB
       MOV  *CSI$2,WA
       MOV  PRNE2(XT),-(XS)  stack PCBLK
       MOV  PRNE1(XT),-(XS)  and argument list
       BRN  TNBBN
*
*      For string primitives:
*        check # args, 1st arg must be valid lhs
*
TNS87  MOV  XT,TNBXT         save loc of sem RHS
       MOV  PRNE1(XT),XL     get arg list
       ZER  WA               count args
       BZE  XL,TNS89
TNS88  ICV  WA               loop thru arg list
       BNE  (XL),=B$CMT,TNS89
       BNE  CMTYP(XL),=C$EXP,TNS89
       MOV  CMLHD(XL),XL
       BRN  TNS88
TNS89  BNE  WA,=NUM02,XESPA  exactly 2 args required
       JSR  CHKCP            check if 1st arg legal lhs
       PPM  XESPT            error if not
       MOV  TNBXT,XT         restore sem RHS
       BRN  TNS86            merge with other proc calls
*
*      RETURN (OM understood)
*
TNS80  MOV  =OMEGA,-(XS)     stack OM value
       BRN  TNS85            merge
*
*      RETURN expression
*
TNS79  MOV  PRNE1(XT),-(XS)  stack expression
TNS85  MOV  =C$RTN,WB
       MOV  *CSI$1,WA
       BGT  PRCNO,=PRCNC,TNBBN build block if ok
       ERB  253,RETURN not inside a procedure
       EJC
*
*      Assignment - same as binary op expression
*      except for type code
*
TNS23  MOV  =C$ASS,WB        type code
       BRN  TNX12            merge with binops
*
*
*      io statements PRINT, PRINTA, (TRACE)
*
TNS64  MOV  =C$IOS,WB
       MOV  *CSI$3,WA
       MOV  PRNE2(XT),-(XS)  function
       MOV  PRNE1(XT),-(XS)  paramlist
       ZER  -(XS)            no file arg (get arg later)
       BRN  TNBBN
*
*      READ ( namelist )
*
TNS63  MOV  =C$IOS,WB
       MOV  *CSI$3,WA
       MOV  PRNE4(XT),-(XS)
       MOV  PRNE2(XT),-(XS)
       ZER  -(XS)            no file arg
       BRN  TNBBN
*
*      READA ( expr , namelist )
*
TNS62  MOV  =C$IOS,WB
       MOV  *CSI$3,WA
       MOV  PRNE6(XT),-(XS)
       MOV  PRNE2(XT),-(XS)       namelist
       MOV  PRNE4(XT),-(XS)       arg expr
       BRN  TNBBN
       EJC
*
*      ASSERT expr
*
TNS61  MOV  =C$IOS,WB
       MOV  *CSI$3,WA
       MOV  PRNE2(XT),-(XS)
       MOV  PRNE1(XT),-(XS)       expr
       ZER  -(XS)                 no file arg
       BRN  TNBBN
*
*      Evaluate signed number constant
*
TNS41  BEQ  PRNE2(XS),=O$PLS,TNB01 return magnitude if positive
       MOV  PRNE1(XS),XR
       LDI  ICVAL(XR)
       NGI
       STI  ICVAL(XR)
       BRN  TNBEX
*
*      Check name is a constant
*
TNS44  MOV  PRNE1(XS),XR
       BEQ  VRSTO(XR),=B$VER,TNS96
       ERB  070,name is not a constant
*
TNS96  MOV  VRVAL(XR),XR
       BRN  TNBEX
*
*      Constant set/tuple
*
TNS45  ERB  322,no constant sets or tuples yet
*
*      loop statement - build node from iterator and the body
*
TNS08  MOV  *CSI$2,WA        length of 2 element node
       MOV  =C$LUP,WB        type code
       MOV  PRNE4(XT),-(XS)
       MOV  PRNE2(XT),-(XS)
       BRN  TNBBN            go make CMBLK
*
*      Full iterator - build a block from all its elements
*      (possibly null)
*
TNS09  MOV  *CSI$6,WA        length of 6 element node
       MOV  =C$FIT,WB        type code
       MOV  PRNE6(XT),-(XS)
       MOV  PRNE5(XT),-(XS)
       MOV  PRNE4(XT),-(XS)
       MOV  PRNE3(XT),-(XS)
       MOV  PRNE2(XT),-(XS)
       MOV  PRNE1(XT),-(XS)
       BRN  TNBBN            go make CMBLK
       EJC
*
*      Here for productions with null right parts
*
TNS10  ZER  R$SRP            return zero
       EXI
*
*      Add either an iterator element or a such that test
*      to the end of an iterator chain.
*
TNS48  MOV  PRNE3(XS),XL     load iterlist
TNS91  MOV  XL,XR
       MOV  CMINX(XL),XL     get link
       BNZ  XL,TNS91
*
*      Fall through at end of chian
*
       MOV  PRNE1(XS),CMINX(XR) add new element to end
       MOV  PRNE3(XS),R$SRP  return chain
       EXI
       EJC
*
*      EXISTS
*
TNS49  MOV  =C$EQN,WB
       BRN  TNS92
*
*      NOTEXISTS
*
TNS50  MOV  =C$NQN,WB
       BRN  TNS92
*
*      FORALL
*
TNS51  MOV  =C$AQN,WB
*
*      All quantifiers merge here
*
TNS92  MOV  PRNE3(XT),-(XS)
       MOV  PRNE1(XT),-(XS)
       MOV  *CSI$2,WA
       BRN  TNBBN
       EJC
*
*      Iterator - node is loop variable, expression
*
TNS15  MOV  *CSI$3,WA        size for 3 element node
       MOV  =C$ITR,WB        type code for iterator
       MOV  PRNE3(XT),-(XS)
       MOV  PRNE1(XT),-(XS)
       ZER  -(XS)            null for such that field
       BRN  TNBBN            go make CMBLK
*
*      Map (or tuple) iterator
*
TNS66  MOV  =C$MIT,WB        map iter
       BRN  TNS68            merge w curly map iter
*
*      Curly map iterator
*
TNS67  MOV  =C$MCI,WB        curly map iter
TNS68  MOV  *CSI$4,WA        4 elt node
       MOV  PRNE6(XT),-(XS)  lh
       MOV  PRNE4(XT),-(XS)  ident
       ZER  -(XS)            null link field
       MOV  PRNE2(XT),-(XS)  subscr
       BRN  TNBBN            then make CMBLK
*
*      Set formers
TNS16  MOV  =C$SET,WB        type code
       BRN  TNS18            merge with tuple former
*
*      Tuple formers
*
TNS17  MOV  =C$TUP,WB        type code
TNS18  MOV  *CSI$1,WA        only one element
       MOV  PRNE2(XT),-(XS)  extract former
       BRN  TNBBN            go make CMBLK
*
*      null set and null tuple - return them
*
TNS19  MOV  =NLSET,R$SRP     null set
       EXI
TNS20  MOV  =NLTUP,R$SRP     null tuple
       EXI
*
*      Here to finish off a former defined as exp rest
*
TNS52  MOV  PRNE1(XS),XR     find type of rest
       BEQ  CMTYP(XR),=C$ARF,TNS93
       BEQ  CMTYP(XR),=C$FMR,TNS94
*
*      It was just an expression list.
*      This gets a bit messy.
*
       MOV  PRNE1(XS),XR     load expression list (or exp on rt)
       ZER  WA
TNS81  BNE  (XR),=B$CMT,TNS82      JVK-done if leaf
       BNE  CMTYP(XR),=C$EXP,TNS82 or end of list
       MOV  XR,WA
       MOV  CMLHD(XR),XR
       BRN  TNS81
TNS82  MOV  WA,-(XS)
       MOV  PRNE2(XT),-(XS)  stack exp
       MOV  XR,-(XS)         and head of list
       MOV  =C$EXP,WB
       MOV  *CSI$2,WA
       JSR  CMBLD
       MOV  (XS)+,XL
       BZE  XL,TNBEX
       MOV  XR,CMLHD(XL)
       MOV  PRNE1(XS),XR
       BRN  TNBEX
*
*      Plug initial value into arithmetic former
*
TNS93  MOV  PRNE2(XS),CMAIN(XR)
       BRN  TNBEX
*
*      Plug expression into iterator former
*
TNS94  MOV  PRNE2(XS),CMFXP(XR)
       BRN  TNBEX
*
*      Here for ...exp bit of a former, which unfortunately
*      gets recognised first
*
TNS53  MOV  =C$ARF,WB
       MOV  *CSI$3,WA
       ZER  -(XS)            for plugging
       MOV  =C$DFL,-(XS)     must be default step
       MOV  PRNE1(XT),-(XS)
       BRN  TNBBN
*
*      Here if its exp...exp again, we know its rest of
*      arithmetic former
*
TNS54  MOV  =C$ARF,WB
       MOV  *CSI$3,WA
       ZER  -(XS)
       MOV  PRNE3(XT),-(XS)
       MOV  PRNE1(XT),-(XS)
       BRN  TNBBN
       EJC
*
*      Here with abbreviated formers
*
TNS55  MOV  XT,TNBXT              save loc of sem RHS
       MOV  PRNE5(XT),XL          LALR problem, check syntax here
       JSR  CHKCP                 check if (subscripted) var
       PPM  TNE06                 error if not
       MOV  =C$ITR,WB
       MOV  *CSI$3,WA
       MOV  TNBXT,XT              recover orig XT
       MOV  PRNE5(XT),-(XS)
       MOV  PRNE3(XT),-(XS)
       MOV  PRNE1(XT),-(XS)
       JSR  CMBLD
*
*      We actually want a C$FMR node
*
TNS95  ZER  -(XS)
       MOV  XR,-(XS)
       MOV  =C$FMR,WB
       MOV  *CSI$2,WA
       BRN  TNBBN
*
*      iterator part of a full former
*
TNS56  MOV  PRNE1(XS),XR
       BRN  TNS95
*
*      Expressions involving AND, OR, IMP get treated as
*      IF expressions, because SETL specifies that both
*      operands are only evaluated if necessary.
*
*      p AND q = If p Then q Else False
*      p OR  q = If p Then True Else q
*      p IMP q = If p Then q Else True
*
.IF    .CNPF
TNX01  MOV  *CSI$3,WA
       MOV  =C$IFS,WB
.ELSE
TNX01  MOV  *CSI$4,WA
       MOV  =C$TVO,WB
.FI
       MOV  PRNE2(XT),XR     JVK-recover operator
       MOV  PRNE3(XT),-(XS)  If p
       BEQ  XR,=O$IOR,TNX02  jump with OR JVK-Rule #
       MOV  PRNE1(XT),-(XS)  Then q
       BEQ  XR,=O$IMP,TNX03  jump with IMP JVK-Rule #
       MOV  =FALSE,-(XS)     Else F
.IF    .CNPF
.ELSE
       MOV  =SCAND,-(XS)
.FI
       BRN  TNBBN
*
*      Finish off IMP
*
TNX03  MOV  =TRUE$,-(XS)     Else T
.IF    .CNPF
.ELSE
       MOV  =SCIMP,-(XS)
.FI
       BRN  TNBBN
*
*      Here with OR
*
TNX02  MOV  =TRUE$,-(XS)     Then T
       MOV  PRNE1(XT),-(XS)  Else q
.IF    .CNPF
.ELSE
       MOV  =SC$OR,-(XS)
.FI
       BRN  TNBBN
       EJC
*
*      EXPR block has its own CMTYP
*
TNX59  MOV  =C$EXR,WB
       MOV  *CSI$1,WA
       MOV  PRNE2(XT),-(XS)
       BRN  TNBBN
*
*      subscripts subscript
*
*      Again grammar is unfortunate.  We will have
*      recognised subscripts first, and have to plug the
*      exp field of subscript
*
TNX69  MOV  PRNE1(XS),XR
       MOV  PRNE2(XS),CMSXP(XR)
       BRN  TNBEX            sic
*
*      Simple subscript - build subscripted expression
*      sans the expression
*
TNX71  MOV  =C$SUB,WB
TNX73  MOV  *CSI$2,WA
       ZER  -(XS)
       MOV  PRNE2(XT),-(XS)
       BRN  TNBBN
*
*      Curly subscript
*
TNX72  MOV  =C$SBM,WB
       BRN  TNX73
       EJC
*
*      Slice tail  ( a .. )
*
TNX74  MOV  =C$SLC,WB
       MOV  *CSI$3,WA
       ZER  -(XS)
       MOV  PRNE3(XT),-(XS)
       ZER  -(XS)            clear end index
       BRN  TNBBN
*
*      Slice  ( a .. b )
*
TNX75  ZER  -(XS)            init sliced expr
       MOV  PRNE4(XT),-(XS)
TNX77  MOV  =C$SLC,WB
       MOV  *CSI$3,WA
       MOV  PRNE2(XT),-(XS)
       BRN  TNBBN
*
*      Slice head ( .. a)
*
TNX76  ZER  -(XS)            init no expr
       MOV  =INTON,-(XS)     init index 1
       BRN  TNX77            merge w slice
*
*      Subscripted things - plug deepest CMSXP field
*
TNX57  ZER  WB               general subscripted things
       BRN  TNX80
TNX58  MNZ  WB               subscr expr includes parenth
TNX80  MOV  PRNE1(XS),XR
       MOV  XR,XL
TNX81  BZE  CMSXP(XL),TNX82
       MOV  CMSXP(XL),XL
       BRN  TNX81
TNX82  BZE  WB,TNX83         jump unless ) in way
       MOV  PRNE3(XS),CMSXP(XL) get actual expression
       BRN  TNBEX
TNX83  MOV  PRNE2(XS),CMSXP(XL)
       BRN  TNBEX
*
*      Expressions involving binary ops
*      Build the node in the order - operator, right operand
*      left operand..
*
TNX11  MOV  =C$BOP,WB        type code
*
*      Merge to stack elments 2, 1, 3
*
TNX12  MOV  *CSI$3,WA        size of 3 element node
       MOV  PRNE2(XT),-(XS)
       MOV  PRNE1(XT),-(XS)
       MOV  PRNE3(XT),-(XS)
       BRN  TNBBN            go make CMBLK
*
*      Expression involving unary operator
*
TNX13  MOV  =C$UOP,WB        type code
TNX90  MOV  PRNE2(XT),-(XS)  get operator
       MOV  PRNE1(XT),-(XS)  and operand
       MOV  *CSI$2,WA        it s a 2 element node
       BRN  TNBBN
*
*      Here with monadic minus - SCANE will have given us
*      operator for dyadic minus
*
TNX24  MOV  =C$UOP,WB        type code
       MOV  =O$MMN,-(XS)     replace operator with monadic -
       MOV  PRNE1(XT),-(XS)  and operand
       MOV  *CSI$2,WA        it s a 2 element node
       BRN  TNBBN
       EJC
*
*      Here for binary form of compound operator
*
TNX30  MOV  =C$CMP,WB        type code
       BRN  TNX12            merge w other binary ops
*
*      Here for unary form of compound operator
*
TNX31  MOV  =C$CMP,WB        type code
       MOV  *CSI$3,WA
       MOV  PRNE2(XT),-(XS)
       MOV  PRNE1(XT),-(XS)
       ZER  -(XS)            no lhs for unary form
       BRN  TNBBN
*
*      Here to build CMBLK once args have been stacked
*
TNBBN  JSR  CMBLD            go get CMBLK
*
*      Merge to exit with value in XR
*
TNBEX  MOV  XR,R$SRP
       EXI
       EJC
*
*      Error productions
*
TNE00  ERB  010,syntax error in program
TNE01  ERB  011,error in program heading
TNE02  ERB  012,error in declaration
TNE03  ERB  014,error in procedure heading
TNE04  ERB  015,error in statement
TNE05  ERB  016,error in CASE tag
TNE06  ERB  018,error in iterator
TNE07  ERB  019,error in quantified test
TNE08  ERB  020,error in expression
       ENP
       EJC
*
*      TPCMP -- compare tuples for equality
*
*      On entry, both arguments are known to be tuples
*
*      (XL)                  left comparand
*      (XR)                  right comparand
*      JSR  TPCMP
*      ppm  loc              equal
*      ppm  loc              not equal
*      (WA)                  destroyed
*
*      TPCMP may be called recursively by COMPV
*
TPCMP  PRC  R,2
       BEQ  TPNEL(XL),TPNEL(XR),TPCM0
       EXI  2                immediate fail
TPCM0  MOV  WB,-(XS)         preserve a register
       MOV  XL,-(XS)
       MOV  XR,-(XS)
*
       ZER  WA               init index
TPCM1  ICV  WA               next index
       MOV  OFFS1(XS),XR         load TPBLK pointer
       JSR  TPELT            get element
       PPM  TPCX1            succeed if through
       MOV  XR,-(XS)         stack this one
       MOV  OFFS1(XS),XR         fetch other TPBLK
       JSR  TPELT            get its element
       PPM
       MOV  (XS)+,XL         unstack one we got first
       JSR  COMPV            compare these two
       PPM  TPCM1            try more if succeed
       PPM  TPCX2            fail if fails
*
TPCX1  MOV  (XS)+,XR
       MOV  (XS)+,XL
       MOV  (XS)+,WB
       EXI  1
*
TPCX2  MOV  (XS)+,XR
       MOV  (XS)+,XL
       MOV  (XS)+,WB
       EXI  2
       ENP
       EJC
*
*      TPELT -- get tuple element
*
*      (XR)                  Pointer to TPBLK
*      (WA)                  Index of element
*      JSR  TPELT
*      PPM  loc              Return if nonexistent element
*      (XR)                  Value of element or OM
*      (WB)                  Destroyed
*
*      SETL people cannot count, so indexing starts at 1
*
TPELT  PRC  E,1
       BGT  WA,TPNEL(XR),TPEL1 jump if tuple exhausted
       MOV  WA,WB            Copy index
       WTB  WB               convert to offset
       ADD  *TPNEL,WB
       ADD  WB,XR            point to element
       MOV  (XR),XR          load it for caller
       EXI
*
*      If index exceeds cardinality load an OMEGA
*      and take alternate return
*
TPEL1  MOV  =OMEGA,XR
       EXI  1
       ENP
       EJC
*
*      TUPPR -- convert tuple to a pair
*
*      On entry, the tuple is known to have 2 elements
*
*      (XR)                  ptr to TPBLK
*      JSR  TUPPR
*      (XR)                  ptr to PRBLK
*      (WA)                  destroyed
*
*      The temptation to perform the conversion in place
*      by overwriteing the TPBLK has to be resisted, as
*      it would leave PRBLKs in the wrong place in maps,
*      because of the way the hashing works
*
TUPPR  PRC  E,0
       MOV  XL,-(XS)         save for caller
       MOV  XR,-(XS)         save TPBLK
       MOV  *PRSI$,WA
       ZER  XL
       JSR  ALLOC            get the PRBLK
       MOV  (XS)+,XL         and recover TPBLK
       MOV  =B$PRL,(XR)
       MOV  TPDOM(XL),PRDOM(XR)
       MOV  TPRNG(XL),PRRNG(XR)
       ZER  PRNXT(XR)
       MOV  (XS)+,XL
       EXI
       ENP
       EJC
*
*      TRIMR -- trim trailing blanks
*
*      TRIMR is passed a pointer to an SCBLK which must be the
*      last block in dynamic storage. Trailing blanks are
*      trimmed off and the dynamic storage pointer reset to
*      the end of the (possibly) shortened block.
*
*      (WB)                  non-zero to trim trailing blanks
*      (XR)                  pointer to string to trim
*      JSR  TRIMR            call to trim string
*      (XR)                  pointer to trimmed string
*      (XL,WA,WB,WC)         destroyed
*
*      The call with WB zero still performs the end zero pad
*      and DNAMP readjustment. It is used from acess if kvtrm=0.
*
TRIMR  PRC  E,0              Entry point
       MOV  XR,XL            Copy string pointer
       MOV  SCLEN(XR),WA     Load string length
       BZE  WA,TRIM3         Jump if null input
       PLC  XL,WA            Else point past last character
       BZE  WB,TRIM4         Jump if no trim
       MOV  =CH$BL,WC        Load blank character
*
*      Loop through characters from right to left
*
TRIM1  LCH  WB,-(XL)         Load next character
.IF    .CAHT
       BEQ  WB,=CH$HT,TRIM2  Jump if horizontal tab
.FI
       BNE  WB,WC,TRIM4      Jump if non-blank found
TRIM2  DCV  WA               Else decrement character count
       BNZ  WA,TRIM1         Loop back if more to check
*
*      Here if result is null (null or all-blank input)
*
TRIM3  MOV  XR,DNAMP         Wipe out input string block
       MOV  =NULLS,XR        Load null result
       BRN  TRIM6            Merge to exit
       EJC
*
*      TRIMR (continued)
*
*      Here with non-blank found (merge for no trim)
*
TRIM4  MOV  WA,SCLEN(XR)     Set new length
       MOV  XR,XL            Copy string pointer
       PSC  XL,WA            Ready for storing blanks
       CTB  WA,SCHAR         Get length of block in BAUS
       ADD  XR,WA            Point past new block
       MOV  WA,DNAMP         Set new top of storage pointer
       LCT  WA,=CFP$C        Get count of chars in word
       ZER  WC               Set blank char
*
*      Loop to zero pad last word of characters
*
TRIM5  SCH  WC,(XL)+         Store zero character
       BCT  WA,TRIM5         Loop back till all stored
       CSC  XL               Complete store characters
*
*      Common exit point
*
TRIM6  ZER  XL               Clear garbage XL pointer
       EXI                   Return to caller
       ENP                   End procedure TRIMR
       EJC
*
*      UNION -- form set union
*
*      (XL)                  ptr to STBLK/MPBLK
*      (XR)                  ptr to STBLK/MPBLK
*      JSR  UNION
*      (XR)                  ptr to result block
*      (WA,WB)                destroyed
*
UNION  PRC  E,0
       MOV  XR,-(XS)         save
       MOV  XL,-(XS)         args
       MOV  STNEL(XR),WA     load length
       ADD  STNEL(XL),WA     compute max result length
       JSR  ALOTS            get a block for result
       MOV  =B$MPL,(XR)      initial type word
       ZER  STNEL(XR)        no elements yet
       MOV  (XS)+,R$UST      start with first set
       MOV  XR,R$URS         save result ptr
*
*      We go through each set in turn, adding elements to
*      the result.  We know the result block is big enough
*      so it will not have to be moved, except by GBCOL -
*      having ptr in R$ location takes care of that.
*
*      We go round this loop twice, using a flag to
*      remember first time
*
       EJC
       ZER  UFLAG            set first time flag
UNI11  MOV  *STSI$,XL        load initial set offset
*
UNI10  MOV  R$UST,XR         load current set
       JSR  NEXTS            get next element
       BNZ  WB,UNI20         jump out if set exhausted
       BEQ  XR,=OMEGA,UNI10  skip OMs
       MOV  XL,-(XS)         stack iterator
       JSR  COPYV            copy the element
*
*      (Too bad if copy is unnecessary)
*
       MOV  XL,XR            move copy ptr
       MOV  R$URS,XL         load result set
       BEQ  (XR),=B$PRL,UNI15 jump with pair
       MOV  =B$STL,(XL)      result is not a map
*
*      Yes, I know that might get done a lot of times
*
UNI15  JSR  ADSEL            add this element
       MOV  XL,R$URS
       MOV  (XS)+,XL         unstack iterator
       BRN  UNI10            inner loop
*
*      Here on inner loop exit
*
UNI20  BNZ  UFLAG,UNI30      right out if flag set
       MOV  (XS)+,R$UST      unstack other set
       MNZ  UFLAG            set flag for second time
       BRN  UNI11            go round again
*
UNI30  ZER  XL               clear possible garbage
       MOV  R$URS,XR         load result for caller
       ZER  R$UST            tidy up
       ZER  R$URS
       EXI
       ENP
       EJC
*
       TTL  SETL-S utility routines
*
*      APPLX -- apply an operator
*
*      In the case where an operator is applicable to only
*      one type of operand, APPLX is entered to check the
*      type and enter the evaluating routine if ok.
*
*      (XL) operand of monadic operator or
*           left operand of dyadic operator
*
APPLX  RTN
       ICA  XR               point to ok type word
       BEQ  (XL),(XR),APP10  is it what we have
       ICA  XR               no bump pointer
APP10  ICA  XR               point to routine
       MOV  XR,XL            copy entry point
       BRN  APPEX            merge to enter
       EJC
*
*      APPLY -- apply an operator
*
*      APPLY selects an appropriate operator routine, by
*      chhoosing one of the entries from its jump vector,
*      indexing by the EPI obtained from the operand in XL
*
*      (XL) operand of monadic operator or
*           left operand of dyadic operator
*
APPLY  RTN
       MOV  (XL),XL          get entry point
       LEI  XL               load EPI
       WTB  XL               convert to BAU offset
       ADD  XR,XL            point to appropriate routine
*
*      Continue by falling into APPEX
       EJC
*
*      APPEX -- enter operator routine
*      This is the common exit for APPLX and APPLY
*
*      (XL) operator routine entry point
*
APPEX  RTN
       MOV  (XS)+,XR         pop right operand
       MOV  (XL),XL
       BRI  XL
       EJC
*
*      EXFAL -- exit with the value FALSE
*
EXFAL  RTN
       MOV  =FALSE,XR
       BRN  EXIXR
       EJC
*
*      EXIOM -- exit with OMEGA
*
*      EXIOM continues by executing the next codeword
*      via EXIXR
*
EXIOM  RTN
       MOV  =OMEGA,XR
       BRN  EXIXR
       EJC
*
*      EXINT -- exit with integer result
*
*      (XL,XR)               may be noncollectable
*      (IA)                  integer value
*      BRN  EXINT            jump to exit with integer
*
*      EXINT continues by executing the next code word
*      which it does by falling through to EXIXR
*
EXINT  RTN
       JSR  ICBLD            Build ICBLK
*
*
*      EXIXR -- exit with result in (XR)
*
*      (XR)                  result
*      (XL)                  may be non-collectable
*      BRN  EXIXR            jump to exit with result in (XR)
*
*      EXIXR continues by executing the next code word
*      which it does by falling through to EXITS.
*
EXIXR  RTN
       MOV  XR,-(XS)         Stack result
*
*
*      EXITS -- exit with result if any stacked
*
*      (XR,XL)               may be non-collectable
*
*      BRN  EXITS            enter EXITS routine
*
EXITS  RTN
       LCW  XR               Load next code word
       MOV  (XR),XL          Load entry address
       BRI  XL               Jump to execute next code word
*
*      EXNUL -- exit with null string
*
*      EXNUL continues by executing the next code word
*      via EXIXR
*
EXNUL  RTN
       MOV  =NULLS,XR        return null string
       BRN  EXIXR
*
.IF    .CNRA
.ELSE
       EJC
*
*      EXREA -- exit with real result
*
*      (XL,XR)               may be non-collectable
*      (RA)                  real value
*      BRN  EXREA            jump to exit with real value
*
*      EXREA continues by executing the next code word
*
EXREA  RTN
       JSR  RCBLD            Build RCBLK
       BRN  EXIXR            Jump to exit with result in XR
.FI
       EJC
*
*      EXRND -- stack range or domain
*
*      Range and Dom operators merge here, because they have
*      so much code in common.
*
EXRND  RTN
       BEQ  (XR),=B$MPL,EXRD1 jump with known map
       JSR  CHKMP            else check
       PPM  EXRD1            ok
       BRN  XEDMR
*
EXRD1  BNZ  MPNEL(XR),EXRD6  test for empty set
       MOV  =NLSET,XR        if so, return empty
       BRN  EXIXR
EXRD6  MOV  XR,RNDMS         stack map pointer
       MOV  *STSI$,XL        initialise it offset
       ZER  RNDSV               zero counter
EXRD2  JSR  NEXTS            fetch element
       BNZ  WB,EXRD5         check wrapround
       BEQ  XR,=OMEGA,EXRD4  skip OMs
       ICV  RNDSV
       BNZ  RNGDM,EXRD3      jump for Dom
       MOV  PRRNG(XR),-(XS)  stack range element
       BRN  EXRD4
EXRD3  MOV  PRDOM(XR),-(XS)  stack domain element
EXRD4  MOV  RNDMS,XR         recover map
       BRN  EXRD2            loop
*
EXRD5  MOV  RNDSV,WA
       JSR  FMSET            form result set
       BRN  EXIXR
       EJC
*
*      FAILP -- pattern match fails
*
FAILP  RTN
       ICP                   no need to store into argument
       ICP                    or pop from stack
       ZER  R$PMS            clear for gbcol
       ZER  R$PPS
       MOV  =OMEGA,XR        return om
       BRN  EXIXR
*
*      EXTRU -- exit with the value TRUE
*
EXTRU  RTN
       MOV  =TRUE$,XR
       BRN  EXIXR
*
*      RECOV -- attempt error recovery
*      Note:  No error recovery yet for LALR version
*
RECOV  RTN
*
*      Here if no recovery is possible
*        JVK - clean up listing file using ERROR
*
       ERB  009,error recovery failed
       EJC
*
*      STMGO -- start execution of new statement
*
*      (XR)                  pointer to CDBLK for new statement
*      BRN  STMGO            jump to execute new statement
*
*      STMGO continues by executing the next statement
*
STMGO  RTN
       MOV  XR,R$COD         Set new code block pointer
       MOV  CDSTM(XR),KVSTN  Set stno
       ADD  *CDCOD,XR        Point to first code word
       LCP  XR               Set code pointer
       BRN  EXITS            and then exit for next code word
       EJC
*
*      STOPR -- terminate run
*
*      (XR)                  points to ending message
*      BRN STOPR             jump to terminate run
*
*      Terminate run and print statistics.  On entry XR points
*      to ending message or is zero if message  printed already.
*
STOPR  RTN
       JSR  PRTNL            Flush buffer
       MOV  =STGST,STAGE     Note final stage
.IF    .CSAX
       BZE  XR,STPRA         Skip if SYSAX already called
       JSR  SYSAX            Call after execution proc
STPRA  ADD  RSMEM,DNAME      Use the reserve memory
.ELSE
       ADD  RSMEM,DNAME      Use the reserve memory
.FI
       BNE  XR,=ENDMS,STPR1  Skip if not normal end message
       BNZ  EXSTS,STPR4      Skip if exec stats suppressed
       ZER  ERICH            Clear errors to int.Ch. Flag
*
*      Look to see if an ending message is supplied
*
STPR1  JSR  PRTNL            JVK-subst
*      JSR  PRTPG            Eject printer
       BZE  XR,STPR2         Skip if no message
       JSR  PRTST            Print message
       JSR  PRTIS              then print the buffer
*
*      Merge here if no message to print
*
STPR2  BNZ  EXSTS,STPR4      Skip if exec stats suppressed
       JSR  PRTIS            Print blank line
       MTI  KVSTN            Get statement number
       MOV  =STPM1,XR        Point to message /in statement XXX/
       JSR  PRTMX            Print it
       JSR  SYSTM            Get current time
       SBI  TIMSX            Minus start time = elapsed exec tim
       STI  STPTI            Save for later
       MOV  =STPM3,XR        Point to msg /execution time msec /
       JSR  PRTMX            Print it
       LDI  KVSTC            get statement count
       STI  STPSI            Save
       ILT  STPR3            Jump if negative
       MOV  =STPM2,XR        Point to message /stmts executed/
       JSR  PRTMX            Print it
       BZE  STPSI,STPR3      No divide by zero
*
*      Merge to skip message (overflow or negative stlimit)
*
STPR3  MTI  GBCNT            Load count of collections
       MOV  =STPM5,XR        Point to message /regenerations /
       JSR  PRTMX            Print it
       JSR  PRTIS            One more blank for luck
       EJC
*
*      STOPR (continued)
*
.IF    .CNPF
.ELSE
*
*      Print Profile Table.
*
       JSR  PRTNL            JVK-subst
*      JSR  PRTPG            eject the printer
       MOV  =PFM10,XR        msg /Program Profile/
       JSR  PRTST            print it
       JSR  PRTNL            really print it
       JSR  PRTNL            and a blank line
       MTI  PRLEN            load printer width
       DVI  PFCLW            divide by column width
       MFI  PFNCL            giving nr of columns
       MOV  =PFM15,XR
       JSR  PFPRH            print profile header (line 1)
       MOV  =PFM16,XR
       JSR  PFPRH            (line 2)
       MOV  =PFM17,XR
       JSR  PFPRH            (line 3)
       ZER  PFBBN            set initial block nr
       MOV  PFTBL,XL         point to top of table
STP3A  JSR  PRTNL            print outstanding line
       ZER  PFCOF            start at beginning of next
       LCT  WB,PFNCL         load column ctr
STP3B  ICV  PFBBN            bump to next block
       BGT  PFBBN,PFNBB,STP3D escape loop when all done
       ADD  *PFES$,XL        and incr table ptr
       LDI  (XL)             get nr of executions
       IEQ  STP3B            jump if never executed
       MOV  =PFPD2,PROFS     set pad position
       ADD  PFCOF,PROFS      for this column
       JSR  PRTIN            and print exec count
       MOV  =PFPD1,PROFS
       ADD  PFCOF,PROFS      set place for ...
       MTI  PFBBN            ... block nr
       JSR  PRTIN            print it
       MOV  =PFPD3,PROFS     point to next ...
       ADD  PFCOF,PROFS      ... print position
       LDI  CFP$I(XL)        get exec time
       JSR  PRTIN            print it
       LDI  CFP$I(XL)        re-get it
       MLI  INTTH            make into microsecs
       IOV  STP3C            omit if overflow
       DVI  (XL)             div by nr of excns
       MOV  =PFPD4,PROFS     say where ...
       ADD  PFCOF,PROFS      ... to print ...
       JSR  PRTIN            ... mcsec/excn
STP3C  ADD  =PFCWD,PFCOF     add col width to offset
       BCT  WB,STP3B         inner loop until line full
       BRN  STP3A            then outer loop for new line
*
STP3D  JSR  PRTNL            finish nicely
.FI
*
*      Check if dump requested
*
STPR4  ZER  WA               JVK-ABEND feature of SYSEJ not used
       ZER  WB
       MOV  R$FCB,XL         Get FCBLK chain
       JSR  SYSEJ            Exit to system
       EJC
*
*      SUCCP -- pattern match succeeds
*      Need to stack result and new value for search string var
*      (WB)                  # left chars in result
*      (R$PMS)               search string SS
*
SUCCP  RTN
       MOV  WB,PMSSL         Save # chars in result
       MOV  WB,WA
       ZER  WB               Take chars from left
       MOV  R$PMS,XL         get search string
       JSR  SBSTR
       MOV  XR,-(XS)         save result
       MOV  PMSSL,WB         new start loc for SS
       MOV  R$PMS,XL
       ZER  R$PMS            clear for GBCOL
       ZER  R$PPS
       MOV  SCLEN(XL),WA     compute length of remainder
       SUB  WB,WA
       JSR  SBSTR
       BRN  EXIXR            return with new SS
*
*      SUCRP -- right pattern match succeeds
*      Need to stack result and new value for search string var
*      (WB)                  # right chars in result
*      (R$PMS)               search string SS
*
SUCRP  RTN
       MOV  WB,PMSSL         Save # chars in result
       MOV  WB,WA
       MOV  R$PMS,XL         get search string
       MOV  SCLEN(XL),WB     find start of right string
       SUB  WA,WB
       JSR  SBSTR
       MOV  XR,-(XS)         save result
       MOV  R$PMS,XL
       ZER  R$PMS            clear for GBCOL
       ZER  R$PPS
       MOV  SCLEN(XL),WA     compute length of remainder
       SUB  PMSSL,WA
       ZER  WB               left side is new ss
       JSR  SBSTR
       BRN  EXIXR            return with new SS
*
*      Common error code
*
*      Overflow
*
EXIOV  RTN
       ERB  173,arithmetic operation caused integer overflow
EXROV  RTN
       ERB  174,arithmetic operation caused real overflow
*
*      Illegal types
*
EXCMP  RTN
       ERB  098,illegal or undefined operand type in test
*
*      Type incompatibility RTNs
*      If an operator routine detects a type incompatibility
*      it branches here to produce an error message.
*      This way, we make no assumptions about which operand
*      is wrong.
*
XECMP  RTN
       ERB  136,incompatible operand types for test
XEDIV  RTN
       ERB  127,non-numeric operand for /
*
XEDMR  RTN
       ERB  132,non-set operand for DOM or RANGE
*
XEDVI  RTN
       ERB  128,non-integer operand for DIV
*
XEMAX  RTN
       ERB  133,incompatible operand types for MAX
*
XEMIN  RTN
       ERB  134,incompatible operand types for MIN
*
XEMNS  RTN
       ERB  129,incompatible operand types for -
*
XEMUL  RTN
       ERB  130,incompatible operand types for *
XENPW  RTN
       ERB  135,incompatible operand types for NPOW
XEOIN  RTN
       ERB  150,undefined operand in membership test
*
XESLE  RTN
       ERB  179,end slice subscript exceeds length
XESLI  RTN
       ERB  177,slice subscript not an integer
XESLL  RTN
       ERB  175,slice subscript is too large
XESLN  RTN
       ERB  178,end slice index negative
XESLT  RTN
       ERB  206,illegal rhs type for slice assignment
XESL0  RTN
       ERB  176,slice subscript zero or negative
*
XESPN  RTN
       ERB  284,string prim second arg neg or zero
XESPI  RTN
       ERB  285,string prim requires integer second arg
XESPS  RTN
       ERB  286,first string prim arg not string
XESPA  RTN
       ERB  287,string primitive requires two args
XESPT  RTN
       ERB  288,invalid first arg for string primitive
XESPP  RTN
       ERB  289,string prim pattern arg not string
*
XEPLS  RTN
       ERB  137,incompatible operand types for +
*
XEREM  RTN
       ERB  131,non-integer operand for MOD
XEVAL  RTN
       ERB  114,VAL operand is not a numeric string
*
       TTL  S E T L - S -- STACK OVERFLOW SECTION
*
*      Control comes here if the main stack overflows
*
       SEC                   Start of stack overflow section
*
       ICV  ERRFT            Fatal error
       MOV  FLPTR,XS         Pop stack to avoid more fails
       BNZ  GBCFL,STAK1      Jump if garbage collecting
       ERB  156,stack overflow
*
*      No chance of recovery in mid garbage collection
*
STAK1  MOV  =ENDSO,XR        Point to message
       BRN  STOPR            Give up
*
       TTL  S E T L - S -- ERROR SECTION
*
*      This section of code is entered whenever a procedure
*      return via an ERR parameter or an ERB opcode is obeyed.
*
*      (WA)                  is the error code
*
*      The global variable STAGE indicates the point at which
*      the error occured as follows.
*
*      STAGE=STGIC           error during initial compile
*
*      STAGE=STGXT           error at execute time.
*
       SEC                   Start of error section
*
ERROR  MOV  WA,ERCOD         Save ERROR code
       MOV  STAGE,XR         Load current STAGE
       BSW  XR,STGNO,ERR06   Jump to appropriate error circuit
       IFF  STGIC,ERR01      Initial compile
       IFF  STGXT,ERR06      Execute time
       IFF  STGST,ERR06
       IFF  STGGB,ERR06      Garbage collection
       ESW                   End switch on error type
       EJC
*
*      Error during initial compile
*
*      The error message is printed as part of the compiler
*      output. This printout includes the offending line (if not
*      printed already) and an error flag under the appropriate
*      column as indicated by SCNSE unless SCNSE is set to zero.
*
*      After printing the message, the generated code is
*      modified to an error call and control is returned to
*      the CMPIL procedure after resetting the stack pointer.
*
*      If the error occurs after the end line, control returns
*      in a slightly different manner to ensure proper cleanup.
*
ERR01  SSL  INISS            reset subroutine stack
       MNZ  ININX            suppress execution
       MNZ  EXSTS              and execution stats
       MNZ  ERFLG            and semantic actions/codegen
       BLE  WA,=MXLXE,ERR11  always report lexical errors
*
*      Error suppress flag not yet supported in LALR
*
ERR11  MOV  ERICH,ERLST      Set flag for LISTR
       JSR  LISTR            List line
       JSR  PRTIS            Terminate listing
       ZER  ERLST            Clear LISTR flag
       MOV  SCNSE,WA         Load scan element offset
.IF    .CAHT
       MOV  WA,WB            Copy offset
       ICV  WA               Increase for ch$ex
       JSR  ALOCS            String block for error flag
       MOV  XR,WA            Remember string ptr
       PSC  XR               Ready for character storing
       BZE  WB,ERR04         Jump if error flag is first char
       MOV  R$CIM,XL         Point to bad statement
       PLC  XL               Ready to get chars
       LCT  WB,WB            Loop counter
*
*      Loop to replace all chars but tabs by blanks
*
ERR02  LCH  WC,(XL)+         Get next char
       BEQ  WC,=CH$HT,ERR03  Skip if tab
       MOV  =CH$BL,WC        Get a blank
       EJC
*
*      Merge to store blank or tab in error line
*
ERR03  SCH  WC,(XR)+         Store char
       BCT  WB,ERR02         Loop
*
*      Merge in case of no preceding blanks
*
ERR04  MOV  =CH$QU,XL        Use question mark as pointer
       SCH  XL,(XR)          Store at end of error line
       CSC  XR               End of SCH loop
       MOV  =STNPD,PROFS     Allow for statement number
       ADD  =STNPD,PROFS     Adjust for line number
       MOV  WA,XR            Point to error line
       JSR  PRTST            Print error line
.ELSE
       MTI  PRLEN            Get print buffer length
       MFI  GTNSI            Store as signed integer
       ADD  =STNPD,WA        Adjust for line number
       ADD  =STNPD,WA        Adjust for statement number
       MTI  WA               Copy to integer accumulator
       RMI  GTNSI            Remainder modulo print bfr length
       STI  PROFS            Use as character offset
       MOV  =CH$QU,WA        Get question mark
       JSR  PRTCH            Generate under bad column
.FI
*
*      Here after placing error flag as required
*
       JSR  ERMSG            Generate flag and error message
       ADD  =NUM03,LSTLC     Bump page ctr for blank, error, BLK
       ZER  XR               In case of fatal error
       BHI  ERRFT,=NUM03,STOPR Pack up if several fatals
       ICV  CMERC            Bump error count
       BRN  STOPR            JVK - for now, always stop
       EJC
*
*      Error at execute time.
*
ERR06  JSR  PRTNL            JVK-subst Flush output
       MOV  =STGST,STAGE     about to stop
*      JSR  PRTPG
       JSR  ERMSG
       ZER  XR
S$YYY  BRN  STOPR            Label to mark end of code
*
*      End of assembly
*
       END                   End SETL-S assembly
